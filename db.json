{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/error-page.png","path":"img/error-page.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Go八股.md","hash":"660a3bd4ff492f465155d1dc0b3538eafb3ddd5b","modified":1746532612193},{"_id":"source/_posts/Hgame2025赛后学习.md","hash":"f208d82249b97a6bcc618741ee5bfe59507fa34e","modified":1746532612192},{"_id":"source/_posts/Java.md","hash":"f2667c491adff4f2027eea302a430927f3bd6bf7","modified":1746532612193},{"_id":"source/_posts/Leetcode&洛谷刷题记录与思考.md","hash":"b1096e2dfa0bf5eb9caa484c25db54c913dce3ea","modified":1746532612194},{"_id":"source/_posts/Linux云服务器捣鼓指北.md","hash":"582979bcec43b964888bd645f336bc5468539b3d","modified":1746532612193},{"_id":"source/_posts/手写RPC框架学习.md","hash":"7a8994d6af35aa59a0053e8adca77f2a3a709178","modified":1746532612193},{"_id":"source/_posts/杭电助手后端二面经历.md","hash":"1036a1873fef9bd5dc3eea465ebc144503f09fb9","modified":1746532612193},{"_id":"source/_posts/杭电助手后端面试总结.md","hash":"21a829b7b900f63fc04f0729ffbbca2c9652c66d","modified":1746532612193},{"_id":"source/_posts/img/QQ20250101-005806.png","hash":"1727e5f475b06dae86eb4f463ffbc8f486e43e5a","modified":1735664304000},{"_id":"source/_posts/img/QQ截图20240503122825.jpg","hash":"4e3c6a90aa22ff5bf4dd2dcaa2913874976a3115","modified":1714710510000},{"_id":"source/_posts/img/QQ截图20240525002142.jpg","hash":"06df2d86703f9c947cb33a98ac0d7ddce46c2801","modified":1716567716000},{"_id":"source/_posts/img/QQ截图20240525003607.jpg","hash":"8316710238ddd24c048095958c18935063a5daae","modified":1716568570000},{"_id":"source/_posts/img/RPC流程图.png","hash":"762e7f41474bb6ca5838d22a8328efbe1e183a4c","modified":1744352606000},{"_id":"source/_posts/img/流程图.png","hash":"762e7f41474bb6ca5838d22a8328efbe1e183a4c","modified":1744352586000},{"_id":"source/_posts/img/QQ截图20240525002925.jpg","hash":"4d60a02a69405961c7ae502c6dfc04be13e0da19","modified":1716568168000},{"_id":"source/_posts/img/QQ截图20240525025835.jpg","hash":"ace774a7e659ce62e39a852f259a0c5c89982dea","modified":1716577118000},{"_id":"source/_posts/img/QQ20241008-222526.png","hash":"acb00d5b4f6f1cfad0e86732174a5b2ce7c9edee","modified":1728397538000},{"_id":"source/_posts/img/QQ20250101-184342.png","hash":"38d5b42c683fa16a19b25f12bb49bbb22c174f37","modified":1735728226000},{"_id":"source/_posts/img/QQ20241003-011900.png","hash":"b200359a2afa74e522830d0a1a89566d1a89aa0f","modified":1727889584000},{"_id":"source/_posts/img/路由分组.png","hash":"7aeb7c515f296a9d544ebe48681494909b8ebbb1","modified":1738214798000},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1746445144349},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"e1b9096ae0c4e5ef0a911aec05dbad4a3aae3173","modified":1746445144416},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"92e45255b8725f0a00450c88fcfd51ec61e1db67","modified":1746445144415},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"7166aff350fcf84cbc01835fad5731eb855cecd7","modified":1746445144576},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"0f469650107841dc1dc716aa94b3ca2bb0721762","modified":1746445144415},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"a2704f0406484fdae3410e9992cf996f9859356e","modified":1746445144577},{"_id":"node_modules/hexo-theme-butterfly/.github/FUNDING.yml","hash":"da5e77f5e0cdb7e11b36546fb6796d10e3dfbe5d","modified":1746445144577},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1746445144577},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1746445144577},{"_id":"node_modules/hexo-theme-butterfly/languages/ja.yml","hash":"a281d3cc3e117e90597b783dc5569dba3976d2eb","modified":1746445144577},{"_id":"node_modules/hexo-theme-butterfly/languages/ko.yml","hash":"c7d861c58f204f47a5b4d6e118e1f1e8fb8a852f","modified":1746445144577},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"e0bf36edf18cf3380b900be7528b536252990c26","modified":1746445144578},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-HK.yml","hash":"bac3063ad2892be232f7d91361c28585a3cc7eb5","modified":1746445144578},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"bd7ee35aa30964493d2729ef105bb86331b096c3","modified":1746445144578},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1746445144545},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"a7e9805a781e34e38d27462e6ce2a5821c34bb9f","modified":1746445144554},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"a93004cc8ec8050df603d32a6e6e02cd96fd9875","modified":1746445144559},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"7ce2a49c6c41847de4ccea377ade116339984434","modified":1746445144561},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"65c4a49c65c3fc4d9dc88b9791a75710c698c3a1","modified":1746445144562},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"ca5333bd262cb58c195c844b593a0eed0c721766","modified":1746445144564},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"10ce05c8dbde09f53bdabe40b5388de9ccc71a31","modified":1746445144576},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1746445144577},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1746445144577},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1746445144578},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1746445144578},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"f9b02aac0dbbb2b71c037dd215e70c8b7ec7741c","modified":1746445144544},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"6bd41add3a45e55d5e51eab5285a2d1a909d37f3","modified":1746445144556},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"1d11e334b22dbbedcb0f751f9ee9789d4416605e","modified":1746445144557},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"e5e6c05a621483b3542f2884e8ba45e84b1e973a","modified":1746445144560},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"bd45e6fa935ace9cb54499b0491dacfb78ccc354","modified":1746445144561},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"43f951b639038f3bc01deea03368d8dcf492cbb0","modified":1746445144563},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"3e65b7bf6bccccbba7e15349f0a44f15c64c5b5e","modified":1746445144564},{"_id":"node_modules/hexo-theme-butterfly/scripts/common/postDesc.js","hash":"272613a71d16f0de6dac883be4839259f774be76","modified":1746445144400},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"039fc75f363d79669b0b2177d929cdff6f2ef7a4","modified":1746445144392},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1746445144392},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"7b1b16e1e8e08245a345764616956be50487eb53","modified":1746445144393},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1746445144393},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/merge_config.js","hash":"10ffed853a935498f1f5da2c5b57200c957874a7","modified":1746445144399},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"bac639c404588ea62e601ef0bcd368c3bd0119af","modified":1746445144407},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1746445144415},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"b23108d29fff3e32384d8689c8bcd2ab306a1ae7","modified":1746445144400},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"20a6ebf63439501a4b3fc81e7a2a2ea5d103bace","modified":1746445144401},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"3eb0bbb1288dc7b0ff82cc46ceb53bd666893416","modified":1746445144392},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"0cdf781a8c14d7b50d309e69f282ec7b178804bb","modified":1746445144392},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/getArchiveLength.js","hash":"bf77635e920eaf52bceebc95f87c7c87a7ca8038","modified":1746445144393},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"00c5742ad1c75b3c5684d02ffc6a1921399e5376","modified":1746445144398},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"a07b586b510aa2df953102d998e84207acc34f9b","modified":1746445144400},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"950b7d0966429bf0f9e6c5e1161e50e545e320b4","modified":1746445144406},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/series.js","hash":"45367c4ce827329867dbcc750ec125da9ccb2cfd","modified":1746445144407},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"2f44e1b3ccd170b256eae178299d6fa933a8d490","modified":1746445144392},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/chartjs.js","hash":"195ba802d7e8406c155124a9c939a2318f82938b","modified":1746445144392},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"25eefe10189caf3910a0e5d5b2f2043ae9255531","modified":1746445144393},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"fa3d0a64f7fce4aff7928d4ddd95548978ba001c","modified":1746445144393},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"f02fb085a88a2c0c82aeffacc24e1b71c74bd7c0","modified":1746445144393},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"89c6c78d2db43b190055d5690741a79bab4f3e7e","modified":1746445144398},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"cf0bc17d0180231167cc6aa8a00fc64f198cb9f9","modified":1746445144398},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"50d8d8fac5c5b6e26317028895d7d82a2cf46606","modified":1746445144399},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1746445144400},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"f589fb6646bd17cf12d77a9b251dd614e1c8b899","modified":1746445144407},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/series.js","hash":"40bc9a065e3a1423e0e66f4911e00713ca9f5e9e","modified":1746445144407},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"3c486b149e28edd1a06843f05a5c355000991b82","modified":1746445144407},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"176804f07567aa80f1ed95897a968a996b155dec","modified":1746445144407},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1746445144571},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"d1eec577074ab7b262182885576135bf1896e12c","modified":1746445144574},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1746445144391},{"_id":"node_modules/hexo-theme-butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1746445144543},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1746445144377},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1746445144377},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"5a52047b8520f79864d5a4ee2379a29751aead23","modified":1746445144398},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"fdb5482d04a75bd79946ad1ed291d281d0e9362d","modified":1746445144415},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"48637ad8e405306772b93837f33400bde1055819","modified":1746445144415},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"e93a36d3c29b5a02c7f26a23f96e1f84b063cbe8","modified":1746445144561},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"e792a435afee1f9491095084a00dc77e3522c1fd","modified":1746445144545},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"9ea75b06f19bf356f340f4a3fc1bdc0713cfe445","modified":1746445144555},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"56a3c32de1a15627ff38c67f1131cdd6ec5ac924","modified":1746445144555},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1746445144557},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"1e1a69aa2cbda2e621c741b3802093244b3cc04e","modified":1746445144562},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"83ed05ef1e39f2ee70c3fba2cf96e488d8ffec66","modified":1746445144563},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1746445144564},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/structured_data.pug","hash":"1b83ae33961528f128596753fd05067c672d6bff","modified":1746445144564},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"44331c9db74b281b5c5c41439d3407a9076df1a1","modified":1746445144558},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"733184f88e3a586a5fcc9d193ad500556b6c8eed","modified":1746445144560},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"18b984ce184ea53d2dff5a03cc2d0d39d2ec3406","modified":1746445144560},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"7d799c4694adb6e265e3f4b975d7f7f6a7021a17","modified":1746445144562},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"e2d31e0f450ad42c47f7ee96375799342bf2f19b","modified":1746445144564},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"a2f7d69ca7ec58f24fe7d4e04ae21d5b62b01567","modified":1746445144557},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"d76ce71ba106e350670c021a3dcae57547d01830","modified":1746445144558},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"9d2d539555bab495959b9df734ed5c43a9f9e5a9","modified":1746445144561},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"ef7afe0df7a3746744ac8185da7163b7406120ca","modified":1746445144552},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/indexPostUI.pug","hash":"f3389fa9ae4fa32e3c16573286583bc3023e57ad","modified":1746445144559},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/404.pug","hash":"15d32c511e4875066fcbe9cb84c3ada07b5a7c41","modified":1746445144544},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1746445144554},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"efb40388e37cca0b5e7c3c66e811a42f8d32c910","modified":1746445144555},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"6b0fa5f048aca8e9cbe56978301af918cf7ac34a","modified":1746445144556},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/shuoshuo.pug","hash":"b2423cfc57a5e3a0e1112ff7c18d5c5c720d89d5","modified":1746445144563},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"79ad31eb72a9e14007770b18a426406a25315b38","modified":1746445144564},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/outdate-notice.pug","hash":"b7ce9484bc5c97ea6154f0b78fb9b8951fafedbd","modified":1746445144561},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"b96c232e5178d927987791d9ae386dd83679535a","modified":1746445144562},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"db92f25ff3fd061882f81bf74ca560ff66983a0c","modified":1746445144563},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"ed79fef5b5025415ea12eaed970f3fe7f6ef9596","modified":1746445144545},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1746445144556},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"efe4f8019632b51c92c4f7628758538305e06e47","modified":1746445144562},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"88f979a0b1a19eeb0db229247833bf9c6865c3b9","modified":1746445144562},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"236c3ce26dd76e80b04d457789475c42da5ac0c8","modified":1746445144564},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/umami_analytics.pug","hash":"bc35a1552d26ecdeeadbf06300078dbb5128a6e5","modified":1746445144565},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1746445144553},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1746445144553},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1746445144553},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"1aba8aa7cd767dc96879d13a13b4c8ceb9023233","modified":1746445144553},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1746445144553},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1746445144553},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"d8753772889b5d0f4d15639ed6af5e91e53b1d03","modified":1746445144553},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1746445144553},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"1dd19a564320d248dbcee7f118a5b96c6466da65","modified":1746445144554},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1746445144554},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1746445144554},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1746445144554},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"fcddd80cdeb6aa81f342cd9f0102302f6ba087a8","modified":1746445144554},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"45f620cd87b9ef2aa9d1e024e697ed6b4eecff34","modified":1746445144559},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"d12340a7df4601b9a23f070e16645861aeb3bb0a","modified":1746445144570},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"4fcb8222b9548e22f7b76f12d33e3698240cbae0","modified":1746445144571},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"67062d597408068e4a59e95851e98fed34b745da","modified":1746445144571},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"a51edfd3e499e7d38c32241c40e8e4d371efca73","modified":1746445144574},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"ba174889e770ae9f6683379b9eae9d8c94253080","modified":1746445144567},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"4cc02bcbaa4a1933a82a9ea57a603fe2d059fc77","modified":1746445144568},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1746445144568},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"d7b988d8588207086670f39aa49fce442c429f7a","modified":1746445144569},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"094108f2a4e351a2fa496d6bd3e2388151416b3f","modified":1746445144570},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1746445144572},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"7d7554573c005399bc8c2264a85896d2d51be1e1","modified":1746445144572},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"543eaf9c7df7e0db841e5946ee5f9082c3c46290","modified":1746445144572},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"ef8e8549fe7ad4b99793844a93b4a89f77f417d5","modified":1746445144573},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"d9cdf564a822a585e67fd5bac8573ba87eeb3743","modified":1746445144573},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"a0f5835f04358122e8b1d38dd3e8da09a1b5b431","modified":1746445144573},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"084dc4dfb41f55e237a9d6cf8c2f5dba729b83be","modified":1746445144574},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"0af7c8754f04bdd9a02a14d880774753bd2e35ee","modified":1746445144574},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"4c9849df9c68d892c7df0ca28123aeb0dc9dc424","modified":1746445144568},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"ad66212554468b7067590308ed4cf40524fea662","modified":1746445144573},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"205ccc7d0ec6ce1193b46bc0c9ce0385594581fb","modified":1746445144567},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"5abe5480d83ff8b452a780a484d50a44091475bf","modified":1746445144567},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"c4cda7b0c99015df29ce00fdfddd2f7679653754","modified":1746445144568},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"dcff804c4c237e1e908481b44c1ac4e39ac0da34","modified":1746445144568},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"1f8d715faf3b91b53426e38195c0920afb3bfa1c","modified":1746445144569},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"992d192db7d1c96e995b85ed11c20c571d33fbad","modified":1746445144571},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/shuoshuo.styl","hash":"79bb1d9a27822ed5675d1e52f5dbd0e2f5d5010a","modified":1746445144573},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"7543bb688876a946538d66b991c71b94b5216277","modified":1746445144574},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"d8a8275a68a1421c4c09b604cf78bea16c1d0463","modified":1746445144567},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"6c4cbdadd9a49029fe0c59e29808d873e5b6b6ee","modified":1746445144571},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"1f2b86df86df81c3a59377b29102314ffc73dfa6","modified":1746445144572},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"de8437a058a315d14d7e7034066f095b7b3ed4b4","modified":1746445144567},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"30d1f809efd252ed0233d96d4374efd2b01d2292","modified":1746445144570},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1746445144570},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"d27dbccaf3de1c9158d19e4fd49a25953cb5778d","modified":1746445144570},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"3be8d0a75e7cc96548667cae0cb6a474279bd0b5","modified":1746445144572},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"216f52fefc2274b542b549d8470503e6f1a308fb","modified":1746445144572},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1746445144572},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/series.styl","hash":"0657169849bc4bf4d93b5492ade040c8f58c1901","modified":1746445144573},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"3a88eedcb694da79e92581ce50cb1a430b1fb615","modified":1746445144574},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"e846ddaef494d46cdfa2379deacfe74fa1cc5264","modified":1746445144574},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1746445144350},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"7119f2f2943de71999d3dd6ba5c60cde846f114b","modified":1746445144392},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"a2b783230a9143de69004cfc914d9f55e6fc1660","modified":1746445144398},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"febff991595504d8e850ced0b9cc090f02ed97f0","modified":1746445144544},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f0a90d8e39915a74b16ef22e851f179415cd7eaa","modified":1746445144558},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1746445144550},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1746445144556},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"cbfbcf34a24d21ba2b21cf9eedb76f4c3c563c5a","modified":1746445144556},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1746445144558},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1746445144563},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"b5db4203a1392385838c73549ddeae0a4be67eba","modified":1746445144565},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"7884883ec15792f7e54daacb3c62b851dde2b66a","modified":1746445144565},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1746445144566},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"5b29badecbbe828112c001156023fc0566045cf6","modified":1746445144555},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"24d094fd917947c0ca7492fa094328b1a183b873","modified":1746445144555},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"e8438941085def0591a72fc9b0d705dbf107f54f","modified":1746445144558},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"62466b251052cae609b6369d4cb4b6a85320757d","modified":1746445144565},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"89c63a5f0c0ab6314de7158fbc8fcbc84997fc55","modified":1746445144552},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f2ea5249b3e6670f6c8c77868f4f42c502e43830","modified":1746445144556},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"c81fa7d8a5cb96d1ae07bfa8c46b84a58161add1","modified":1746445144556},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"8af585e6d6f73ee57114eefad574dc6e8ea9f570","modified":1746445144556},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"592b2251db6c1abeb8b0eebe3b2e6d9aa0dec445","modified":1746445144557},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"58914c58a190e3bc0aa37cb581e77e442b563501","modified":1746445144557},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1746445144559},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1746445144559},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"7a80231fc71822e503879383a2d9611edf1d72dd","modified":1746445144560},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"84f7cfde00f929fa3dc40349bcab060ec68f1b9f","modified":1746445144563},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"53d99831f29aeb2e336ed1407d79590041f77002","modified":1746445144565},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"30a7d157890de69deab28baa47fb7bb28b040efd","modified":1746445144565},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"24f18b0c67803210d53abbf9c1d454c000b06eee","modified":1746445144566},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"e2bf15357485cd502414b3b20f5b1f762a2fd014","modified":1746445144566},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/chartjs.pug","hash":"732eb1118ea1a73aa5c164d639097c614f8e9953","modified":1746445144554},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"af66d13204030d47537b9e31a6173e63589ce7ff","modified":1746445144559},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"b83db9fa64d42a0bfd97efb660e09be3f166a144","modified":1746445144560},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"db2f4fff80a1166476ea76ae004aa186df11bad3","modified":1746445144560},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"ca2fc5928ca292f29fd8333c73733344994096fb","modified":1746445144560},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"187302dbc916852ff2fdf47061e272c061611dda","modified":1746445144552},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"27fa75affebc6e84a487c62bceff783bde595256","modified":1746445144555},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"fa4b4194749d05f7249f365f2b89c0281057ce54","modified":1746445144555},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"72e2970b23570e308f8af5d8ba8e5e3321d01bbf","modified":1746445144557},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"a7c07dbc1e970a5b247091458e1ee9b144a3366d","modified":1746445144559},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"34edfebf0cace0852806be774910ccb0e0914650","modified":1746445144563},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"d2e12a9fc302a4efe52c90d44896fbd73e193a1f","modified":1746445144565},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d376ec17fb19fcdcf0d2ad71330190146d3af879","modified":1746445144566},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ec6c685080634ac46ffbea1b8f10313388888f43","modified":1746445144566},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"7f0ede1cd3fed2669c94a8e1b21bc0b183f310b8","modified":1746445144545},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"013756ff3363344987cc00fc9bd833baf193c341","modified":1746445144556},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"f8557548d2ad8dd149c562193991c6c6cda02415","modified":1746445144559},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"2622b4cf9189fa23e4a422aaf9ef272e4f2c6137","modified":1746445144560},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"f5ee1c9c8ffa4bca972d30f4de69268b8d47f052","modified":1746445144544},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"e51e896ccb13900de38dc81cf44dc789e2418a12","modified":1746445144559},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"efef352c1d122409575386bf3894dce8e87032e2","modified":1746445144563},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"9f02598b5e4296aec6470639d4bac4c9ac46392e","modified":1746445144569},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"ef52ebf1e8e751a412f9456fdaeee7d88afd9a72","modified":1746445144571},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"077ec530831be1d80e93da380406b9f5abd0918a","modified":1746445144569},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"1883c91d43bff10aae55122a21e0b064b6f5c9dd","modified":1746445144571},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"de4bb5fc2dfca368b35e4c1109c92f7abc9e2245","modified":1746445144572},{"_id":"node_modules/hexo-theme-butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1746445144534},{"_id":"public/2024/10/08/杭电助手后端面试总结/index.html","hash":"3eeadff00902329878a13b394d5d9e3dcef93738","modified":1746718848153},{"_id":"public/2025/03/03/Java/index.html","hash":"6b785ceeb2809778546526d63d33121b9f04f49f","modified":1746718848153},{"_id":"public/2025/03/05/杭电助手后端二面经历/index.html","hash":"89ce75e599c9d27b045bc0b428819184fec0156e","modified":1746718848153},{"_id":"public/2025/03/05/Linux云服务器捣鼓指北/index.html","hash":"24afa5af76391e3e0cdd9755c049fdadebc51b39","modified":1746718848153},{"_id":"public/2025/03/07/Go八股/index.html","hash":"b48c2cfd6165bf15b8f5bb47eb2d37b17eb505e3","modified":1746718848153},{"_id":"public/2025/03/07/Hgame2025赛后学习/index.html","hash":"93eca966d4b3f5c298737d999949dbec155f8d4e","modified":1746718848153},{"_id":"public/2025/05/05/手写RPC框架学习/index.html","hash":"bdc6aeff14369be0bc276131006b69608a52e6f2","modified":1746718848153},{"_id":"public/2025/05/06/Leetcode&洛谷刷题记录与思考/index.html","hash":"c4e09535c4eea015abe448f25151c8a6bbaa498a","modified":1746718848153},{"_id":"public/archives/index.html","hash":"e4fa73a7ef55fab8773f121fd4c3d0acb971f5d4","modified":1747587529991},{"_id":"public/archives/2024/index.html","hash":"076f84339e84e8b17eb047b7ed738da5261fcbee","modified":1747587529991},{"_id":"public/archives/2024/10/index.html","hash":"6329c0587b32ac4e99900aac3718d1b59cc0604e","modified":1747587529991},{"_id":"public/archives/2025/index.html","hash":"7fa6e6d27f8e16d5d17eb40e55443c0b1985ff0e","modified":1747587529991},{"_id":"public/archives/2025/03/index.html","hash":"b042b677fd6621447cbea969c427f1fb5ac36786","modified":1747587529991},{"_id":"public/archives/2025/05/index.html","hash":"e1d49ac784db610446c06f421d932e7fb121dd2b","modified":1747587529991},{"_id":"public/index.html","hash":"466741f83f1937f18b638652ce599829e9ea3e49","modified":1747587529991},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1746718848153},{"_id":"public/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1746718848153},{"_id":"public/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1746718848153},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1746718848153},{"_id":"public/css/index.css","hash":"4c86f8d1af5215cb8de40129426ecb3c26605674","modified":1746718848153},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746718848153},{"_id":"public/js/main.js","hash":"fb746a3e67d0373deea8481110dd436fea4ca38c","modified":1746718848153},{"_id":"public/js/tw_cn.js","hash":"7ef59df188ea523da89f4caf69c5c0f14e78da69","modified":1746718848153},{"_id":"public/js/utils.js","hash":"fd3c26366c78dd82bc87d4ddebe76c582122e1b7","modified":1746718848153},{"_id":"public/js/search/algolia.js","hash":"e5821f78381af9f0f646952a7dd118daab2a79a6","modified":1746718848153},{"_id":"public/js/search/local-search.js","hash":"4e11d033fb58563f5e1b497f1a6f1c62d3501ee6","modified":1746718848153},{"_id":"public/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1746718848153}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Go八股","date":"2025-03-07T08:43:36.000Z","updated":"2025-05-06T11:56:52.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"noticeOutdate":null,"_content":"\n# Go八股\n\n## 有限状态机\n\n也叫有限自动状态机, 写过dp的话, 其实就说明已经用到过了, 本质上就是一个状态转换成另一个状态, 状态之间可以双向也可以单向, 同时也有纯粹的只进不出的状态, 也许是故意设计成这样的, 避免一个错误产生后, 程序仍然继续运行, 感觉会用在一些比较特殊的业务场景, 需要重新启动估计. 对于不需要重新启动的业务, 感觉在加一个处理异常的状态, 再重新转换回正常的状态即可.参考这篇文章[有限状态机FSM(finite state machine) 一_fsm statemachine-CSDN博客](https://blog.csdn.net/liqiangeastsun/article/details/118932263)\n\n同时文章中提到了, 如果只是使用`if-else`语句进行判断, 最后会造成代码的不可读性. 通过使用一个通用的方法, 是比较好的办法. 通过定义一个抽象类`statusBase`, 在其中定义三个抽象方法`OnEnter` , `OnExecute`和`OnExit`. 对于每个状态去具体的实现这是三个方法从而实现不同状态的转移, 提高代码的可读性.\n\n```java\npublic abstract class StateBase\n{\n    // 当前类型\n    protected StateEnum _state;\n    // 状态转换事件，要转换状态的通知\n    protected Action<StateEnum> _transitionEvent;\n    public StateBase()  { }\n\n    // 进入该状态\n    public abstract void OnEnter();\n\n    // 执行该状态的行为\n    public abstract void OnExecute();\n\n    // 退出该状态\n    public abstract void OnExit();\n\n    //返回当前类型\n    public StateEnum State\n    {\n        get { return _state; }\n    }\n    \n    public void SetTransitionEvent(Action<StateEnum> transitionEvent)\n    {\n        _transitionEvent = transitionEvent;\n    }\n}\n\n```\n\n## 一致性\n\n​\t由于后端处理的很多都是与数据相关, 但是, 在当今的互联网服务中, 很明显, 没有办法再使用单一的服务端提供服务, 一方面是能够处理的请求实在是有限, 同时, 将所有的数据都保存在同一 服务端, 万一服务器崩溃就会导致服务不可用, 同时, 数据也可能会丢失, 所以, 目前服务集群部署更为常见. 但是为了提供相同的服务, 就需要保证每个服务器能够获取或者存储的数据应该是一致的. 当然根据业务场景可能对数据的要求并不一样。\n\n1. 强一致性\n\n   要求在任何时刻, 系统中所有的副本都是一样的, 对数据的一致性具有极高的要求, 在比如银行的转账系统等比较常见.\n\n2. 最终一致性\n\n   允许在短时内出现数据不一致的情况, 通过使所有节点的数据解决.\n\n## RBAC(Role-Based Access Control) 基于角色的访问控制\n\n听这很高大上的名词, 刚看到我也懵了, 也难怪参考博客的博主面试的时候被问懵了. 其实这东西在平常的已经用过很多遍了.\n\n简单的来说, 就是对于每个用户逐一赋予相应的权限任务量实在是太大了. 其实, 大部分用户能够获得的权限是差不多的, 所以只要区分用户对于服务来说到底是怎样的关系, 也就是确定用户在服务中的角色, 相同的角色, 意味着用户能够用到的权限是一样的. 比如`消费者`, `商家`, `平台管理`之类的. 其实一想, 这就与平时的面向对象编程没有什么区别.\n\n![](https://i-blog.csdnimg.cn/blog_migrate/90f4fbd9dcb2eae0683d0e4f4789f859.png)\n\n上面这张别人做的图将RBAC的优势总结的非常的好, 一看就能理解.\n\n当然我说的这种RBAC还是最基础的, 对于升级款的, 只能说非常的高端\n\nRBAC0（Core RBAC）：最简单的RBAC形式，员工使用角色来获取权限（使用最多）。\n\n基本模型有三个元素：用户、角色和权限。模型设计基于“多对多”原则，即多个用户可以具有相同的角色，一个用户可以具有多个角色。同样，您可以将同一权限分配给多个角色，也可以将同一角色分配给多个权限。\n\nRBAC1（Hierarchical RBAC）：分层，建立在FlatRBAC规则之上，增加角色分层。\n\n添加了第四个组件-层次结构，它定义了不同角色之间的资历关系。通过允许高级角色自动获取下级角色的权限，可以消除冗余，例如在角色重叠时必须指定某些权限。\n\nRBAC2（Static separation of duty (SSD) relations）：受约束的，建立在分层RBAC0之上，并增加职责分离。\n\n为了在存在利益冲突策略的情况下提供帮助，将根据用户分配添加角色之间的关系。例如，作为一个角色的成员的用户将无法被指派为具有利益冲突的角色的成员。\n\nRBAC3（Dynamic separation of duty (DSD) relations）：RBAC3=RBAC1+RBAC2\n\n与SSD一样，DSD限制了可用的用户权限，但基于不同的上下文。例如，根据会话期间执行的任务，用户可能需要不同级别的访问，DSD限制会话期间激活的权限。\n\n原文链接：https://blog.csdn.net/m0_62006803/article/details/133962328\n\n## JWT\n\n​\t其实已经用过很多次了, 但是其实对他的构成还不是很了解, 没想到这个也会被考, 感觉这八股是和算法一样学不完了.\n了解JWT感觉还得先了解session.\n\n### session\n\n对于一个session其实具体存储在服务端, 这也是为什么, 如果在一个服务器上存储了大量的用户登录信息会造成服务器性能的下降. \n\n在服务器上存储的session具有一个id值, 而当产生了session后, 服务器会将session的id放入cookie进行返回, 当客户端请求时, 将sessionid放入cookie, 然后服务端进行检查, 然后服务可以根据session进行一些特殊的记录, 对用户进行有状态记录.\n\n### JWT结构\n\n以前还真没想过, 都是直接将先关的claim直接填写好就丢到函数里面进行生成返回了, 设置连JWT的传输安全都没考虑过. \n\nJWT 通常是这样的：`xxxxx.yyyyy.zzzzz`\n\n1. HEADER 表头, 包括了令牌的类型和签名使用的算法等\n2. Payload 负载, 包含了一些非敏感信息\n3. Signature 签名 将上面两部分的编码后信息与指定的secret进行相对应的算法加密生成相对应的数字签名, 用于确保传输过程中数据没有被更改\n\n![](https://oss.javaguide.cn/javaguide/system-design/jwt/jwt-composition.png)\n\n## go语言垃圾回收\n\n其实还是之前就接触过的东西, 只不过换了一种名词进行表达, 同时还将其定义更加明确化了而已.\n\n对于一个程序运行时, 动态使用的最多的应该就是内存, 不同, 存放不同的数据. 但是有些数据很明显, 在经过一段时间的使用后, 其实就没有继续使用的意义了. 但是, 对于大部分语言来说, 都为程序员编程提供的自申请的一些地址空间. 一般将内存划分为堆空间和栈空间. 对于堆空间, 是可以申请的空间, 而栈空间一般直接由编译器进行管理.\n\n当在栈空间内申请内存后, 使用一个指针表明其位置, 然后就可以使用了. 但是当后面这一块内存空间可能就不需要使用了, 但是, 如果只是直接将指向的指针改为新的地址, 那么原来的这一块地址就无法追踪, 相当于垃圾没有进行回收. 对于持续运行的程序来说, 如果没有进行重启, 那么这块地址就无法进行释放, 相当于对机器来说, 这块内存就消失了, 也就是`内存泄漏`.\n\n### 垃圾回收机制\n\n目前使用的好像是所谓的三色法+混合屏障机制. 其实就三色法来说还是比较好理解的.\n\n垃圾回收机制最需要解决的就是内存泄漏, 而泄漏的内存都有一个特点, 就是不可达. 那么自然思路就是找到所有不可达的内存区, 将其标为可用就行了, 当然, 反向一下就是找到所有可达的内存, 那么剩下的就是不可达的. \n\n从根节点出发, 将所能抵达的内存块标记为灰色, 然后再从灰色的内存块出发, 将能到达的内存标为灰色, 将原来灰色的内存块标记为黑色, 重复执行, 直到最后没有灰色的内存块存在, 再执行回收机制, 将所有的不可达内存块即白色内存块释放. 当然这其中还插入了混合屏障机制, 当然我目前还没有完全理解.\n\n","source":"_posts/Go八股.md","raw":"---\ntitle: Go八股\ndate: 2025-03-07 16:43:36\nupdated: 2025-05-06 19:56:52\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\nnoticeOutdate:\n---\n\n# Go八股\n\n## 有限状态机\n\n也叫有限自动状态机, 写过dp的话, 其实就说明已经用到过了, 本质上就是一个状态转换成另一个状态, 状态之间可以双向也可以单向, 同时也有纯粹的只进不出的状态, 也许是故意设计成这样的, 避免一个错误产生后, 程序仍然继续运行, 感觉会用在一些比较特殊的业务场景, 需要重新启动估计. 对于不需要重新启动的业务, 感觉在加一个处理异常的状态, 再重新转换回正常的状态即可.参考这篇文章[有限状态机FSM(finite state machine) 一_fsm statemachine-CSDN博客](https://blog.csdn.net/liqiangeastsun/article/details/118932263)\n\n同时文章中提到了, 如果只是使用`if-else`语句进行判断, 最后会造成代码的不可读性. 通过使用一个通用的方法, 是比较好的办法. 通过定义一个抽象类`statusBase`, 在其中定义三个抽象方法`OnEnter` , `OnExecute`和`OnExit`. 对于每个状态去具体的实现这是三个方法从而实现不同状态的转移, 提高代码的可读性.\n\n```java\npublic abstract class StateBase\n{\n    // 当前类型\n    protected StateEnum _state;\n    // 状态转换事件，要转换状态的通知\n    protected Action<StateEnum> _transitionEvent;\n    public StateBase()  { }\n\n    // 进入该状态\n    public abstract void OnEnter();\n\n    // 执行该状态的行为\n    public abstract void OnExecute();\n\n    // 退出该状态\n    public abstract void OnExit();\n\n    //返回当前类型\n    public StateEnum State\n    {\n        get { return _state; }\n    }\n    \n    public void SetTransitionEvent(Action<StateEnum> transitionEvent)\n    {\n        _transitionEvent = transitionEvent;\n    }\n}\n\n```\n\n## 一致性\n\n​\t由于后端处理的很多都是与数据相关, 但是, 在当今的互联网服务中, 很明显, 没有办法再使用单一的服务端提供服务, 一方面是能够处理的请求实在是有限, 同时, 将所有的数据都保存在同一 服务端, 万一服务器崩溃就会导致服务不可用, 同时, 数据也可能会丢失, 所以, 目前服务集群部署更为常见. 但是为了提供相同的服务, 就需要保证每个服务器能够获取或者存储的数据应该是一致的. 当然根据业务场景可能对数据的要求并不一样。\n\n1. 强一致性\n\n   要求在任何时刻, 系统中所有的副本都是一样的, 对数据的一致性具有极高的要求, 在比如银行的转账系统等比较常见.\n\n2. 最终一致性\n\n   允许在短时内出现数据不一致的情况, 通过使所有节点的数据解决.\n\n## RBAC(Role-Based Access Control) 基于角色的访问控制\n\n听这很高大上的名词, 刚看到我也懵了, 也难怪参考博客的博主面试的时候被问懵了. 其实这东西在平常的已经用过很多遍了.\n\n简单的来说, 就是对于每个用户逐一赋予相应的权限任务量实在是太大了. 其实, 大部分用户能够获得的权限是差不多的, 所以只要区分用户对于服务来说到底是怎样的关系, 也就是确定用户在服务中的角色, 相同的角色, 意味着用户能够用到的权限是一样的. 比如`消费者`, `商家`, `平台管理`之类的. 其实一想, 这就与平时的面向对象编程没有什么区别.\n\n![](https://i-blog.csdnimg.cn/blog_migrate/90f4fbd9dcb2eae0683d0e4f4789f859.png)\n\n上面这张别人做的图将RBAC的优势总结的非常的好, 一看就能理解.\n\n当然我说的这种RBAC还是最基础的, 对于升级款的, 只能说非常的高端\n\nRBAC0（Core RBAC）：最简单的RBAC形式，员工使用角色来获取权限（使用最多）。\n\n基本模型有三个元素：用户、角色和权限。模型设计基于“多对多”原则，即多个用户可以具有相同的角色，一个用户可以具有多个角色。同样，您可以将同一权限分配给多个角色，也可以将同一角色分配给多个权限。\n\nRBAC1（Hierarchical RBAC）：分层，建立在FlatRBAC规则之上，增加角色分层。\n\n添加了第四个组件-层次结构，它定义了不同角色之间的资历关系。通过允许高级角色自动获取下级角色的权限，可以消除冗余，例如在角色重叠时必须指定某些权限。\n\nRBAC2（Static separation of duty (SSD) relations）：受约束的，建立在分层RBAC0之上，并增加职责分离。\n\n为了在存在利益冲突策略的情况下提供帮助，将根据用户分配添加角色之间的关系。例如，作为一个角色的成员的用户将无法被指派为具有利益冲突的角色的成员。\n\nRBAC3（Dynamic separation of duty (DSD) relations）：RBAC3=RBAC1+RBAC2\n\n与SSD一样，DSD限制了可用的用户权限，但基于不同的上下文。例如，根据会话期间执行的任务，用户可能需要不同级别的访问，DSD限制会话期间激活的权限。\n\n原文链接：https://blog.csdn.net/m0_62006803/article/details/133962328\n\n## JWT\n\n​\t其实已经用过很多次了, 但是其实对他的构成还不是很了解, 没想到这个也会被考, 感觉这八股是和算法一样学不完了.\n了解JWT感觉还得先了解session.\n\n### session\n\n对于一个session其实具体存储在服务端, 这也是为什么, 如果在一个服务器上存储了大量的用户登录信息会造成服务器性能的下降. \n\n在服务器上存储的session具有一个id值, 而当产生了session后, 服务器会将session的id放入cookie进行返回, 当客户端请求时, 将sessionid放入cookie, 然后服务端进行检查, 然后服务可以根据session进行一些特殊的记录, 对用户进行有状态记录.\n\n### JWT结构\n\n以前还真没想过, 都是直接将先关的claim直接填写好就丢到函数里面进行生成返回了, 设置连JWT的传输安全都没考虑过. \n\nJWT 通常是这样的：`xxxxx.yyyyy.zzzzz`\n\n1. HEADER 表头, 包括了令牌的类型和签名使用的算法等\n2. Payload 负载, 包含了一些非敏感信息\n3. Signature 签名 将上面两部分的编码后信息与指定的secret进行相对应的算法加密生成相对应的数字签名, 用于确保传输过程中数据没有被更改\n\n![](https://oss.javaguide.cn/javaguide/system-design/jwt/jwt-composition.png)\n\n## go语言垃圾回收\n\n其实还是之前就接触过的东西, 只不过换了一种名词进行表达, 同时还将其定义更加明确化了而已.\n\n对于一个程序运行时, 动态使用的最多的应该就是内存, 不同, 存放不同的数据. 但是有些数据很明显, 在经过一段时间的使用后, 其实就没有继续使用的意义了. 但是, 对于大部分语言来说, 都为程序员编程提供的自申请的一些地址空间. 一般将内存划分为堆空间和栈空间. 对于堆空间, 是可以申请的空间, 而栈空间一般直接由编译器进行管理.\n\n当在栈空间内申请内存后, 使用一个指针表明其位置, 然后就可以使用了. 但是当后面这一块内存空间可能就不需要使用了, 但是, 如果只是直接将指向的指针改为新的地址, 那么原来的这一块地址就无法追踪, 相当于垃圾没有进行回收. 对于持续运行的程序来说, 如果没有进行重启, 那么这块地址就无法进行释放, 相当于对机器来说, 这块内存就消失了, 也就是`内存泄漏`.\n\n### 垃圾回收机制\n\n目前使用的好像是所谓的三色法+混合屏障机制. 其实就三色法来说还是比较好理解的.\n\n垃圾回收机制最需要解决的就是内存泄漏, 而泄漏的内存都有一个特点, 就是不可达. 那么自然思路就是找到所有不可达的内存区, 将其标为可用就行了, 当然, 反向一下就是找到所有可达的内存, 那么剩下的就是不可达的. \n\n从根节点出发, 将所能抵达的内存块标记为灰色, 然后再从灰色的内存块出发, 将能到达的内存标为灰色, 将原来灰色的内存块标记为黑色, 重复执行, 直到最后没有灰色的内存块存在, 再执行回收机制, 将所有的不可达内存块即白色内存块释放. 当然这其中还插入了混合屏障机制, 当然我目前还没有完全理解.\n\n","slug":"Go八股","published":1,"layout":"post","photos":[],"_id":"cmafjaxa10000vpx51qgh4tlm","content":"<h1 id=\"Go八股\"><a href=\"#Go八股\" class=\"headerlink\" title=\"Go八股\"></a>Go八股</h1><h2 id=\"有限状态机\"><a href=\"#有限状态机\" class=\"headerlink\" title=\"有限状态机\"></a>有限状态机</h2><p>也叫有限自动状态机, 写过dp的话, 其实就说明已经用到过了, 本质上就是一个状态转换成另一个状态, 状态之间可以双向也可以单向, 同时也有纯粹的只进不出的状态, 也许是故意设计成这样的, 避免一个错误产生后, 程序仍然继续运行, 感觉会用在一些比较特殊的业务场景, 需要重新启动估计. 对于不需要重新启动的业务, 感觉在加一个处理异常的状态, 再重新转换回正常的状态即可.参考这篇文章<a href=\"https://blog.csdn.net/liqiangeastsun/article/details/118932263\">有限状态机FSM(finite state machine) 一_fsm statemachine-CSDN博客</a></p>\n<p>同时文章中提到了, 如果只是使用<code>if-else</code>语句进行判断, 最后会造成代码的不可读性. 通过使用一个通用的方法, 是比较好的办法. 通过定义一个抽象类<code>statusBase</code>, 在其中定义三个抽象方法<code>OnEnter</code> , <code>OnExecute</code>和<code>OnExit</code>. 对于每个状态去具体的实现这是三个方法从而实现不同状态的转移, 提高代码的可读性.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StateBase</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前类型</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> StateEnum _state;</span><br><span class=\"line\">    <span class=\"comment\">// 状态转换事件，要转换状态的通知</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Action&lt;StateEnum&gt; _transitionEvent;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">StateBase</span><span class=\"params\">()</span>  &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入该状态</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">OnEnter</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行该状态的行为</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">OnExecute</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 退出该状态</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">OnExit</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回当前类型</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> StateEnum State</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        get &#123; <span class=\"keyword\">return</span> _state; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">SetTransitionEvent</span><span class=\"params\">(Action&lt;StateEnum&gt; transitionEvent)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _transitionEvent = transitionEvent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"一致性\"><a href=\"#一致性\" class=\"headerlink\" title=\"一致性\"></a>一致性</h2><p>​\t由于后端处理的很多都是与数据相关, 但是, 在当今的互联网服务中, 很明显, 没有办法再使用单一的服务端提供服务, 一方面是能够处理的请求实在是有限, 同时, 将所有的数据都保存在同一 服务端, 万一服务器崩溃就会导致服务不可用, 同时, 数据也可能会丢失, 所以, 目前服务集群部署更为常见. 但是为了提供相同的服务, 就需要保证每个服务器能够获取或者存储的数据应该是一致的. 当然根据业务场景可能对数据的要求并不一样。</p>\n<ol>\n<li><p>强一致性</p>\n<p>要求在任何时刻, 系统中所有的副本都是一样的, 对数据的一致性具有极高的要求, 在比如银行的转账系统等比较常见.</p>\n</li>\n<li><p>最终一致性</p>\n<p>允许在短时内出现数据不一致的情况, 通过使所有节点的数据解决.</p>\n</li>\n</ol>\n<h2 id=\"RBAC-Role-Based-Access-Control-基于角色的访问控制\"><a href=\"#RBAC-Role-Based-Access-Control-基于角色的访问控制\" class=\"headerlink\" title=\"RBAC(Role-Based Access Control) 基于角色的访问控制\"></a>RBAC(Role-Based Access Control) 基于角色的访问控制</h2><p>听这很高大上的名词, 刚看到我也懵了, 也难怪参考博客的博主面试的时候被问懵了. 其实这东西在平常的已经用过很多遍了.</p>\n<p>简单的来说, 就是对于每个用户逐一赋予相应的权限任务量实在是太大了. 其实, 大部分用户能够获得的权限是差不多的, 所以只要区分用户对于服务来说到底是怎样的关系, 也就是确定用户在服务中的角色, 相同的角色, 意味着用户能够用到的权限是一样的. 比如<code>消费者</code>, <code>商家</code>, <code>平台管理</code>之类的. 其实一想, 这就与平时的面向对象编程没有什么区别.</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/90f4fbd9dcb2eae0683d0e4f4789f859.png\"></p>\n<p>上面这张别人做的图将RBAC的优势总结的非常的好, 一看就能理解.</p>\n<p>当然我说的这种RBAC还是最基础的, 对于升级款的, 只能说非常的高端</p>\n<p>RBAC0（Core RBAC）：最简单的RBAC形式，员工使用角色来获取权限（使用最多）。</p>\n<p>基本模型有三个元素：用户、角色和权限。模型设计基于“多对多”原则，即多个用户可以具有相同的角色，一个用户可以具有多个角色。同样，您可以将同一权限分配给多个角色，也可以将同一角色分配给多个权限。</p>\n<p>RBAC1（Hierarchical RBAC）：分层，建立在FlatRBAC规则之上，增加角色分层。</p>\n<p>添加了第四个组件-层次结构，它定义了不同角色之间的资历关系。通过允许高级角色自动获取下级角色的权限，可以消除冗余，例如在角色重叠时必须指定某些权限。</p>\n<p>RBAC2（Static separation of duty (SSD) relations）：受约束的，建立在分层RBAC0之上，并增加职责分离。</p>\n<p>为了在存在利益冲突策略的情况下提供帮助，将根据用户分配添加角色之间的关系。例如，作为一个角色的成员的用户将无法被指派为具有利益冲突的角色的成员。</p>\n<p>RBAC3（Dynamic separation of duty (DSD) relations）：RBAC3&#x3D;RBAC1+RBAC2</p>\n<p>与SSD一样，DSD限制了可用的用户权限，但基于不同的上下文。例如，根据会话期间执行的任务，用户可能需要不同级别的访问，DSD限制会话期间激活的权限。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/m0_62006803/article/details/133962328\">https://blog.csdn.net/m0_62006803/article/details/133962328</a></p>\n<h2 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h2><p>​\t其实已经用过很多次了, 但是其实对他的构成还不是很了解, 没想到这个也会被考, 感觉这八股是和算法一样学不完了.<br>了解JWT感觉还得先了解session.</p>\n<h3 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h3><p>对于一个session其实具体存储在服务端, 这也是为什么, 如果在一个服务器上存储了大量的用户登录信息会造成服务器性能的下降. </p>\n<p>在服务器上存储的session具有一个id值, 而当产生了session后, 服务器会将session的id放入cookie进行返回, 当客户端请求时, 将sessionid放入cookie, 然后服务端进行检查, 然后服务可以根据session进行一些特殊的记录, 对用户进行有状态记录.</p>\n<h3 id=\"JWT结构\"><a href=\"#JWT结构\" class=\"headerlink\" title=\"JWT结构\"></a>JWT结构</h3><p>以前还真没想过, 都是直接将先关的claim直接填写好就丢到函数里面进行生成返回了, 设置连JWT的传输安全都没考虑过. </p>\n<p>JWT 通常是这样的：<code>xxxxx.yyyyy.zzzzz</code></p>\n<ol>\n<li>HEADER 表头, 包括了令牌的类型和签名使用的算法等</li>\n<li>Payload 负载, 包含了一些非敏感信息</li>\n<li>Signature 签名 将上面两部分的编码后信息与指定的secret进行相对应的算法加密生成相对应的数字签名, 用于确保传输过程中数据没有被更改</li>\n</ol>\n<p><img src=\"https://oss.javaguide.cn/javaguide/system-design/jwt/jwt-composition.png\"></p>\n<h2 id=\"go语言垃圾回收\"><a href=\"#go语言垃圾回收\" class=\"headerlink\" title=\"go语言垃圾回收\"></a>go语言垃圾回收</h2><p>其实还是之前就接触过的东西, 只不过换了一种名词进行表达, 同时还将其定义更加明确化了而已.</p>\n<p>对于一个程序运行时, 动态使用的最多的应该就是内存, 不同, 存放不同的数据. 但是有些数据很明显, 在经过一段时间的使用后, 其实就没有继续使用的意义了. 但是, 对于大部分语言来说, 都为程序员编程提供的自申请的一些地址空间. 一般将内存划分为堆空间和栈空间. 对于堆空间, 是可以申请的空间, 而栈空间一般直接由编译器进行管理.</p>\n<p>当在栈空间内申请内存后, 使用一个指针表明其位置, 然后就可以使用了. 但是当后面这一块内存空间可能就不需要使用了, 但是, 如果只是直接将指向的指针改为新的地址, 那么原来的这一块地址就无法追踪, 相当于垃圾没有进行回收. 对于持续运行的程序来说, 如果没有进行重启, 那么这块地址就无法进行释放, 相当于对机器来说, 这块内存就消失了, 也就是<code>内存泄漏</code>.</p>\n<h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><p>目前使用的好像是所谓的三色法+混合屏障机制. 其实就三色法来说还是比较好理解的.</p>\n<p>垃圾回收机制最需要解决的就是内存泄漏, 而泄漏的内存都有一个特点, 就是不可达. 那么自然思路就是找到所有不可达的内存区, 将其标为可用就行了, 当然, 反向一下就是找到所有可达的内存, 那么剩下的就是不可达的. </p>\n<p>从根节点出发, 将所能抵达的内存块标记为灰色, 然后再从灰色的内存块出发, 将能到达的内存标为灰色, 将原来灰色的内存块标记为黑色, 重复执行, 直到最后没有灰色的内存块存在, 再执行回收机制, 将所有的不可达内存块即白色内存块释放. 当然这其中还插入了混合屏障机制, 当然我目前还没有完全理解.</p>\n","excerpt":"","more":"<h1 id=\"Go八股\"><a href=\"#Go八股\" class=\"headerlink\" title=\"Go八股\"></a>Go八股</h1><h2 id=\"有限状态机\"><a href=\"#有限状态机\" class=\"headerlink\" title=\"有限状态机\"></a>有限状态机</h2><p>也叫有限自动状态机, 写过dp的话, 其实就说明已经用到过了, 本质上就是一个状态转换成另一个状态, 状态之间可以双向也可以单向, 同时也有纯粹的只进不出的状态, 也许是故意设计成这样的, 避免一个错误产生后, 程序仍然继续运行, 感觉会用在一些比较特殊的业务场景, 需要重新启动估计. 对于不需要重新启动的业务, 感觉在加一个处理异常的状态, 再重新转换回正常的状态即可.参考这篇文章<a href=\"https://blog.csdn.net/liqiangeastsun/article/details/118932263\">有限状态机FSM(finite state machine) 一_fsm statemachine-CSDN博客</a></p>\n<p>同时文章中提到了, 如果只是使用<code>if-else</code>语句进行判断, 最后会造成代码的不可读性. 通过使用一个通用的方法, 是比较好的办法. 通过定义一个抽象类<code>statusBase</code>, 在其中定义三个抽象方法<code>OnEnter</code> , <code>OnExecute</code>和<code>OnExit</code>. 对于每个状态去具体的实现这是三个方法从而实现不同状态的转移, 提高代码的可读性.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StateBase</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前类型</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> StateEnum _state;</span><br><span class=\"line\">    <span class=\"comment\">// 状态转换事件，要转换状态的通知</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Action&lt;StateEnum&gt; _transitionEvent;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">StateBase</span><span class=\"params\">()</span>  &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入该状态</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">OnEnter</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行该状态的行为</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">OnExecute</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 退出该状态</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">OnExit</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回当前类型</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> StateEnum State</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        get &#123; <span class=\"keyword\">return</span> _state; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">SetTransitionEvent</span><span class=\"params\">(Action&lt;StateEnum&gt; transitionEvent)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _transitionEvent = transitionEvent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"一致性\"><a href=\"#一致性\" class=\"headerlink\" title=\"一致性\"></a>一致性</h2><p>​\t由于后端处理的很多都是与数据相关, 但是, 在当今的互联网服务中, 很明显, 没有办法再使用单一的服务端提供服务, 一方面是能够处理的请求实在是有限, 同时, 将所有的数据都保存在同一 服务端, 万一服务器崩溃就会导致服务不可用, 同时, 数据也可能会丢失, 所以, 目前服务集群部署更为常见. 但是为了提供相同的服务, 就需要保证每个服务器能够获取或者存储的数据应该是一致的. 当然根据业务场景可能对数据的要求并不一样。</p>\n<ol>\n<li><p>强一致性</p>\n<p>要求在任何时刻, 系统中所有的副本都是一样的, 对数据的一致性具有极高的要求, 在比如银行的转账系统等比较常见.</p>\n</li>\n<li><p>最终一致性</p>\n<p>允许在短时内出现数据不一致的情况, 通过使所有节点的数据解决.</p>\n</li>\n</ol>\n<h2 id=\"RBAC-Role-Based-Access-Control-基于角色的访问控制\"><a href=\"#RBAC-Role-Based-Access-Control-基于角色的访问控制\" class=\"headerlink\" title=\"RBAC(Role-Based Access Control) 基于角色的访问控制\"></a>RBAC(Role-Based Access Control) 基于角色的访问控制</h2><p>听这很高大上的名词, 刚看到我也懵了, 也难怪参考博客的博主面试的时候被问懵了. 其实这东西在平常的已经用过很多遍了.</p>\n<p>简单的来说, 就是对于每个用户逐一赋予相应的权限任务量实在是太大了. 其实, 大部分用户能够获得的权限是差不多的, 所以只要区分用户对于服务来说到底是怎样的关系, 也就是确定用户在服务中的角色, 相同的角色, 意味着用户能够用到的权限是一样的. 比如<code>消费者</code>, <code>商家</code>, <code>平台管理</code>之类的. 其实一想, 这就与平时的面向对象编程没有什么区别.</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/90f4fbd9dcb2eae0683d0e4f4789f859.png\"></p>\n<p>上面这张别人做的图将RBAC的优势总结的非常的好, 一看就能理解.</p>\n<p>当然我说的这种RBAC还是最基础的, 对于升级款的, 只能说非常的高端</p>\n<p>RBAC0（Core RBAC）：最简单的RBAC形式，员工使用角色来获取权限（使用最多）。</p>\n<p>基本模型有三个元素：用户、角色和权限。模型设计基于“多对多”原则，即多个用户可以具有相同的角色，一个用户可以具有多个角色。同样，您可以将同一权限分配给多个角色，也可以将同一角色分配给多个权限。</p>\n<p>RBAC1（Hierarchical RBAC）：分层，建立在FlatRBAC规则之上，增加角色分层。</p>\n<p>添加了第四个组件-层次结构，它定义了不同角色之间的资历关系。通过允许高级角色自动获取下级角色的权限，可以消除冗余，例如在角色重叠时必须指定某些权限。</p>\n<p>RBAC2（Static separation of duty (SSD) relations）：受约束的，建立在分层RBAC0之上，并增加职责分离。</p>\n<p>为了在存在利益冲突策略的情况下提供帮助，将根据用户分配添加角色之间的关系。例如，作为一个角色的成员的用户将无法被指派为具有利益冲突的角色的成员。</p>\n<p>RBAC3（Dynamic separation of duty (DSD) relations）：RBAC3&#x3D;RBAC1+RBAC2</p>\n<p>与SSD一样，DSD限制了可用的用户权限，但基于不同的上下文。例如，根据会话期间执行的任务，用户可能需要不同级别的访问，DSD限制会话期间激活的权限。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/m0_62006803/article/details/133962328\">https://blog.csdn.net/m0_62006803/article/details/133962328</a></p>\n<h2 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h2><p>​\t其实已经用过很多次了, 但是其实对他的构成还不是很了解, 没想到这个也会被考, 感觉这八股是和算法一样学不完了.<br>了解JWT感觉还得先了解session.</p>\n<h3 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h3><p>对于一个session其实具体存储在服务端, 这也是为什么, 如果在一个服务器上存储了大量的用户登录信息会造成服务器性能的下降. </p>\n<p>在服务器上存储的session具有一个id值, 而当产生了session后, 服务器会将session的id放入cookie进行返回, 当客户端请求时, 将sessionid放入cookie, 然后服务端进行检查, 然后服务可以根据session进行一些特殊的记录, 对用户进行有状态记录.</p>\n<h3 id=\"JWT结构\"><a href=\"#JWT结构\" class=\"headerlink\" title=\"JWT结构\"></a>JWT结构</h3><p>以前还真没想过, 都是直接将先关的claim直接填写好就丢到函数里面进行生成返回了, 设置连JWT的传输安全都没考虑过. </p>\n<p>JWT 通常是这样的：<code>xxxxx.yyyyy.zzzzz</code></p>\n<ol>\n<li>HEADER 表头, 包括了令牌的类型和签名使用的算法等</li>\n<li>Payload 负载, 包含了一些非敏感信息</li>\n<li>Signature 签名 将上面两部分的编码后信息与指定的secret进行相对应的算法加密生成相对应的数字签名, 用于确保传输过程中数据没有被更改</li>\n</ol>\n<p><img src=\"https://oss.javaguide.cn/javaguide/system-design/jwt/jwt-composition.png\"></p>\n<h2 id=\"go语言垃圾回收\"><a href=\"#go语言垃圾回收\" class=\"headerlink\" title=\"go语言垃圾回收\"></a>go语言垃圾回收</h2><p>其实还是之前就接触过的东西, 只不过换了一种名词进行表达, 同时还将其定义更加明确化了而已.</p>\n<p>对于一个程序运行时, 动态使用的最多的应该就是内存, 不同, 存放不同的数据. 但是有些数据很明显, 在经过一段时间的使用后, 其实就没有继续使用的意义了. 但是, 对于大部分语言来说, 都为程序员编程提供的自申请的一些地址空间. 一般将内存划分为堆空间和栈空间. 对于堆空间, 是可以申请的空间, 而栈空间一般直接由编译器进行管理.</p>\n<p>当在栈空间内申请内存后, 使用一个指针表明其位置, 然后就可以使用了. 但是当后面这一块内存空间可能就不需要使用了, 但是, 如果只是直接将指向的指针改为新的地址, 那么原来的这一块地址就无法追踪, 相当于垃圾没有进行回收. 对于持续运行的程序来说, 如果没有进行重启, 那么这块地址就无法进行释放, 相当于对机器来说, 这块内存就消失了, 也就是<code>内存泄漏</code>.</p>\n<h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><p>目前使用的好像是所谓的三色法+混合屏障机制. 其实就三色法来说还是比较好理解的.</p>\n<p>垃圾回收机制最需要解决的就是内存泄漏, 而泄漏的内存都有一个特点, 就是不可达. 那么自然思路就是找到所有不可达的内存区, 将其标为可用就行了, 当然, 反向一下就是找到所有可达的内存, 那么剩下的就是不可达的. </p>\n<p>从根节点出发, 将所能抵达的内存块标记为灰色, 然后再从灰色的内存块出发, 将能到达的内存标为灰色, 将原来灰色的内存块标记为黑色, 重复执行, 直到最后没有灰色的内存块存在, 再执行回收机制, 将所有的不可达内存块即白色内存块释放. 当然这其中还插入了混合屏障机制, 当然我目前还没有完全理解.</p>\n"},{"title":"Hgame2025赛后学习","date":"2025-03-07T08:45:22.000Z","updated":"2025-05-06T11:56:52.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"noticeOutdate":null,"_content":"\n# Hgame2025赛后学习\n\n​\t在发现自己的网络安全知识非常的低下后，也就不再现在ctf这条赛道上进行苦卷了，更多地把他看作是各种高级封装开发外的对计算机技术底层的一种兴趣认知。所以也不太好意思说这是我的赛后总结, 毕竟也就做出来那么两道题, 其他的就根本不行了, 可见和众多师傅相比我的计算机水平十分的有限, 所以就把这比赛当作是认知新技术的一种契机了.\n\n## web\n\n### BandBomb\n\n#### 做题经历\n\n​\t第一次尝试web的题, 最终还是没有做出来. 通过阅读给出的服务器代码, 可以知道有一个接口`/rename`在后面的使用中应该会有用处, 推测可以根据请求对相关文件进行更改. 由于做misc的经验, 所以我以为会有一个相关的flag文件放在服务器上, 需要更改使其进行显示. 但是由于没有学过`ejs`的技术, 所以完全不知道这道题的用意了.\n\n​\t同时, 在为运行中的web服务设置环境变量也属于是在我的技术水平之外了.\n\n#### 相关细节\n\n​\t通过阅读服务的代码, 可以知道, template的名字为`motis`同时, 是处在默认的ejs文件夹下的, 所有做题思路是自己编写相关的服务器文件, 然后通过`/rename`接口对原来的服务器文件进行替换, 自己编写的服务器系统需要读取服务器运行设置的flag环境变量, 将其返回即可.\n\n```js\n//题目提供的服务器源代码\nconst express = require('express');\nconst multer = require('multer');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\n\napp.set('view engine', 'ejs');\n\napp.use('/static', express.static(path.join(__dirname, 'public')));\napp.use(express.json());\n\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    const uploadDir = 'uploads';\n    if (!fs.existsSync(uploadDir)) {\n      fs.mkdirSync(uploadDir);\n    }\n    cb(null, uploadDir);\n  },\n  filename: (req, file, cb) => {\n    cb(null, file.originalname);\n  }\n});\n\nconst upload = multer({ \n  storage: storage,\n  fileFilter: (_, file, cb) => {\n    try {\n      if (!file.originalname) {\n        return cb(new Error('无效的文件名'), false);\n      }\n      cb(null, true);\n    } catch (err) {\n      cb(new Error('文件处理错误'), false);\n    }\n  }\n});\n\napp.get('/', (req, res) => {\n  const uploadsDir = path.join(__dirname, 'uploads');\n  \n  if (!fs.existsSync(uploadsDir)) {\n    fs.mkdirSync(uploadsDir);\n  }\n\n  fs.readdir(uploadsDir, (err, files) => {\n    if (err) {\n      return res.status(500).render('mortis', { files: [] });\n    }\n    res.render('mortis', { files: files });  //将读取到的参数放到“mortis”的模板中\n  });\n});\n\napp.post('/upload', (req, res) => {\n  upload.single('file')(req, res, (err) => {\n    if (err) {\n      return res.status(400).json({ error: err.message });\n    }\n    if (!req.file) {\n      return res.status(400).json({ error: '没有选择文件' });\n    }\n    res.json({ \n      message: '文件上传成功',\n      filename: req.file.filename \n    });\n  });\n});\n\napp.post('/rename', (req, res) => {\n  const { oldName, newName } = req.body;\n  const oldPath = path.join(__dirname, 'uploads', oldName);\n  const newPath = path.join(__dirname, 'uploads', newName);\n\n  if (!oldName || !newName) {\n    return res.status(400).json({ error: ' ' });\n  }\n\n  fs.rename(oldPath, newPath, (err) => {\n    if (err) {\n      return res.status(500).json({ error: ' ' + err.message });\n    }\n    res.json({ message: ' ' });\n  });\n});\n\napp.listen(port, () => {\n  console.log(`服务器运行在 http://localhost:${port}`);\n});\n\n```\n\n\n\n","source":"_posts/Hgame2025赛后学习.md","raw":"---\ntitle: Hgame2025赛后学习\ndate: 2025-03-07 16:45:22\nupdated: 2025-05-06 19:56:52\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\nnoticeOutdate:\n---\n\n# Hgame2025赛后学习\n\n​\t在发现自己的网络安全知识非常的低下后，也就不再现在ctf这条赛道上进行苦卷了，更多地把他看作是各种高级封装开发外的对计算机技术底层的一种兴趣认知。所以也不太好意思说这是我的赛后总结, 毕竟也就做出来那么两道题, 其他的就根本不行了, 可见和众多师傅相比我的计算机水平十分的有限, 所以就把这比赛当作是认知新技术的一种契机了.\n\n## web\n\n### BandBomb\n\n#### 做题经历\n\n​\t第一次尝试web的题, 最终还是没有做出来. 通过阅读给出的服务器代码, 可以知道有一个接口`/rename`在后面的使用中应该会有用处, 推测可以根据请求对相关文件进行更改. 由于做misc的经验, 所以我以为会有一个相关的flag文件放在服务器上, 需要更改使其进行显示. 但是由于没有学过`ejs`的技术, 所以完全不知道这道题的用意了.\n\n​\t同时, 在为运行中的web服务设置环境变量也属于是在我的技术水平之外了.\n\n#### 相关细节\n\n​\t通过阅读服务的代码, 可以知道, template的名字为`motis`同时, 是处在默认的ejs文件夹下的, 所有做题思路是自己编写相关的服务器文件, 然后通过`/rename`接口对原来的服务器文件进行替换, 自己编写的服务器系统需要读取服务器运行设置的flag环境变量, 将其返回即可.\n\n```js\n//题目提供的服务器源代码\nconst express = require('express');\nconst multer = require('multer');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\n\napp.set('view engine', 'ejs');\n\napp.use('/static', express.static(path.join(__dirname, 'public')));\napp.use(express.json());\n\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    const uploadDir = 'uploads';\n    if (!fs.existsSync(uploadDir)) {\n      fs.mkdirSync(uploadDir);\n    }\n    cb(null, uploadDir);\n  },\n  filename: (req, file, cb) => {\n    cb(null, file.originalname);\n  }\n});\n\nconst upload = multer({ \n  storage: storage,\n  fileFilter: (_, file, cb) => {\n    try {\n      if (!file.originalname) {\n        return cb(new Error('无效的文件名'), false);\n      }\n      cb(null, true);\n    } catch (err) {\n      cb(new Error('文件处理错误'), false);\n    }\n  }\n});\n\napp.get('/', (req, res) => {\n  const uploadsDir = path.join(__dirname, 'uploads');\n  \n  if (!fs.existsSync(uploadsDir)) {\n    fs.mkdirSync(uploadsDir);\n  }\n\n  fs.readdir(uploadsDir, (err, files) => {\n    if (err) {\n      return res.status(500).render('mortis', { files: [] });\n    }\n    res.render('mortis', { files: files });  //将读取到的参数放到“mortis”的模板中\n  });\n});\n\napp.post('/upload', (req, res) => {\n  upload.single('file')(req, res, (err) => {\n    if (err) {\n      return res.status(400).json({ error: err.message });\n    }\n    if (!req.file) {\n      return res.status(400).json({ error: '没有选择文件' });\n    }\n    res.json({ \n      message: '文件上传成功',\n      filename: req.file.filename \n    });\n  });\n});\n\napp.post('/rename', (req, res) => {\n  const { oldName, newName } = req.body;\n  const oldPath = path.join(__dirname, 'uploads', oldName);\n  const newPath = path.join(__dirname, 'uploads', newName);\n\n  if (!oldName || !newName) {\n    return res.status(400).json({ error: ' ' });\n  }\n\n  fs.rename(oldPath, newPath, (err) => {\n    if (err) {\n      return res.status(500).json({ error: ' ' + err.message });\n    }\n    res.json({ message: ' ' });\n  });\n});\n\napp.listen(port, () => {\n  console.log(`服务器运行在 http://localhost:${port}`);\n});\n\n```\n\n\n\n","slug":"Hgame2025赛后学习","published":1,"layout":"post","photos":[],"_id":"cmafjaxac0001vpx554nid16u","content":"<h1 id=\"Hgame2025赛后学习\"><a href=\"#Hgame2025赛后学习\" class=\"headerlink\" title=\"Hgame2025赛后学习\"></a>Hgame2025赛后学习</h1><p>​\t在发现自己的网络安全知识非常的低下后，也就不再现在ctf这条赛道上进行苦卷了，更多地把他看作是各种高级封装开发外的对计算机技术底层的一种兴趣认知。所以也不太好意思说这是我的赛后总结, 毕竟也就做出来那么两道题, 其他的就根本不行了, 可见和众多师傅相比我的计算机水平十分的有限, 所以就把这比赛当作是认知新技术的一种契机了.</p>\n<h2 id=\"web\"><a href=\"#web\" class=\"headerlink\" title=\"web\"></a>web</h2><h3 id=\"BandBomb\"><a href=\"#BandBomb\" class=\"headerlink\" title=\"BandBomb\"></a>BandBomb</h3><h4 id=\"做题经历\"><a href=\"#做题经历\" class=\"headerlink\" title=\"做题经历\"></a>做题经历</h4><p>​\t第一次尝试web的题, 最终还是没有做出来. 通过阅读给出的服务器代码, 可以知道有一个接口<code>/rename</code>在后面的使用中应该会有用处, 推测可以根据请求对相关文件进行更改. 由于做misc的经验, 所以我以为会有一个相关的flag文件放在服务器上, 需要更改使其进行显示. 但是由于没有学过<code>ejs</code>的技术, 所以完全不知道这道题的用意了.</p>\n<p>​\t同时, 在为运行中的web服务设置环境变量也属于是在我的技术水平之外了.</p>\n<h4 id=\"相关细节\"><a href=\"#相关细节\" class=\"headerlink\" title=\"相关细节\"></a>相关细节</h4><p>​\t通过阅读服务的代码, 可以知道, template的名字为<code>motis</code>同时, 是处在默认的ejs文件夹下的, 所有做题思路是自己编写相关的服务器文件, 然后通过<code>/rename</code>接口对原来的服务器文件进行替换, 自己编写的服务器系统需要读取服务器运行设置的flag环境变量, 将其返回即可.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//题目提供的服务器源代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;express&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> multer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;multer&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"title function_\">express</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;view engine&#x27;</span>, <span class=\"string\">&#x27;ejs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;/static&#x27;</span>, express.<span class=\"title function_\">static</span>(path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;public&#x27;</span>)));</span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(express.<span class=\"title function_\">json</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage = multer.<span class=\"title function_\">diskStorage</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">destination</span>: <span class=\"function\">(<span class=\"params\">req, file, cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uploadDir = <span class=\"string\">&#x27;uploads&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fs.<span class=\"title function_\">existsSync</span>(uploadDir)) &#123;</span><br><span class=\"line\">      fs.<span class=\"title function_\">mkdirSync</span>(uploadDir);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">cb</span>(<span class=\"literal\">null</span>, uploadDir);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">filename</span>: <span class=\"function\">(<span class=\"params\">req, file, cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">cb</span>(<span class=\"literal\">null</span>, file.<span class=\"property\">originalname</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> upload = <span class=\"title function_\">multer</span>(&#123; </span><br><span class=\"line\">  <span class=\"attr\">storage</span>: storage,</span><br><span class=\"line\">  <span class=\"attr\">fileFilter</span>: <span class=\"function\">(<span class=\"params\">_, file, cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!file.<span class=\"property\">originalname</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">cb</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;无效的文件名&#x27;</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">cb</span>(<span class=\"literal\">null</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">cb</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;文件处理错误&#x27;</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> uploadsDir = path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;uploads&#x27;</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fs.<span class=\"title function_\">existsSync</span>(uploadsDir)) &#123;</span><br><span class=\"line\">    fs.<span class=\"title function_\">mkdirSync</span>(uploadsDir);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fs.<span class=\"title function_\">readdir</span>(uploadsDir, <span class=\"function\">(<span class=\"params\">err, files</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">500</span>).<span class=\"title function_\">render</span>(<span class=\"string\">&#x27;mortis&#x27;</span>, &#123; <span class=\"attr\">files</span>: [] &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">render</span>(<span class=\"string\">&#x27;mortis&#x27;</span>, &#123; <span class=\"attr\">files</span>: files &#125;);  <span class=\"comment\">//将读取到的参数放到“mortis”的模板中</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/upload&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  upload.<span class=\"title function_\">single</span>(<span class=\"string\">&#x27;file&#x27;</span>)(req, res, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">400</span>).<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">error</span>: err.<span class=\"property\">message</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!req.<span class=\"property\">file</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">400</span>).<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">error</span>: <span class=\"string\">&#x27;没有选择文件&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">json</span>(&#123; </span><br><span class=\"line\">      <span class=\"attr\">message</span>: <span class=\"string\">&#x27;文件上传成功&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">filename</span>: req.<span class=\"property\">file</span>.<span class=\"property\">filename</span> </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/rename&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; oldName, newName &#125; = req.<span class=\"property\">body</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldPath = path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;uploads&#x27;</span>, oldName);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newPath = path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;uploads&#x27;</span>, newName);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!oldName || !newName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">400</span>).<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">error</span>: <span class=\"string\">&#x27; &#x27;</span> &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fs.<span class=\"title function_\">rename</span>(oldPath, newPath, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">500</span>).<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">error</span>: <span class=\"string\">&#x27; &#x27;</span> + err.<span class=\"property\">message</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27; &#x27;</span> &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(port, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`服务器运行在 http://localhost:<span class=\"subst\">$&#123;port&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n","excerpt":"","more":"<h1 id=\"Hgame2025赛后学习\"><a href=\"#Hgame2025赛后学习\" class=\"headerlink\" title=\"Hgame2025赛后学习\"></a>Hgame2025赛后学习</h1><p>​\t在发现自己的网络安全知识非常的低下后，也就不再现在ctf这条赛道上进行苦卷了，更多地把他看作是各种高级封装开发外的对计算机技术底层的一种兴趣认知。所以也不太好意思说这是我的赛后总结, 毕竟也就做出来那么两道题, 其他的就根本不行了, 可见和众多师傅相比我的计算机水平十分的有限, 所以就把这比赛当作是认知新技术的一种契机了.</p>\n<h2 id=\"web\"><a href=\"#web\" class=\"headerlink\" title=\"web\"></a>web</h2><h3 id=\"BandBomb\"><a href=\"#BandBomb\" class=\"headerlink\" title=\"BandBomb\"></a>BandBomb</h3><h4 id=\"做题经历\"><a href=\"#做题经历\" class=\"headerlink\" title=\"做题经历\"></a>做题经历</h4><p>​\t第一次尝试web的题, 最终还是没有做出来. 通过阅读给出的服务器代码, 可以知道有一个接口<code>/rename</code>在后面的使用中应该会有用处, 推测可以根据请求对相关文件进行更改. 由于做misc的经验, 所以我以为会有一个相关的flag文件放在服务器上, 需要更改使其进行显示. 但是由于没有学过<code>ejs</code>的技术, 所以完全不知道这道题的用意了.</p>\n<p>​\t同时, 在为运行中的web服务设置环境变量也属于是在我的技术水平之外了.</p>\n<h4 id=\"相关细节\"><a href=\"#相关细节\" class=\"headerlink\" title=\"相关细节\"></a>相关细节</h4><p>​\t通过阅读服务的代码, 可以知道, template的名字为<code>motis</code>同时, 是处在默认的ejs文件夹下的, 所有做题思路是自己编写相关的服务器文件, 然后通过<code>/rename</code>接口对原来的服务器文件进行替换, 自己编写的服务器系统需要读取服务器运行设置的flag环境变量, 将其返回即可.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//题目提供的服务器源代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;express&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> multer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;multer&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"title function_\">express</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;view engine&#x27;</span>, <span class=\"string\">&#x27;ejs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;/static&#x27;</span>, express.<span class=\"title function_\">static</span>(path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;public&#x27;</span>)));</span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(express.<span class=\"title function_\">json</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage = multer.<span class=\"title function_\">diskStorage</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">destination</span>: <span class=\"function\">(<span class=\"params\">req, file, cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uploadDir = <span class=\"string\">&#x27;uploads&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fs.<span class=\"title function_\">existsSync</span>(uploadDir)) &#123;</span><br><span class=\"line\">      fs.<span class=\"title function_\">mkdirSync</span>(uploadDir);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">cb</span>(<span class=\"literal\">null</span>, uploadDir);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">filename</span>: <span class=\"function\">(<span class=\"params\">req, file, cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">cb</span>(<span class=\"literal\">null</span>, file.<span class=\"property\">originalname</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> upload = <span class=\"title function_\">multer</span>(&#123; </span><br><span class=\"line\">  <span class=\"attr\">storage</span>: storage,</span><br><span class=\"line\">  <span class=\"attr\">fileFilter</span>: <span class=\"function\">(<span class=\"params\">_, file, cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!file.<span class=\"property\">originalname</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">cb</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;无效的文件名&#x27;</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">cb</span>(<span class=\"literal\">null</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">cb</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;文件处理错误&#x27;</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> uploadsDir = path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;uploads&#x27;</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fs.<span class=\"title function_\">existsSync</span>(uploadsDir)) &#123;</span><br><span class=\"line\">    fs.<span class=\"title function_\">mkdirSync</span>(uploadsDir);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fs.<span class=\"title function_\">readdir</span>(uploadsDir, <span class=\"function\">(<span class=\"params\">err, files</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">500</span>).<span class=\"title function_\">render</span>(<span class=\"string\">&#x27;mortis&#x27;</span>, &#123; <span class=\"attr\">files</span>: [] &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">render</span>(<span class=\"string\">&#x27;mortis&#x27;</span>, &#123; <span class=\"attr\">files</span>: files &#125;);  <span class=\"comment\">//将读取到的参数放到“mortis”的模板中</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/upload&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  upload.<span class=\"title function_\">single</span>(<span class=\"string\">&#x27;file&#x27;</span>)(req, res, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">400</span>).<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">error</span>: err.<span class=\"property\">message</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!req.<span class=\"property\">file</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">400</span>).<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">error</span>: <span class=\"string\">&#x27;没有选择文件&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">json</span>(&#123; </span><br><span class=\"line\">      <span class=\"attr\">message</span>: <span class=\"string\">&#x27;文件上传成功&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">filename</span>: req.<span class=\"property\">file</span>.<span class=\"property\">filename</span> </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/rename&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; oldName, newName &#125; = req.<span class=\"property\">body</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldPath = path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;uploads&#x27;</span>, oldName);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newPath = path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&#x27;uploads&#x27;</span>, newName);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!oldName || !newName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">400</span>).<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">error</span>: <span class=\"string\">&#x27; &#x27;</span> &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fs.<span class=\"title function_\">rename</span>(oldPath, newPath, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.<span class=\"title function_\">status</span>(<span class=\"number\">500</span>).<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">error</span>: <span class=\"string\">&#x27; &#x27;</span> + err.<span class=\"property\">message</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">json</span>(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27; &#x27;</span> &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(port, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`服务器运行在 http://localhost:<span class=\"subst\">$&#123;port&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"Java","date":"2025-03-03T15:53:06.000Z","updated":"2025-05-06T11:56:52.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"noticeOutdate":null,"_content":"\n# Java\n\n1. `println`和`print`的区别在于前者在输出后自动添加换行, 后者则没有.\n2. ~~在创建一个对象时`new`关键字在于重新创造一个对象, 如果直接创建一个对象, 创建对象的值在`Java string`的内存池内如果存在, 该对象会直接指向这个值.~~好像是在内存池中创建一个常量而已, 如果在常量池中有, 就直接将这个常量赋值, 否则就在常量池里再创建一个常量.(但是这样在内存池中创建多个相同的常量又有什么意义呢?)\n\n3. 在scaner类中, `Scaner.next()`一定要读到有效字符后才可以结束.对有效字符之前遇到的空白会自动将其去除, 将有效字符后的空白作为结束符(就是不能输入含有空格的字符串)\n4. `scaner.nextLIne()`以回车符为结束的标志. \n   1. scaner类中有`hasNextXXX`进行判断是否还有继续输入. \n\n# Springboot开发\n\n## 前言\n\n​\t之前经过杭电助手后端的二面, 使用Gin框架开发了一个web应用. 已经可以可以体会到, 一个框架对于应用开发效率的提升, 再开发过程中节省了很多需要去配置相关依赖的过程, 再生产中只需要注重服务的逻辑实现就可以了.\n​\tGin框架是基于Go语言的web开发框架. 这次为了能够吃透新买的项目教程书, 学习Springboot框架, 同时也是怎加视野和理解不同的编程思维.\n\n# Java项目管理器Maven\n\n​\t在一个应用开发的过程中, 一定需要用到很多的第三方库, 这些库也可以称作为是包. 这些包的下载管理, 如果没有包处理器, 需要开发者自己去同意管理, 不仅耗费时间, 同时也容易混乱. 所以专门的事情就要有专门的人去做. 因此就诞生了包管理器,  在python中用到的就是pip.\n​\t对于maven来说, 好像管理的范围更加的广泛, 是对整个Java项目的所有资源进行管理.将这个项目进行抽象成一个模型, 方便解读和管理. 也许在Maven的眼中, 我们写出来的每一个Java项目的样子其实如下图(图片来自网络)\n\n![](https://i-blog.csdnimg.cn/blog_migrate/39cf153e729b8733fea0c157b2e2d11e.png)\n\n​\t其中的本地是自身项目的包管理地址, 私服有点像是镜像源吧, 但是同时翻译其实是仓库, 就和github上差不多吧, 分为私有仓库, 公有仓库, 由中央就是maven团队维护的仓库全为公有仓库.\n​\t对于一个处在仓库中的jar包, 他的访问路径就是他的坐标.\n\n## Springboot的实践\n\n还是按照黑马的课程, 通过IDEA进行构项目.\n\n对于Maven还是不熟悉的, 不得不说, 很难想象Maven的构建如果没有成熟的插件进行支持, 手工的构建是一件多么麻烦的事情, 当然, 也有可能是对于maven的不熟悉.\n\n对于基于maven进行构建的Java项目, 首先上来对我最卡的就是包的管理. 对于python有pip, 对于Go自身就有管理. 但是Java属实有点难到我了. jar包的管理全部都是通过maven的pom文件中的依赖路径进行管理的. 目前我还是很难理解pom文件中的所有数据文件进行的写法.但是可以确信的是, 一个项目需要的jar包文件的路径应该是全写在maven的文件中了.\n\n一开始的项目构建中, 我并没有采用视频中的jdk17, 一开始我以为是jdk版本的问题. 但是经过多方的尝试, 同时还是阅读编译器的信息, 感觉可能还是包的引入问题. 但是查阅资料, 发现Java中并没有pip这样的包管理器. 其实对我来说是犯了难了. 对于maven这个第三方的包管理器, 感觉像是为Java开发提供的一种补丁的方法. 其操作的程度对于目前初学的我来说简直是一种折磨.\n\n回顾视频, 我发现再maven的选择上, 我少勾选了web的选项, 我猜测这相当于是在我的maven文件中没有自动加上相关的web包的依赖路径. 当然在我, 加上后一时间还是无法运行. 其实从IDEA的终端看看就知道是相关的解析一直没有完成, 涉及到这些外部包的事情, 难免就会涉及的镜像源的问题. 所以一时间的想法就是配置镜像源. 但是在IDEA中的maven好像是他自带的, 因为但我在没有补下maven之前他仍然能够常的运行. 所以即使我补下maven后, 同时在我本机的配置中加上了进行源, 但是仍然慢. 只有进入开发环境中的maven进行配置后, 就能够成功运行了.\n\n## Java知识恶补\n\n在完全没有接触Java直接进行Java的框架应用还是有一定难度. Java和C系的语言差别还是很多.\n\n### 1.Java中的变量值传递的理解\n\n对于在Java中对于有一个方法如果传入一个数组, 对数组进行修改后, 原数组的值也会产生改变这点. 和C系的语言非常不一样. 对于C系的语言来说, 如果只是直接将一个类进行传入, 相当于传入的就是副本, 不会对原来的值进行影响. 只有在传入时, 特地使用 '&' 进行运算的传输值, 才是相关变量的地址值. 但是在Java中, 无论是的什么类对象, 当然目前我并没有尝试数组, 传入的其实都是这个类的地址, 其变量的值, 不能直接简单的看作一个类的整体, 其实, 变量名本身就是一个地址. 所以, 虽然对于Java来说, 所有的传递都是值传递(passed-by-value), 但是, 由于传进去的本身就是地址值, 所以通过地址的修改会造成原来的有所变化.\n\n**通过实践, 对于直接传入数组, 效果也是一样的. 也就是说, 在Java中, 数组其实也是一个类. 补:不对, 因为所以的类对象都是通过new方法建立的, 所以, 其实语句的左值本身就是一个引用变量. 所以传入方法中, 传入的当然就是引用了.**\n\n### 2.Java中的静态变量与静态方法\n\n​\t在main函数中对我想写的方法进行测试时, 产生的报错, 写的是不能在静态方法中调用非静态的方法. 查阅资料, 发现这点对于静态变量适用. 原因就在于JVM的机制问题, 目前不是非常的能够看懂. *静态方法类似其他语言中的函数*\n\n### 3.Java中构造方法的一点小不同\n\n​\t大部分的构造的方法都和C++差不多,  但是, 当在类中已经定义了相关构造方法后, 编译器就不会再自动构造默认的构造方法了, 想要的话必须自己加, 不理解为什么这样设计. 同时, 再创建构造方法时, 必须使用`new`进行构造.\n\n### 4.关于子类和父类的创建引用的关系\n\n​\t还是贴篇文章吧, 有图有真相.\n\n​\t[【java】父类与子类的引用赋值关系_子类引用指向父类对象-CSDN博客](https://blog.csdn.net/weixin_42929607/article/details/107168033)\n\n​\t父类引用指向的是子类实例的话, 只能调用从父类继承的方法和变量. 但是, 子类对于父类的方法进行覆写, 父类引用调用时, 仍然还是父类的方法.\n\n```java\npublic class Main {\n\n    public static void main(String... args) {\n        Father f = new Child();\n        f.hello(); //Child's hello\n    }\n\n}\n\nclass Father {\n\n    public void hello() {\n        System.out.println(\"Father's hello\");\n    }\n}\n\nclass Child extends Father {\n\n    public void hello() {\n        System.out.println(\"Child's hello\");\n    }\n\n}\n```\n\n## Java static修饰\n\n 对于static修饰的变量和方法,  对于变量来说, 其生命周期和类的生命周期一样长, 对于静态方法来说, 可以不通过创建一个具体的对象直接进行访问使用. 所以对于静态方法来说, 如果不是访问静态变量, 就就无法对其他的类变量进行访问, 因为普通的类变量依赖于具体的对象存在.\n\n## Java中的多态优势\n\n在做算法的时候遇到`Queue<int[]> queue = LinkedList<int[]> list`的声明. 不是很明白, 为什么一定要使用父类声明变量, 然后使用子类进行实现. \n\n对于类和一个父类，在构建实现一个父类申明的时, 会对父类的方法进行构造, 然后再对子类方法进行构造. 声明的父类变量, 相当于是一个指针, 声明为可以更改为其他的子类实现.\n\n```java\npackage dd20161114_2;\n\npublic class Master1 {\npublic static void main(String[] args) {\n    //dog对象实例化\n        Dog dog=new Dog();\n        eat(dog);\n    //cat对象实例化\n        Cat cat=new Cat();\n        eat(cat);\n    //Pet对象实例化\n        Pet pet=new Dog();\n        pet=new Cat();\n        eat(pet);\n\n    }\n    public static void eat(Pet pet){\n\n        pet.eat();\n    }\n}\n/*\n输出结果：\n狗啃骨头\n猫吃鱼\n猫吃鱼\n*/\n```\n\n\n\n## Java中的相等判断\n\n对于equal方法来说都是判断整体是否相等, 若果只是使用`==`比较的是地址是否相等. 对于一个new出来的对象, 都是使用独立的内存进行存储的, 所以即使所有的字段都相同, equal也为false\n","source":"_posts/Java.md","raw":"---\ntitle: Java\ndate: 2025-03-03 23:53:06\nupdated: 2025-05-06 19:56:52\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\nnoticeOutdate:\n---\n\n# Java\n\n1. `println`和`print`的区别在于前者在输出后自动添加换行, 后者则没有.\n2. ~~在创建一个对象时`new`关键字在于重新创造一个对象, 如果直接创建一个对象, 创建对象的值在`Java string`的内存池内如果存在, 该对象会直接指向这个值.~~好像是在内存池中创建一个常量而已, 如果在常量池中有, 就直接将这个常量赋值, 否则就在常量池里再创建一个常量.(但是这样在内存池中创建多个相同的常量又有什么意义呢?)\n\n3. 在scaner类中, `Scaner.next()`一定要读到有效字符后才可以结束.对有效字符之前遇到的空白会自动将其去除, 将有效字符后的空白作为结束符(就是不能输入含有空格的字符串)\n4. `scaner.nextLIne()`以回车符为结束的标志. \n   1. scaner类中有`hasNextXXX`进行判断是否还有继续输入. \n\n# Springboot开发\n\n## 前言\n\n​\t之前经过杭电助手后端的二面, 使用Gin框架开发了一个web应用. 已经可以可以体会到, 一个框架对于应用开发效率的提升, 再开发过程中节省了很多需要去配置相关依赖的过程, 再生产中只需要注重服务的逻辑实现就可以了.\n​\tGin框架是基于Go语言的web开发框架. 这次为了能够吃透新买的项目教程书, 学习Springboot框架, 同时也是怎加视野和理解不同的编程思维.\n\n# Java项目管理器Maven\n\n​\t在一个应用开发的过程中, 一定需要用到很多的第三方库, 这些库也可以称作为是包. 这些包的下载管理, 如果没有包处理器, 需要开发者自己去同意管理, 不仅耗费时间, 同时也容易混乱. 所以专门的事情就要有专门的人去做. 因此就诞生了包管理器,  在python中用到的就是pip.\n​\t对于maven来说, 好像管理的范围更加的广泛, 是对整个Java项目的所有资源进行管理.将这个项目进行抽象成一个模型, 方便解读和管理. 也许在Maven的眼中, 我们写出来的每一个Java项目的样子其实如下图(图片来自网络)\n\n![](https://i-blog.csdnimg.cn/blog_migrate/39cf153e729b8733fea0c157b2e2d11e.png)\n\n​\t其中的本地是自身项目的包管理地址, 私服有点像是镜像源吧, 但是同时翻译其实是仓库, 就和github上差不多吧, 分为私有仓库, 公有仓库, 由中央就是maven团队维护的仓库全为公有仓库.\n​\t对于一个处在仓库中的jar包, 他的访问路径就是他的坐标.\n\n## Springboot的实践\n\n还是按照黑马的课程, 通过IDEA进行构项目.\n\n对于Maven还是不熟悉的, 不得不说, 很难想象Maven的构建如果没有成熟的插件进行支持, 手工的构建是一件多么麻烦的事情, 当然, 也有可能是对于maven的不熟悉.\n\n对于基于maven进行构建的Java项目, 首先上来对我最卡的就是包的管理. 对于python有pip, 对于Go自身就有管理. 但是Java属实有点难到我了. jar包的管理全部都是通过maven的pom文件中的依赖路径进行管理的. 目前我还是很难理解pom文件中的所有数据文件进行的写法.但是可以确信的是, 一个项目需要的jar包文件的路径应该是全写在maven的文件中了.\n\n一开始的项目构建中, 我并没有采用视频中的jdk17, 一开始我以为是jdk版本的问题. 但是经过多方的尝试, 同时还是阅读编译器的信息, 感觉可能还是包的引入问题. 但是查阅资料, 发现Java中并没有pip这样的包管理器. 其实对我来说是犯了难了. 对于maven这个第三方的包管理器, 感觉像是为Java开发提供的一种补丁的方法. 其操作的程度对于目前初学的我来说简直是一种折磨.\n\n回顾视频, 我发现再maven的选择上, 我少勾选了web的选项, 我猜测这相当于是在我的maven文件中没有自动加上相关的web包的依赖路径. 当然在我, 加上后一时间还是无法运行. 其实从IDEA的终端看看就知道是相关的解析一直没有完成, 涉及到这些外部包的事情, 难免就会涉及的镜像源的问题. 所以一时间的想法就是配置镜像源. 但是在IDEA中的maven好像是他自带的, 因为但我在没有补下maven之前他仍然能够常的运行. 所以即使我补下maven后, 同时在我本机的配置中加上了进行源, 但是仍然慢. 只有进入开发环境中的maven进行配置后, 就能够成功运行了.\n\n## Java知识恶补\n\n在完全没有接触Java直接进行Java的框架应用还是有一定难度. Java和C系的语言差别还是很多.\n\n### 1.Java中的变量值传递的理解\n\n对于在Java中对于有一个方法如果传入一个数组, 对数组进行修改后, 原数组的值也会产生改变这点. 和C系的语言非常不一样. 对于C系的语言来说, 如果只是直接将一个类进行传入, 相当于传入的就是副本, 不会对原来的值进行影响. 只有在传入时, 特地使用 '&' 进行运算的传输值, 才是相关变量的地址值. 但是在Java中, 无论是的什么类对象, 当然目前我并没有尝试数组, 传入的其实都是这个类的地址, 其变量的值, 不能直接简单的看作一个类的整体, 其实, 变量名本身就是一个地址. 所以, 虽然对于Java来说, 所有的传递都是值传递(passed-by-value), 但是, 由于传进去的本身就是地址值, 所以通过地址的修改会造成原来的有所变化.\n\n**通过实践, 对于直接传入数组, 效果也是一样的. 也就是说, 在Java中, 数组其实也是一个类. 补:不对, 因为所以的类对象都是通过new方法建立的, 所以, 其实语句的左值本身就是一个引用变量. 所以传入方法中, 传入的当然就是引用了.**\n\n### 2.Java中的静态变量与静态方法\n\n​\t在main函数中对我想写的方法进行测试时, 产生的报错, 写的是不能在静态方法中调用非静态的方法. 查阅资料, 发现这点对于静态变量适用. 原因就在于JVM的机制问题, 目前不是非常的能够看懂. *静态方法类似其他语言中的函数*\n\n### 3.Java中构造方法的一点小不同\n\n​\t大部分的构造的方法都和C++差不多,  但是, 当在类中已经定义了相关构造方法后, 编译器就不会再自动构造默认的构造方法了, 想要的话必须自己加, 不理解为什么这样设计. 同时, 再创建构造方法时, 必须使用`new`进行构造.\n\n### 4.关于子类和父类的创建引用的关系\n\n​\t还是贴篇文章吧, 有图有真相.\n\n​\t[【java】父类与子类的引用赋值关系_子类引用指向父类对象-CSDN博客](https://blog.csdn.net/weixin_42929607/article/details/107168033)\n\n​\t父类引用指向的是子类实例的话, 只能调用从父类继承的方法和变量. 但是, 子类对于父类的方法进行覆写, 父类引用调用时, 仍然还是父类的方法.\n\n```java\npublic class Main {\n\n    public static void main(String... args) {\n        Father f = new Child();\n        f.hello(); //Child's hello\n    }\n\n}\n\nclass Father {\n\n    public void hello() {\n        System.out.println(\"Father's hello\");\n    }\n}\n\nclass Child extends Father {\n\n    public void hello() {\n        System.out.println(\"Child's hello\");\n    }\n\n}\n```\n\n## Java static修饰\n\n 对于static修饰的变量和方法,  对于变量来说, 其生命周期和类的生命周期一样长, 对于静态方法来说, 可以不通过创建一个具体的对象直接进行访问使用. 所以对于静态方法来说, 如果不是访问静态变量, 就就无法对其他的类变量进行访问, 因为普通的类变量依赖于具体的对象存在.\n\n## Java中的多态优势\n\n在做算法的时候遇到`Queue<int[]> queue = LinkedList<int[]> list`的声明. 不是很明白, 为什么一定要使用父类声明变量, 然后使用子类进行实现. \n\n对于类和一个父类，在构建实现一个父类申明的时, 会对父类的方法进行构造, 然后再对子类方法进行构造. 声明的父类变量, 相当于是一个指针, 声明为可以更改为其他的子类实现.\n\n```java\npackage dd20161114_2;\n\npublic class Master1 {\npublic static void main(String[] args) {\n    //dog对象实例化\n        Dog dog=new Dog();\n        eat(dog);\n    //cat对象实例化\n        Cat cat=new Cat();\n        eat(cat);\n    //Pet对象实例化\n        Pet pet=new Dog();\n        pet=new Cat();\n        eat(pet);\n\n    }\n    public static void eat(Pet pet){\n\n        pet.eat();\n    }\n}\n/*\n输出结果：\n狗啃骨头\n猫吃鱼\n猫吃鱼\n*/\n```\n\n\n\n## Java中的相等判断\n\n对于equal方法来说都是判断整体是否相等, 若果只是使用`==`比较的是地址是否相等. 对于一个new出来的对象, 都是使用独立的内存进行存储的, 所以即使所有的字段都相同, equal也为false\n","slug":"Java","published":1,"layout":"post","photos":[],"_id":"cmafjaxae0002vpx57mgwe38x","content":"<h1 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h1><ol>\n<li><p><code>println</code>和<code>print</code>的区别在于前者在输出后自动添加换行, 后者则没有.</p>\n</li>\n<li><p><del>在创建一个对象时<code>new</code>关键字在于重新创造一个对象, 如果直接创建一个对象, 创建对象的值在<code>Java string</code>的内存池内如果存在, 该对象会直接指向这个值.</del>好像是在内存池中创建一个常量而已, 如果在常量池中有, 就直接将这个常量赋值, 否则就在常量池里再创建一个常量.(但是这样在内存池中创建多个相同的常量又有什么意义呢?)</p>\n</li>\n<li><p>在scaner类中, <code>Scaner.next()</code>一定要读到有效字符后才可以结束.对有效字符之前遇到的空白会自动将其去除, 将有效字符后的空白作为结束符(就是不能输入含有空格的字符串)</p>\n</li>\n<li><p><code>scaner.nextLIne()</code>以回车符为结束的标志. </p>\n<ol>\n<li>scaner类中有<code>hasNextXXX</code>进行判断是否还有继续输入.</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"Springboot开发\"><a href=\"#Springboot开发\" class=\"headerlink\" title=\"Springboot开发\"></a>Springboot开发</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>​\t之前经过杭电助手后端的二面, 使用Gin框架开发了一个web应用. 已经可以可以体会到, 一个框架对于应用开发效率的提升, 再开发过程中节省了很多需要去配置相关依赖的过程, 再生产中只需要注重服务的逻辑实现就可以了.<br>​\tGin框架是基于Go语言的web开发框架. 这次为了能够吃透新买的项目教程书, 学习Springboot框架, 同时也是怎加视野和理解不同的编程思维.</p>\n<h1 id=\"Java项目管理器Maven\"><a href=\"#Java项目管理器Maven\" class=\"headerlink\" title=\"Java项目管理器Maven\"></a>Java项目管理器Maven</h1><p>​\t在一个应用开发的过程中, 一定需要用到很多的第三方库, 这些库也可以称作为是包. 这些包的下载管理, 如果没有包处理器, 需要开发者自己去同意管理, 不仅耗费时间, 同时也容易混乱. 所以专门的事情就要有专门的人去做. 因此就诞生了包管理器,  在python中用到的就是pip.<br>​\t对于maven来说, 好像管理的范围更加的广泛, 是对整个Java项目的所有资源进行管理.将这个项目进行抽象成一个模型, 方便解读和管理. 也许在Maven的眼中, 我们写出来的每一个Java项目的样子其实如下图(图片来自网络)</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/39cf153e729b8733fea0c157b2e2d11e.png\"></p>\n<p>​\t其中的本地是自身项目的包管理地址, 私服有点像是镜像源吧, 但是同时翻译其实是仓库, 就和github上差不多吧, 分为私有仓库, 公有仓库, 由中央就是maven团队维护的仓库全为公有仓库.<br>​\t对于一个处在仓库中的jar包, 他的访问路径就是他的坐标.</p>\n<h2 id=\"Springboot的实践\"><a href=\"#Springboot的实践\" class=\"headerlink\" title=\"Springboot的实践\"></a>Springboot的实践</h2><p>还是按照黑马的课程, 通过IDEA进行构项目.</p>\n<p>对于Maven还是不熟悉的, 不得不说, 很难想象Maven的构建如果没有成熟的插件进行支持, 手工的构建是一件多么麻烦的事情, 当然, 也有可能是对于maven的不熟悉.</p>\n<p>对于基于maven进行构建的Java项目, 首先上来对我最卡的就是包的管理. 对于python有pip, 对于Go自身就有管理. 但是Java属实有点难到我了. jar包的管理全部都是通过maven的pom文件中的依赖路径进行管理的. 目前我还是很难理解pom文件中的所有数据文件进行的写法.但是可以确信的是, 一个项目需要的jar包文件的路径应该是全写在maven的文件中了.</p>\n<p>一开始的项目构建中, 我并没有采用视频中的jdk17, 一开始我以为是jdk版本的问题. 但是经过多方的尝试, 同时还是阅读编译器的信息, 感觉可能还是包的引入问题. 但是查阅资料, 发现Java中并没有pip这样的包管理器. 其实对我来说是犯了难了. 对于maven这个第三方的包管理器, 感觉像是为Java开发提供的一种补丁的方法. 其操作的程度对于目前初学的我来说简直是一种折磨.</p>\n<p>回顾视频, 我发现再maven的选择上, 我少勾选了web的选项, 我猜测这相当于是在我的maven文件中没有自动加上相关的web包的依赖路径. 当然在我, 加上后一时间还是无法运行. 其实从IDEA的终端看看就知道是相关的解析一直没有完成, 涉及到这些外部包的事情, 难免就会涉及的镜像源的问题. 所以一时间的想法就是配置镜像源. 但是在IDEA中的maven好像是他自带的, 因为但我在没有补下maven之前他仍然能够常的运行. 所以即使我补下maven后, 同时在我本机的配置中加上了进行源, 但是仍然慢. 只有进入开发环境中的maven进行配置后, 就能够成功运行了.</p>\n<h2 id=\"Java知识恶补\"><a href=\"#Java知识恶补\" class=\"headerlink\" title=\"Java知识恶补\"></a>Java知识恶补</h2><p>在完全没有接触Java直接进行Java的框架应用还是有一定难度. Java和C系的语言差别还是很多.</p>\n<h3 id=\"1-Java中的变量值传递的理解\"><a href=\"#1-Java中的变量值传递的理解\" class=\"headerlink\" title=\"1.Java中的变量值传递的理解\"></a>1.Java中的变量值传递的理解</h3><p>对于在Java中对于有一个方法如果传入一个数组, 对数组进行修改后, 原数组的值也会产生改变这点. 和C系的语言非常不一样. 对于C系的语言来说, 如果只是直接将一个类进行传入, 相当于传入的就是副本, 不会对原来的值进行影响. 只有在传入时, 特地使用 ‘&amp;’ 进行运算的传输值, 才是相关变量的地址值. 但是在Java中, 无论是的什么类对象, 当然目前我并没有尝试数组, 传入的其实都是这个类的地址, 其变量的值, 不能直接简单的看作一个类的整体, 其实, 变量名本身就是一个地址. 所以, 虽然对于Java来说, 所有的传递都是值传递(passed-by-value), 但是, 由于传进去的本身就是地址值, 所以通过地址的修改会造成原来的有所变化.</p>\n<p><strong>通过实践, 对于直接传入数组, 效果也是一样的. 也就是说, 在Java中, 数组其实也是一个类. 补:不对, 因为所以的类对象都是通过new方法建立的, 所以, 其实语句的左值本身就是一个引用变量. 所以传入方法中, 传入的当然就是引用了.</strong></p>\n<h3 id=\"2-Java中的静态变量与静态方法\"><a href=\"#2-Java中的静态变量与静态方法\" class=\"headerlink\" title=\"2.Java中的静态变量与静态方法\"></a>2.Java中的静态变量与静态方法</h3><p>​\t在main函数中对我想写的方法进行测试时, 产生的报错, 写的是不能在静态方法中调用非静态的方法. 查阅资料, 发现这点对于静态变量适用. 原因就在于JVM的机制问题, 目前不是非常的能够看懂. <em>静态方法类似其他语言中的函数</em></p>\n<h3 id=\"3-Java中构造方法的一点小不同\"><a href=\"#3-Java中构造方法的一点小不同\" class=\"headerlink\" title=\"3.Java中构造方法的一点小不同\"></a>3.Java中构造方法的一点小不同</h3><p>​\t大部分的构造的方法都和C++差不多,  但是, 当在类中已经定义了相关构造方法后, 编译器就不会再自动构造默认的构造方法了, 想要的话必须自己加, 不理解为什么这样设计. 同时, 再创建构造方法时, 必须使用<code>new</code>进行构造.</p>\n<h3 id=\"4-关于子类和父类的创建引用的关系\"><a href=\"#4-关于子类和父类的创建引用的关系\" class=\"headerlink\" title=\"4.关于子类和父类的创建引用的关系\"></a>4.关于子类和父类的创建引用的关系</h3><p>​\t还是贴篇文章吧, 有图有真相.</p>\n<p>​\t<a href=\"https://blog.csdn.net/weixin_42929607/article/details/107168033\">【java】父类与子类的引用赋值关系_子类引用指向父类对象-CSDN博客</a></p>\n<p>​\t父类引用指向的是子类实例的话, 只能调用从父类继承的方法和变量. 但是, 子类对于父类的方法进行覆写, 父类引用调用时, 仍然还是父类的方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Father</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>();</span><br><span class=\"line\">        f.hello(); <span class=\"comment\">//Child&#x27;s hello</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Father&#x27;s hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Father</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Child&#x27;s hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java-static修饰\"><a href=\"#Java-static修饰\" class=\"headerlink\" title=\"Java static修饰\"></a>Java static修饰</h2><p> 对于static修饰的变量和方法,  对于变量来说, 其生命周期和类的生命周期一样长, 对于静态方法来说, 可以不通过创建一个具体的对象直接进行访问使用. 所以对于静态方法来说, 如果不是访问静态变量, 就就无法对其他的类变量进行访问, 因为普通的类变量依赖于具体的对象存在.</p>\n<h2 id=\"Java中的多态优势\"><a href=\"#Java中的多态优势\" class=\"headerlink\" title=\"Java中的多态优势\"></a>Java中的多态优势</h2><p>在做算法的时候遇到<code>Queue&lt;int[]&gt; queue = LinkedList&lt;int[]&gt; list</code>的声明. 不是很明白, 为什么一定要使用父类声明变量, 然后使用子类进行实现. </p>\n<p>对于类和一个父类，在构建实现一个父类申明的时, 会对父类的方法进行构造, 然后再对子类方法进行构造. 声明的父类变量, 相当于是一个指针, 声明为可以更改为其他的子类实现.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> dd20161114_2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Master1</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//dog对象实例化</span></span><br><span class=\"line\">        Dog dog=<span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\">        eat(dog);</span><br><span class=\"line\">    <span class=\"comment\">//cat对象实例化</span></span><br><span class=\"line\">        Cat cat=<span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">        eat(cat);</span><br><span class=\"line\">    <span class=\"comment\">//Pet对象实例化</span></span><br><span class=\"line\">        Pet pet=<span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\">        pet=<span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">        eat(pet);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(Pet pet)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        pet.eat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">狗啃骨头</span></span><br><span class=\"line\"><span class=\"comment\">猫吃鱼</span></span><br><span class=\"line\"><span class=\"comment\">猫吃鱼</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Java中的相等判断\"><a href=\"#Java中的相等判断\" class=\"headerlink\" title=\"Java中的相等判断\"></a>Java中的相等判断</h2><p>对于equal方法来说都是判断整体是否相等, 若果只是使用<code>==</code>比较的是地址是否相等. 对于一个new出来的对象, 都是使用独立的内存进行存储的, 所以即使所有的字段都相同, equal也为false</p>\n","excerpt":"","more":"<h1 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h1><ol>\n<li><p><code>println</code>和<code>print</code>的区别在于前者在输出后自动添加换行, 后者则没有.</p>\n</li>\n<li><p><del>在创建一个对象时<code>new</code>关键字在于重新创造一个对象, 如果直接创建一个对象, 创建对象的值在<code>Java string</code>的内存池内如果存在, 该对象会直接指向这个值.</del>好像是在内存池中创建一个常量而已, 如果在常量池中有, 就直接将这个常量赋值, 否则就在常量池里再创建一个常量.(但是这样在内存池中创建多个相同的常量又有什么意义呢?)</p>\n</li>\n<li><p>在scaner类中, <code>Scaner.next()</code>一定要读到有效字符后才可以结束.对有效字符之前遇到的空白会自动将其去除, 将有效字符后的空白作为结束符(就是不能输入含有空格的字符串)</p>\n</li>\n<li><p><code>scaner.nextLIne()</code>以回车符为结束的标志. </p>\n<ol>\n<li>scaner类中有<code>hasNextXXX</code>进行判断是否还有继续输入.</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"Springboot开发\"><a href=\"#Springboot开发\" class=\"headerlink\" title=\"Springboot开发\"></a>Springboot开发</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>​\t之前经过杭电助手后端的二面, 使用Gin框架开发了一个web应用. 已经可以可以体会到, 一个框架对于应用开发效率的提升, 再开发过程中节省了很多需要去配置相关依赖的过程, 再生产中只需要注重服务的逻辑实现就可以了.<br>​\tGin框架是基于Go语言的web开发框架. 这次为了能够吃透新买的项目教程书, 学习Springboot框架, 同时也是怎加视野和理解不同的编程思维.</p>\n<h1 id=\"Java项目管理器Maven\"><a href=\"#Java项目管理器Maven\" class=\"headerlink\" title=\"Java项目管理器Maven\"></a>Java项目管理器Maven</h1><p>​\t在一个应用开发的过程中, 一定需要用到很多的第三方库, 这些库也可以称作为是包. 这些包的下载管理, 如果没有包处理器, 需要开发者自己去同意管理, 不仅耗费时间, 同时也容易混乱. 所以专门的事情就要有专门的人去做. 因此就诞生了包管理器,  在python中用到的就是pip.<br>​\t对于maven来说, 好像管理的范围更加的广泛, 是对整个Java项目的所有资源进行管理.将这个项目进行抽象成一个模型, 方便解读和管理. 也许在Maven的眼中, 我们写出来的每一个Java项目的样子其实如下图(图片来自网络)</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/39cf153e729b8733fea0c157b2e2d11e.png\"></p>\n<p>​\t其中的本地是自身项目的包管理地址, 私服有点像是镜像源吧, 但是同时翻译其实是仓库, 就和github上差不多吧, 分为私有仓库, 公有仓库, 由中央就是maven团队维护的仓库全为公有仓库.<br>​\t对于一个处在仓库中的jar包, 他的访问路径就是他的坐标.</p>\n<h2 id=\"Springboot的实践\"><a href=\"#Springboot的实践\" class=\"headerlink\" title=\"Springboot的实践\"></a>Springboot的实践</h2><p>还是按照黑马的课程, 通过IDEA进行构项目.</p>\n<p>对于Maven还是不熟悉的, 不得不说, 很难想象Maven的构建如果没有成熟的插件进行支持, 手工的构建是一件多么麻烦的事情, 当然, 也有可能是对于maven的不熟悉.</p>\n<p>对于基于maven进行构建的Java项目, 首先上来对我最卡的就是包的管理. 对于python有pip, 对于Go自身就有管理. 但是Java属实有点难到我了. jar包的管理全部都是通过maven的pom文件中的依赖路径进行管理的. 目前我还是很难理解pom文件中的所有数据文件进行的写法.但是可以确信的是, 一个项目需要的jar包文件的路径应该是全写在maven的文件中了.</p>\n<p>一开始的项目构建中, 我并没有采用视频中的jdk17, 一开始我以为是jdk版本的问题. 但是经过多方的尝试, 同时还是阅读编译器的信息, 感觉可能还是包的引入问题. 但是查阅资料, 发现Java中并没有pip这样的包管理器. 其实对我来说是犯了难了. 对于maven这个第三方的包管理器, 感觉像是为Java开发提供的一种补丁的方法. 其操作的程度对于目前初学的我来说简直是一种折磨.</p>\n<p>回顾视频, 我发现再maven的选择上, 我少勾选了web的选项, 我猜测这相当于是在我的maven文件中没有自动加上相关的web包的依赖路径. 当然在我, 加上后一时间还是无法运行. 其实从IDEA的终端看看就知道是相关的解析一直没有完成, 涉及到这些外部包的事情, 难免就会涉及的镜像源的问题. 所以一时间的想法就是配置镜像源. 但是在IDEA中的maven好像是他自带的, 因为但我在没有补下maven之前他仍然能够常的运行. 所以即使我补下maven后, 同时在我本机的配置中加上了进行源, 但是仍然慢. 只有进入开发环境中的maven进行配置后, 就能够成功运行了.</p>\n<h2 id=\"Java知识恶补\"><a href=\"#Java知识恶补\" class=\"headerlink\" title=\"Java知识恶补\"></a>Java知识恶补</h2><p>在完全没有接触Java直接进行Java的框架应用还是有一定难度. Java和C系的语言差别还是很多.</p>\n<h3 id=\"1-Java中的变量值传递的理解\"><a href=\"#1-Java中的变量值传递的理解\" class=\"headerlink\" title=\"1.Java中的变量值传递的理解\"></a>1.Java中的变量值传递的理解</h3><p>对于在Java中对于有一个方法如果传入一个数组, 对数组进行修改后, 原数组的值也会产生改变这点. 和C系的语言非常不一样. 对于C系的语言来说, 如果只是直接将一个类进行传入, 相当于传入的就是副本, 不会对原来的值进行影响. 只有在传入时, 特地使用 ‘&amp;’ 进行运算的传输值, 才是相关变量的地址值. 但是在Java中, 无论是的什么类对象, 当然目前我并没有尝试数组, 传入的其实都是这个类的地址, 其变量的值, 不能直接简单的看作一个类的整体, 其实, 变量名本身就是一个地址. 所以, 虽然对于Java来说, 所有的传递都是值传递(passed-by-value), 但是, 由于传进去的本身就是地址值, 所以通过地址的修改会造成原来的有所变化.</p>\n<p><strong>通过实践, 对于直接传入数组, 效果也是一样的. 也就是说, 在Java中, 数组其实也是一个类. 补:不对, 因为所以的类对象都是通过new方法建立的, 所以, 其实语句的左值本身就是一个引用变量. 所以传入方法中, 传入的当然就是引用了.</strong></p>\n<h3 id=\"2-Java中的静态变量与静态方法\"><a href=\"#2-Java中的静态变量与静态方法\" class=\"headerlink\" title=\"2.Java中的静态变量与静态方法\"></a>2.Java中的静态变量与静态方法</h3><p>​\t在main函数中对我想写的方法进行测试时, 产生的报错, 写的是不能在静态方法中调用非静态的方法. 查阅资料, 发现这点对于静态变量适用. 原因就在于JVM的机制问题, 目前不是非常的能够看懂. <em>静态方法类似其他语言中的函数</em></p>\n<h3 id=\"3-Java中构造方法的一点小不同\"><a href=\"#3-Java中构造方法的一点小不同\" class=\"headerlink\" title=\"3.Java中构造方法的一点小不同\"></a>3.Java中构造方法的一点小不同</h3><p>​\t大部分的构造的方法都和C++差不多,  但是, 当在类中已经定义了相关构造方法后, 编译器就不会再自动构造默认的构造方法了, 想要的话必须自己加, 不理解为什么这样设计. 同时, 再创建构造方法时, 必须使用<code>new</code>进行构造.</p>\n<h3 id=\"4-关于子类和父类的创建引用的关系\"><a href=\"#4-关于子类和父类的创建引用的关系\" class=\"headerlink\" title=\"4.关于子类和父类的创建引用的关系\"></a>4.关于子类和父类的创建引用的关系</h3><p>​\t还是贴篇文章吧, 有图有真相.</p>\n<p>​\t<a href=\"https://blog.csdn.net/weixin_42929607/article/details/107168033\">【java】父类与子类的引用赋值关系_子类引用指向父类对象-CSDN博客</a></p>\n<p>​\t父类引用指向的是子类实例的话, 只能调用从父类继承的方法和变量. 但是, 子类对于父类的方法进行覆写, 父类引用调用时, 仍然还是父类的方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Father</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>();</span><br><span class=\"line\">        f.hello(); <span class=\"comment\">//Child&#x27;s hello</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Father&#x27;s hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Father</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Child&#x27;s hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java-static修饰\"><a href=\"#Java-static修饰\" class=\"headerlink\" title=\"Java static修饰\"></a>Java static修饰</h2><p> 对于static修饰的变量和方法,  对于变量来说, 其生命周期和类的生命周期一样长, 对于静态方法来说, 可以不通过创建一个具体的对象直接进行访问使用. 所以对于静态方法来说, 如果不是访问静态变量, 就就无法对其他的类变量进行访问, 因为普通的类变量依赖于具体的对象存在.</p>\n<h2 id=\"Java中的多态优势\"><a href=\"#Java中的多态优势\" class=\"headerlink\" title=\"Java中的多态优势\"></a>Java中的多态优势</h2><p>在做算法的时候遇到<code>Queue&lt;int[]&gt; queue = LinkedList&lt;int[]&gt; list</code>的声明. 不是很明白, 为什么一定要使用父类声明变量, 然后使用子类进行实现. </p>\n<p>对于类和一个父类，在构建实现一个父类申明的时, 会对父类的方法进行构造, 然后再对子类方法进行构造. 声明的父类变量, 相当于是一个指针, 声明为可以更改为其他的子类实现.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> dd20161114_2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Master1</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//dog对象实例化</span></span><br><span class=\"line\">        Dog dog=<span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\">        eat(dog);</span><br><span class=\"line\">    <span class=\"comment\">//cat对象实例化</span></span><br><span class=\"line\">        Cat cat=<span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">        eat(cat);</span><br><span class=\"line\">    <span class=\"comment\">//Pet对象实例化</span></span><br><span class=\"line\">        Pet pet=<span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\">        pet=<span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">        eat(pet);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(Pet pet)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        pet.eat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">狗啃骨头</span></span><br><span class=\"line\"><span class=\"comment\">猫吃鱼</span></span><br><span class=\"line\"><span class=\"comment\">猫吃鱼</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Java中的相等判断\"><a href=\"#Java中的相等判断\" class=\"headerlink\" title=\"Java中的相等判断\"></a>Java中的相等判断</h2><p>对于equal方法来说都是判断整体是否相等, 若果只是使用<code>==</code>比较的是地址是否相等. 对于一个new出来的对象, 都是使用独立的内存进行存储的, 所以即使所有的字段都相同, equal也为false</p>\n"},{"title":"Leetcode&洛谷刷题记录与思考","date":"2025-05-06T10:47:42.000Z","updated":"2025-05-06T11:56:52.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"noticeOutdate":null,"_content":"\n# Leetcode&&洛谷刷题记录与思考\n\n## p 7517\n\n题目链接：\n\n[](https://www.luogu.com.cn/problem/solution/P7517)\n\n对于第一篇题解的理解。\n\n···\n\n```c++\n#include<bits/stdc++.h>\n#define ll long long\n#define il inline\nusing namespace std;\nconst int N=5e5+10;\nint read(){//没有多大用的快读\n    int f=1,s=0;\n    char x=getchar();\n    while(x<'0'||x>'9'){\n        if(x=='-') f=-1;\n        x=getchar();\n    }\n    while(x>='0'&&x<='9'){\n        s=s*10+x-'0';\n        x=getchar();\n    }\n    return f*s;\n}\nint a[N],b[N];//b即为桶\nint main(){\n    int n=read();\n    for(int i=1;i<=n;i++){\n        a[i]=read();\n        for(int j=1;j*j<=a[i];j++){\n            if(a[i]%j!=0) continue;//关键判断\n            int ans1=j,ans2=a[i]/j;\n            b[ans1]++;\n            if(ans1!=ans2)//特判\n                b[ans2]++;\n        }\n    }\n    ll ans=0;//爆int警告\n    for(int i=1;i<=n;i++)\n        ans+=(ll)b[a[i]]-1;//累加，减一是减去自己的贡献\n    cout<<ans;\n    return 0;\n}\n```\n\n···\n\n其中有他自己创建的读取函数，目前我并不知道这样的读取函数对于直接使用系统自带函数能够提速多少，所以目前不予讨论. \n\n这篇题解的思路在于直接将每个输入的数的因数直接统计出来,在b桶中计数, a中存储的是用户输入的结果. 最后再将用户输入的结果中的数所对应的桶中的结果倒出来, 同时减去来自自己出现时的那一次` 如果是i=j可以出现的情况应该就不用了`. 这样每次用户输入的数需要判断\n$$\nO(\\sqrt{a_i})\n$$\n第二种方法:\n\n```c++\n#include<bits/stdc++.h>\n#define ll long long\n#define il inline\nusing namespace std;\nconst int N=5e5+10;\nint read(){\n    int f=1,s=0;\n    char x=getchar();\n    while(x<'0'||x>'9'){\n        if(x=='-') f=-1;\n        x=getchar();\n    }\n    while(x>='0'&&x<='9'){\n        s=s*10+x-'0';\n        x=getchar();\n    }\n    return f*s;\n}\nint a[N],b[N];\nint main(){\n    int n=read();\n    for(int i=1;i<=n;i++)\n    \tb[read()]++;\n    ll ans=0;\n    for(int i=1;i<=N;i++){\n    \tfor(int j=2;i*j<=N;j++)\n    \t\tans+=b[i]*b[i*j];\n    \tans+=b[i]*(b[i]-1);\n\t}\n    cout<<ans;\n    return 0;\n}\n```\n\n这次通过的是将尽可能的用户输入的数的倍数全部都进行计数. 如果用户输入的数的倍数曾经在用户输入的数据中, 就相当于可以组成一个数对. 不存在的话, 自然相应的数的次数为0, 最终累成和累加的结果就是0. 但是这样的操作,不经让人觉得速度并没有快多少, 应为都要将所有的数据判断一遍, 其中会有很多的含零的数据, 同时这对内存的消耗也很大.\n\n\n\n### 总结\n\n对于这道题, 看基本上的解题思路都是直接通过设置桶, 然后直接统计倍数. 这道题的数据都是`a_i<=5e5` 所以直接将最大定位.\n\n### 自己根据学习写的代码\n\n```C\n#include<stdio.h>\n#include<string.h>\nconst long long Maxn=5e5+10;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    long long a[Maxn];\n    memset(a,0,sizeof(a));\n    \n    for(long long i=0;i<n;i++)\n    {\n        long long temp;\n        scanf(\"%lld\",&temp);\n        a[temp]++;\n    }\n    long long ans=0;\n    for(long long i=1;i<Maxn;i++){\n        ans+=a[i]*(a[i]-1);\n        for(long long j=2*i;j<Maxn;j+=i){\n            ans+=a[i]*a[j];\n        }\n    }\n    \n    printf(\"%lld\",ans);\n    return 0;\n        \n}\n```\n\n## p 2701\n\n[洛谷](https://www.luogu.com.cn/problem/P2701)\n\n根据提供的题解是通过动态规划进行解答. \n\n对于动态规划, 首先, 能够进行动态规划的题目首先可以满足暴力枚举, 但是由于数据量较大, 时间消耗过多. 其次, 可以根据节点, 会出现重复搜索或枚举,  将这部分的重复枚举进行删除或者记录, 达到省去的操作, 就可以称作是动态规划.  ==仅代表个人理解==  .\n\n对于这道题, 选取每一个点作为起点向别处延伸, 很明显可以通过暴力枚举进行解答, 同时, 通过不同的点进行容易想到, 会有很多重复, 所以就可以通过动态规划进行解题.\n\n由于面积的延伸是正方形,倘若任意一点向想对边进行延伸,即 都需要考虑他周围的点,  \n\n```c\n#include<stdio.h>\nint min_3(int ,int ,int);\nint main()\n{\n    int n,t;\n    scanf(\"%d %d\",&n,&t);\n    int a[n][n],b[n][n];\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            a[i][j]=1;\n\n    for(int i=0;i<t;i++)\n    {\n        int x,y;\n        scanf(\"%d %d\",&x,&y);\n        a[x-1][y-1]=0;\n    }\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            b[i][j]=a[i][j];\n    //到这为止已经将所有的数据进行了初始化。\n    //同时，此时的为0是第一行开始，0表示此处有树\n    //当以点为右下角,此处同时可以代表就是此处可以达到的最大面积\n\n    //将每一个点代表的正方形可视化，或者是略加思考，可以的到每个点与周围点的关系\n\n   for(int i=1;i<n;i++)\n        for(int j=1;j<n;j++)\n            if(a[i][j])\n                b[i][j]+=min_3(b[i-1][j-1],b[i][j-1],b[i-1][j]);    //不要忘记，只有当前的区域是没有树的才可能作为一个区域的右下角。\n\n    int max=0;\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            if(b[i][j]>max)\n                max=b[i][j];\n    printf(\"%d\",max);\n    return 0; \n}\n\nint min_3(int a,int b,int c)\n{\n    if(a<b)\n        if(a<c)\n            return a;\n        else\n            return c;\n    else\n        if(b<c)\n            return b;\n        else\n            return c;\n}\n\n```\n\n还是要考虑到的是，如何实现动态规划问题。关键在于如何找出者这之间的关系。\n\n## p 2678\n\n[跳石头](https://www.luogu.com.cn/problem/P2678)\n\n通过思考题目可以知道，如果是通过暴力的方法进行解答，需要每次都找到最小的那段距离，然后再将最小的那段距离加到其相邻的两端距离中最小的那一段距离中去，然后再多次重复此方法，知道达到搬移石头的次数用尽。\n\n很明显，这样的算法思路十分简单，但是遇到数据量大的题目时就略显费劲，先寻找最小的值为N，在判断最小值附近的值，这样的操作要做N遍，所以这是一个 O( n^2^ )的算法。\n\n对于题解中大佬给出的二分答案法，我一开始并没有想明白对于一个无法进行排序的距离数组，如何使用需要有序为前提的二分查找. 但是通过阅读代码发现, 其中, 解题人的思路并非是将搬移次数作为了循环条件, 而是将搬移次数M当做了一个判断二分答案是否有效的条件. 其思路是, ==如果存在一个最大的最短距离为X,那么很明显, 其他的任何一段距离必定大于等于这段最短距离== . \n\n所以, 更具解题人的思路, 只需要查找在最长距离中的能够满足搬运次数少于或等于M次的x的最大值就行了~~当然其实应该不会存在有小于的情况, 不然的话再搬一次不就有新的最大最小距离了吗~~ ,而这个答案明显一定在这之中,当然也可能会包括两端. 对于每个差找到的值, 判断如果需要达到这个查找值,对于当前数组所需要搬运的次数, 如果大于了M次的话, 就说明是太大, 将右边左移, 如果是小于M次就是将左边界右移,应为说明还可以有更大的距离.(其实,这样的算法,同样也会造成很多的数据其实不用算的,毕竟有些数据, 不可能是当前的这个数组能够组成的数据,但是, 在对于巨量的数据来说, 这多出来的计算量, 可能还没有暴力一个节点循环一遍计算量来得多 :cry: )\n\n\n\n## 14、最长公共前缀\n\n```c\nint SearchForMinString(char** strs, int strsSize) {\n    int minsize = strlen(strs[0]);  //初始化最小的长度为第一个字符串的长度\n    for (int i = 1; i < strsSize; i++) {\n        if (strlen(strs[i]) < minsize)  //如果有字符串的长度小于就取最小的\n            minsize = strlen(strs[i]);\n    }\n    return minsize;\n}\n\nchar* longestCommonPrefix(char** strs, int strsSize) {\n    int minsize = SearchForMinString(strs, strsSize);   //得到最小的字符串长度\n    char* answer = (char*)malloc(sizeof(char) * minsize+1);\n    memset(answer,0,sizeof(char) * minsize+1);\n    int answersize = 0;\n    for (int i = 0; i < minsize; i++) {\n        for (int j = 1; j < strsSize; j++) {\n            if (strs[j][i] != strs[0][i]) //有不一样的就直接返回答案\n                return answer;\n        }\n        answer[answersize] = strs[0][i]; \n        answersize++;\n        //说明所有的字符串该为位字符一样，将其赋值到结果的字符串中\n    }\n    return answer;\n}\n```\n\n对于其中的字符串的malloc应用, 定要记住字符串结尾有一个`\\0`, 但同时,`strlen`函数不会将这个计入字符长度内, 所以直接用这样的到的字符长度去创建一个字符串会导致最后一个`\\0`消失, 导致构不成一个字符串. \n\n与此同时, 对于malloc其分配的地址空间并不会直接给你初始化好, 所以建议搭配memset一起使用, 同时容易记住申请空间的大小.\n\n## 11、盛水最多的容器\n\n这道题，其实就是现实中的短板效应。任意选择的两个板能够盛水容量取决于最短的板. \n\n对于这道题直接进行暴力求解非常简单. 但是对于一些测试用例会有超时的可能.\n\n对于得到的木板数组处于无序状态,  对于任何的一个组合, 两端的木板选择只有两种. 假设从两端开始选取, 如果将两端任意一段的木板移动, 如果移动长版, 那么, 不论移动后的到的木板长度比原来大, 还是比原来小, 由于短板效应不会变, 但是底边必定变小, 所以选择的是的到的容积必定变小. 所以每次移动, 每次移动短板, 才能够是短板的长度进行变化. 这样的行为,可以一减小一定计算量.\n\n```c\nint maxArea(int* height, int heightSize) {\n    int head,tail;\n    head=0;tail=heightSize-1;\n    int maxCapacity=(height[head]<height[tail]?height[head]:height[tail])*(tail-head);\n    while(head!=tail)\n    {\n        if(height[head]>height[tail])\n            tail--;\n        else\n            head++;\n        int temp;\n        temp=(height[head]<height[tail]?height[head]:height[tail])*(tail-head);\n        if(temp>maxCapacity)\n            maxCapacity=temp;\n    }\n    return maxCapacity;\n}\n```\n\n## 209、长度最小的子数组\n\n### 解法一、滑动窗口解法\n\n对于滑动窗口来说, 本题要求的子数组连续, 所以可以想象成一个窗口进行滑动. 如果该窗口是不变的话, 那么就需要每次对窗口的大小进行调整, 将窗口的大小从1~numsSize进行尝试, 显然,这样的尝试只比O(n2)暴力搜索快一点. 无法在时间限度内完成.\n\n直接从小到大的对窗口进行增大, 存在的问题就是, 会有很多的较小的窗口其实没有计算的必要. 如果使用的是动态大小的窗口的话,可以对此进行一定的减少计算.\n\n先逐步的扩大窗口,直到, 窗口中的数能够直接达到target, 然后再考虑是否对窗口中的数进行出队操作.(对于数组前面的数来说, 必须要是窗口达到当前的大小才能够达到target所以, 应去除窗口前面的数, 看看后面的数有没有可能.) 对窗口中的数进行出队, 当窗口内数的和,小于target的时候, 这时, 就当前的子数组的子数组长度+1的长度, 就是当前子数组能到达到的最小长度, 然后再向后进行查找.\n\n```c\n// 纯粹的窗口会导致许多小窗口的无谓计算, 尤其是当target和numsSize较大的时候\n\nint minSubArrayLen(int target, int* nums, int numsSize) {\n    int windowlenth=1;\n    while(windowlenth<=numsSize){\n        for(int i=0;i<=numsSize-windowlenth;i++){\n            int sum=0;\n            for(int j=i;j-i<windowlenth;j++){\n                sum+=nums[j];\n            }\n            if(sum>=target){\n                return windowlenth;\n            }\n        }\n        windowlenth++;\n    }\n    return 0;\n}\n\n//通过动态窗口的大小进行搜索,先找到一个能够达到target的子数组\n\nint minSubArrayLen(int target, int* nums, int numsSize) {\n    int queue[numsSize],head,tail;\n    int queuesum=0;\n    int ans=numsSize+1;\n    head=tail=0;\n    for(int i=0;i<numsSize;i++){\n\n        //进行入队操作同时统计队内和\n        int temp_ans;\n        queue[tail]=nums[i];\n        tail++;\n        queuesum+=nums[i];\n\n        //达到target的时候就从头出队\n        if(queuesum>=target){\n\n            //将能够缩小的全部出队\n            while(queuesum>=target){\n                queuesum-=queue[head];\n                head++;\n            }\n\n\n            temp_ans=tail-head+1;\n            if(ans>temp_ans)\n                ans=temp_ans;\n        }\n    }\n    if (ans == numsSize+1)\n        return 0;\n    return ans;\n}\n```\n\n\n\n## p1002\n\n[过河卒](https://www.luogu.com.cn/problem/P1002)\n\n其实就是经典动态规划，需要想清楚，几个状态，通过状态的转移找到公式，然后根据公式进行推理即可。\n\n## p1004\n\n[方格取数](https://www.luogu.com.cn/problem/P1004)\n\n通过我的思考，也是动态规划根据题目的意思，但是，这次需要遍历两次，需要在第一次的时候，将取到的数置零。让后再进行第二次遍历，进行同样的操作。但是需要进行。但是对于一个直接的动态规划而言，并没有对路劲进行记忆，所以，如何对于一个数组进行置零是很大的问题，对于我的思维来说，我会考虑在加上一个大小合适的记忆数组，对于每一次的路径进行记忆，但是，我认为这十分地耗费空间，而且代码也并不优雅。\n\n通过题解的思考，这道题的解法是一个四维的动态规划，由于平时遇到的数据二维居多，对于思维的数组，一时间难以理解。最主要的在于，第一遍与第二遍是否应该分开思考的问题。\n\n通过前面对于二维动态规划的思考，如果是按照模拟的方法，对于每次数组的遍历都采用分离的思想，则每次都是贪心算法，最终获得的是局部最优解，难以证明就是整体最优解。所以在思考四维的动态规划时，也不能将两次遍历分开思考。\n\n对于相关的四维动态规划数组，其存储的应该就是，一次和第二次走到相关x，y位置是取到的最大值。两次走法应该是在相同时空观下的。但是，由于第一次走后会取走数，所以最终，在走到相同位置时，要减去相关位置的数。一定要将动态规划数组在某某位置的值和相应数组在某某位置的值分开思考。\n\n## 1010\n\n[幂次方](https://www.luogu.com.cn/problem/P1010)\n\n通过提示，想到对于一个数进行问题的分解，每次只做一层，用递归的方法。\n\n很容易想到需要用到二进制进行求解。\n\n通过阅读大佬的题解能得到一个很新的思路\n\n```c++\n#include<iostream>\n#include<cmath>\nusing namespace std;\nint a;\nvoid fff(int x)\n{\n    for(int i=14;i>=0;i--) //两万的数据最多是2（14）\n    {\n        if(pow(2,i)<=x){\n        //pow（n，m）在cmath库中，返回n^m；枚举出第一个幂次方\n            if(i==1) cout<<\"2\"; //2（1）不用再往后分解了且2^1输出为2，单独出来\n            else if(i==0) cout<<\"2(0)\"; //2（0）也不用再往后分解了，单独出来\n            else{ //若i>1则继续分解指数i\n                cout<<\"2(\";\n            fff(i);\n            cout<<\")\";\n            }\n            x-=pow(2,i); //继续循环分解余下的\n            if(x!=0) cout<<\"+\";\n            //加号处理的最简单方法：若此x还没分解完，则后面还有项，所以输出一个+号\n        }\n    }\n}\nint main()\n{\n    cin>>a;\n    fff(a);\n    return 0;\n}\n \n```\n\n## DFS的算法学习\n\n[LCR 175. 计算二叉树的深度 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/)\n\n非常简单的一道DFS的算法题目，计算二叉树的深度， 其实计算什么的深度都是一样的。这道题目相当于已经将应用的场景抽象化了，所以难度不高，在正式的应用中，真正的难度在于如何能够想到这个算法。\n\nDFS算法的根本是枚举，将所有可能的情况都按照一定的顺序进行了枚举。关键在于回溯的机制。当一条路走到底后，就进行回溯，将之前还存在有路没走的节点再次进行。\n\n话不多说上源码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\n * right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int calculateDepth(TreeNode* root) {\n        if (root == nullptr)\n            return 0;\n        int ldepth = 1;\n        int rdepth = 1;\n        ldepth += calculateDepth(root->left);\n        rdepth += calculateDepth(root->right);\n        return ldepth > rdepth ? ldepth : rdepth;\n    }\n};\n```\n\n[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/description/)\n\n简单的DFS算法可以进行实现，先找到最小的树，然后将其反转，最后在将其根节点进行反转。但是唯一的问题在于，原来又有一个疑问是有可能左右指树可能有空，但是想想，其实有空也应该进行反转，所以在写的时候疑惑解消了\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == nullptr)\n            return root;\n        invertTree(root->left);\n        invertTree(root->right);\n        TreeNode* temp;\n        temp = root->left;\n        root->left = root->right;\n        root->right = temp;\n        return root;\n    }\n};\n```\n\n[八皇后](https://www.luogu.com.cn/problem/P1219)\n\n同样需要用到DFS算法，但是这题对我来说的难点在于，如何寻找状态和判断对角线已经被占用\n\n通过题解，可得将每次下完一个棋，棋盘剩余的资源为一个状态，向下进行传递。同时，对于对角线来说，存在一定的规律，从右到左的行下标与列下标的和在同一对角线相等且唯一，从左到右，行下标与列下标的差在同一对角线值相等且唯一。\n\n```c++\n#include<iostream>\nclass Solution{\n    private:\n        int size;  //表格的大小\n        int rows[14],colunms[14],r_l[27],l_r[27];\n        int solutions;\n    public:\n        int GetSoutions() {\n            return solutions;\n        }   //用于输出解的个数\n\n        void Solve(){\n            int n;\n            std::cin>>n;\n            this->size = n;\n            queen(1);\n            printf(\"%d\",this->GetSoutions());\n        }\n\n    private:\n        void myprint(){\n            if(solutions<3){\n                for(int i = 1 ;i<=size ; i++)\n                    std::printf(\"%d \",rows[i]);\n                putchar('\\n');\n            }\n            this->solutions++;\n        }\n\n\n    // 查询合适的位置放置一枚queen，如果没有判断输出，有则标记状态，在进行下次状态转移\n        void queen(int row){\n            //row大于行数size，说明到达边界，要么是全部放置完成\n            if(row>size){\n                myprint();\n                return;\n            }\n            else{\n                //保证字典序从1开始\n                for(int col = 1 ;col<=size;col++){\n                    //说明相关列没有被占领，对角线也没有\n                    //在此处我曾将row与col差的值进行互换,输出的结果就是错误的,目前还没具体明白是为什么\n                    if((!colunms[col]) && (!r_l[col+row]) && (!l_r[row-col+size])){\n                        rows[row] = col;    //直接记录相关的列，方便下次进行输出\n                        colunms[col] = 1;\n                        r_l[col+row] = 1;\n                        l_r[row-col+size] = 1;\n                        queen(row+1);   //状态转移，按照字典序，需从行号递增\n                        \n                        //从上个函数跳出，说明已经完成了当前的这个状态的记录的所有结果需要重新进行上个状态的记录，\n                        //故清除当前状态的记录\n                        colunms[col] = r_l[col+row] = l_r[row-col+size] = 0;\n                    }\n                }\n            }\n        }      \n};\n\nint main(){\n    Solution ans = Solution();\n    ans.Solve();\n    return 0;\n}\n```\n\n[P5194](https://www.luogu.com.cn/problem/P5194)\n\n通过阅读题目，容易直接写出深度优先的算法，同时还可以想到类似背包一类。但是，分析数据的大小为1000，至少要做1000^2次运算, 除了AC的答案,其他全部超时了. \n\n所以设计到深度优先搜索的算法优化, 就是剪枝的理论.\n\n目前来说, 对于剪枝的理解就是, 通过对题目数据进行分析, 方向对于一些搜索的路径不需要再次搜索. 如题中, 但当前的砝码超出了承受范围C, 则之后的砝码都会超出, 可以直接返回, 这点只需要在判断时加上return语句即可, 但同时, 当前砝码必定大于等于前面两个砝码的质量之和, 但加上当前的砝码超出时, 直接返回后, 由于上一个状态并不能知道当前状态的下一个状态已经超出, 还会再次跳过下一个状态, 直接进行下下个, 这个对于当前的数据集来说就没有必要了, 下一个砝码超出, 则下下个砝码必定超出.\n\n同时存在关系\n\n```c++\nweight[i]+weight[i+3]<C;\nweight[i]+weight[i+1]+weight[i+2]<C;\n//所以在i状态下,可以直接跳到i+3的状态,避免了对i+1,i+2的计算,所以,也许直接从大到小搜索才是正解?\n```\n\n```c++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long sum[1005],a[1005],ans,n,c;\nvoid dfs(int cur,long long x){  //cur是为了标记当前的位置，x是记录当前的大小，防止超过C\n    if(x>c) return; //此时累加和已经超过了承受的范围\n    if(sum[cur-1]+x<=c){    //对于当前位置来说，如果前面的砝码全部取上加上现在的质量没有超过C，减少了前几次的累加操作\n        ans = max(ans,sum[cur-1]+x);\n        return;\n    }\n    ans = max(ans,x);   //当前状态已经是累加完一个数的状态了，前缀和判断的是该数之前的所有大小，进行细分\n    for(int i=1;i<cur;i++)\n        dfs(i,x+a[i]);      //从第一次最大的做不了后，他直接就从最小的开始一个个递归了，从这里开始是常态化的搜索，剪枝操作在上一步的前缀和里\n}\nint main()\n{\n    cin>>n>>c;\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n        sum[i]=sum[i-1]+a[i];   //前缀和数组\n    }\n    dfs(n+1,0);\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n[P1162 填色问题](https://www.luogu.com.cn/problem/P1162)\n\n做这道题的目的是为了能够锻炼BFS算法的思维，但是在题解中出现了比较优秀的DFS算法值得学习其中的思想\n\n```c++\n#include <iostream>\nusing namespace std;\nint a[32][32], b[32][32];\nint dx[5] = {0, -1, 1, 0, 0};\nint dy[5] = {0, 0, 0, -1, 1};\nint n, i, j;\n\nvoid dfs(int p, int q)\n{\n    int i;\n    if (p < 0 || p > n + 1 || q < 0 || q > n + 1 || a[p][q] != 0)\n        return; // 说明已经超过了搜索的范围\n    a[p][q] = 1;\n    for (i = 1; i <= 4; i++)\n        dfs(p + dx[i], q + dy[i]); // 先该点的四周进行搜索\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n        {\n            cin >> b[i][j];\n            if (b[i][j] == 0)\n                a[i][j] = 0;\n            else\n                a[i][j] = 2; // 目前这里为什么直接赋值为2还不清楚\n        }\n\n    dfs(0, 0); // 这的dfs的作用是通过染色法，将有被围墙保护起来的水进行染色\n\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j <= n; j++)\n        {\n            if (a[i][j] == 0)\n                cout << 2 << ' '; // 说明这里的水是之前被围墙保护起来的没有染色\n            else\n                cout << b[i][j] << ' ';\n        }                           // a数组中保存的是将原来包括所有墙一起染色的答案。\n            cout << '\\n';\n    }\n    return 0;\n}\n```\n\n题解的发布者的整体思想是类似在画图选择颜色中的方向选择。\n\n​\t在一开始的思考中，我都是通过正向的思维，在想，如何判断到达围墙边缘，同时判断处于围墙的内部。\n​\t从现在看来，如果我使用正向思维的DFS算算法，就需要首先找到属于围墙中心的一点，然后从这个点开始做扩散。但是如何判断这个点是围墙内的点是一个非常困难的问题，虽然从题目中已经确定，闭合圈中一定可以到达。其实可从触碰到的任意一个点进行判断，但是总感觉有点不够优雅。\n\n​\t大佬的解法是直接从外围开始，将颜料倒进水里，通过dfs的扩散效果，将除了被围墙保护起来的水进行染色，包括围墙，然后再通过和原来的状态进行对比，得到那些水是被围墙保护起来的，总体效果类似于反选。\n\n## BFS的学习\n\n对于BFS来说, 就相当于是对一棵树进行层序遍历, 然后再得出结果, 需要将每一个节点对应的下一个节点进行记录. 可以想到是先进先出的思想.\n\n[P1162 填色问题](https://www.luogu.com.cn/problem/P1162)\n\n同样也是这个问题, 但是采用的是BFS的想法\n\n题解的提供者同样也是使用的反选的方法进行搜索的. 可见思路的重要性.\n\n```c++\n#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\nconst int M = 31;   //从1开始记录图像位置\nint map[M][M];\nbool vis[M][M];     //用于记录是否是边界块，其实反向就是说这些不是被保护的块\nint n,m,a,b,c;\nqueue<int> q;\n\n\nvoid bfs(int x, int y){\n    vis[x][y] = 1;\n    q.push(x);\n    q.push(y);\n    while(!q.empty()){\n        int  w = q.front();\n        q.pop();\n        int e = q.front();\n        q.pop();\n\n        //然后向该点的四周进行判断\n        //只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断\n        if(map[w+1][e]== 0 && w!=n && !vis[w+1][e]) vis[w+1][e] = 1 , q.push(w+1), q.push(e); \n        //原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。\n        if(map[w-1][e] == 0 && w != 1 && !vis[w-1][e] )    vis[w-1][e] = 1,q.push(w-1),q.push(e);\n        if(map[w][e+1] == 0 && e != n && !vis[w][e+1] )    vis[w][e+1] = 1,q.push(w),q.push(e+1);\n        if(map[w][e-1] == 0 && e != 1 && !vis[w][e-1] )    vis[w][e-1] = 1,q.push(w),q.push(e-1);\n\n    }\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i<=n;i++){\n        for(int j =1 ;j<=n;j++){\n            cin>>map[i][j];\n            if(map[i][j] == 1) vis[i][j] = 1;\n        }\n    }\n\n    for(int i = 1;i<=n;i+=n-1){ //直接就判断两个对角上的点\n        for(int j = 1;j <= n; j++){\n            if(vis[i][j]) continue;     //说明触发到了边界点从这个点\n            bfs(i,j);\n        }\n    }\n\n    for(int i = 1 ; i <= n ; i = i + n - 1 )        //\n    {\n        for(int j = 1 ; j <= n ; j++)\n        {\n            if(vis[j][i])    continue;\n            bfs(j,i);            //十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点\n                                //但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。\n        }\n    }\n\n     for(int i = 1 ; i <= n ; i++)                //\n    {\n        for(int j = 1 ; j <= n ; j++ )\n        {\n            if(!vis[i][j])    cout<<\"2\"<<\" \";        //如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； \n            else     cout<<map[i][j]<<\" \";;\n        }\n        cout<<endl;\n    } \n    return 0;\n}\n```\n\n实现的方法还是比较符合典型的BFS的实现方法的\n\n这里放一下我根据上一个题解进行的优化尝试\n根据将外围包裹一圈, 这样就可以直接是判断点进行自由移动, 可以减少一点代码量, 但是多了一点计算.\n\n```c++\n#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\nconst int M = 32;   //从1开始记录图像位置\nint map[M][M];\nbool vis[M][M];     //用于记录是否是边界块，其实反向就是说这些不是被保护的块\nint n,m,a,b,c;\nqueue<int> q;\n\n\nvoid bfs(int x, int y){\n    vis[x][y] = 1;\n    q.push(x);\n    q.push(y);\n    while(!q.empty()){\n        int  w = q.front();\n        q.pop();\n        int e = q.front();\n        q.pop();\n\n        //然后向该点的四周进行判断\n        //只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断\n        if(map[w+1][e]== 0 && w!=n+1 && !vis[w+1][e]) vis[w+1][e] = 1 , q.push(w+1), q.push(e); \n        //原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。\n        if(map[w-1][e] == 0 && w != 0 && !vis[w-1][e] )    vis[w-1][e] = 1,q.push(w-1),q.push(e);\n        if(map[w][e+1] == 0 && e != n+1 && !vis[w][e+1] )    vis[w][e+1] = 1,q.push(w),q.push(e+1);\n        if(map[w][e-1] == 0 && e != 0 && !vis[w][e-1] )    vis[w][e-1] = 1,q.push(w),q.push(e-1);\n\n    }\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i<=n;i++){\n        for(int j =1 ;j<=n;j++){\n            cin>>map[i][j];\n            if(map[i][j] == 1) vis[i][j] = 1;\n        }\n    }\n\n    for(int i = 0;i<=n;i+=n){ //直接就判断两个对角上的点\n        for(int j = 1;j <= n; j++){\n            if(vis[i][j]) continue;     //说明触发到了边界点从这个点\n            bfs(i,j);\n        }\n    }\n\n    // for(int i = 1 ; i <= n ; i = i + n - 1 )        //\n    // {\n    //     for(int j = 1 ; j <= n ; j++)\n    //     {\n    //         if(vis[j][i])    continue;\n    //         bfs(j,i);            //十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点\n    //                             //但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。\n    //     }\n    // }\n\n     for(int i = 1 ; i <= n ; i++)                //\n    {\n        for(int j = 1 ; j <= n ; j++ )\n        {\n            if(!vis[i][j])    cout<<\"2\"<<\" \";        //如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； \n            else     cout<<map[i][j]<<\" \";;\n        }\n        cout<<endl;\n    } \n    return 0;\n}\n```\n\n[P1443](https://www.luogu.com.cn/problem/P1443)\n\n第一道自己写的题目, 但是写着写着从BFS写成了DFS, 虽然当然直接进行DFS显然超时了, 需要进行剪枝.先贴一下没有剪枝过的代码, 作为对比\n\n```c++\n#include<iostream>\n#include<queue>\nint a[401][401],b[401][401],n,m,x,y;\nint dx[]={2,1,-2,-1,2,1,-2,-1};\nint dy[]={1,2,1,2,-1,-2,-1,-2};\nbool c[401][401];\n// queue<int> q;\nusing namespace std;\n\nvoid DFS(int x,int y){\n    for(int i = 0 ;i<8;i++){\n        if(x+dx[i] < 1 || y+dy[i]< 1  || x+dx[i] > n || y+dy[i]>m || c[x][y]) continue;\n        else{\n            if(b[x+dx[i]][y+dy[i]] !=-1)\n                b[x+dx[i]][y+dy[i]] = min(b[x+dx[i]][y+dy[i]],b[x][y]+1);\n            else\n                b[x+dx[i]][y+dy[i]] = b[x][y]+1;\n            c[x][y] = 1;\n            DFS(x+dx[i],y+dy[i]);\n            c[x][y] = 0;\n        }\n    }\n    return;\n}\nint main(){\n    cin>>n>>m;\n    cin>>x>>y;\n    for(int i = 1 ;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            b[i][j] = -1;\n        }\n    }\n    b[x][y] = 0;\n    DFS(x,y);\n    for(int i = 1 ;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            cout<<b[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n想来想去没想到有什么剪枝的方法，因为本身就要判断从这个点进行会不会比另一个点进行更快，就相当于时每个点都进行判断了，要对每一条支路进行分析，剪不掉，意味着层数越深，搜索的次数就越多，因为会有很多的支路。所谓的剪枝，也许就是从层数的角度出发，但是这样就是BFS了，所以最终还是使用BFS进行求解。~~对于搜索来说，如何选择合适的搜索方式确实时需要慎重考虑的，回旋镖咋回来了~~\n\n```c++\n#include<iostream>\n#include<queue>\nint a[401][401],b[401][401],n,m,x,y;\nint dx[]={2,1,-2,-1,2,1,-2,-1};\nint dy[]={1,2,1,2,-1,-2,-1,-2};\nbool c[401][401];\t//像水扩散一样, 从一个点开始出发,将他的每层的连接进行判断,重叠部分就不用判断了,所以不用取消状态.\n\nusing namespace std;\nqueue<int> q;\nvoid BFS(int x,int y){\n    for(int i = 0 ;i<8;i++){\n        if(x+dx[i] < 1 || y+dy[i]< 1  || x+dx[i] > n || y+dy[i]>m || c[x][y]) continue;\n        else{\n            if(b[x+dx[i]][y+dy[i]] !=-1)\n                b[x+dx[i]][y+dy[i]] = min(b[x+dx[i]][y+dy[i]],b[x][y]+1);\n            else\n                b[x+dx[i]][y+dy[i]] = b[x][y]+1;\n\n            q.push(x+dx[i]);\n            q.push(y+dy[i]);\n        }\n    }\n    c[x][y] = 1;\t//之前不小心放在循环的里面了,还是要注意什么时候要对状态使用完成进行标记,放里面就有DFS的味道了\n    if(q.empty())\n        return;\n    int n_x = q.front();\n    q.pop();\n    int n_y= q.front();\n    q.pop();\n    BFS(n_x,n_y);\n    return;\n}\nint main(){\n    cin>>n>>m;\n    cin>>x>>y;\n    for(int i = 1 ;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            b[i][j] = -1;\n        }\n    }\n    b[x][y] = 0;\n    BFS(x,y);\n    for(int i = 1 ;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            cout<<b[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n## 30、串联所有单词的字串\n\n\n\n滑动窗口优化，我尝试的第一道困难题，毕竟不是算法竞赛，没有想象中难么难。当还是有一定挑战的\n\n```python\n#我的解法只使用了简单的枚举，其实并不涉及滑动窗口，在重复度高的情况中容易多次统计，造成计算重复\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m,n,ls = len(words),len(words[0]),len(s)\n        for i in range(ls):\n            if(i + m*n >ls):\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i+j*n : i+(j+1)*n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -=1\n                if differ[word] == 0:\n                    del differ[word]\n            if len(differ) == 0:\n                res.append(i)\n        return res            \n\n\n\n\n\n\n#使用滑动窗口，在最外层的循环中，循环的长度为一个单词的长度，如果是单词整体的减少，通过滑动窗口已经能够进行判断\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m, n, ls = len(words), len(words[0]), len(s)\n        for i in range(n):\n            if i + m * n > ls:\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i + j * n: i + (j + 1) * n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -= 1\n                if differ[word] == 0:\n                    del differ[word]\n                    \n                    #下一段是使用滑动窗口的优化\n                    #步长为n代表窗口的整体滑动\n            for start in range(i, ls - m * n + 1, n):\n                if start != i:\n                    #word为窗口滑动进入的新词\n                    word = s[start + (m - 1) * n: start + m * n]\n                    differ[word] += 1\n                    #可能上一个词组不是,刚好欠这个词\n                    if differ[word] == 0:\n                        del differ[word]\n                    #上一个\n                    word = s[start - n: start]\n                    differ[word] -= 1\n                    if differ[word] == 0:\n                        del differ[word]\n                if len(differ) == 0:\n                    res.append(start)\n        return res\n\n```\n\n ## 135、分发糖果\n\n第二道困难题，关于数组的，确实有难度，在于一点巧劲，常规解法的话其实需要对题目的数学模型有一定的理解\n\n```python\nint candy(int* ratings, int ratingsSize) {\n    int left[ratingsSize];\n    for (int i = 0; i < ratingsSize; i++) {\n        if (i > 0 && ratings[i] > ratings[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        } else {\n            left[i] = 1;\n        }\n    }\n    int right = 0, ret = 0;\n    for (int i = ratingsSize - 1; i >= 0; i--) {\n        if (i < ratingsSize - 1 && ratings[i] > ratings[i + 1]) {\n            right++;\n        } else {\n            right = 1;\n        }\n        ret += fmax(left[i], right);\n    }\n    return ret;\n}\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/candy/solutions/533150/fen-fa-tang-guo-by-leetcode-solution-f01p/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        ret = 1\n        inc, dec, pre = 1, 0, 1\n\n        for i in range(1, n):\n            if ratings[i] >= ratings[i - 1]:\n                dec = 0\n                pre = (1 if ratings[i] == ratings[i - 1] else pre + 1)\n                ret += pre\n                inc = pre\n            else:\n                dec += 1\n                if dec == inc:\n                    dec += 1\n                ret += dec\n                pre = 1\n        \n        return ret\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/candy/solutions/533150/fen-fa-tang-guo-by-leetcode-solution-f01p/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n## 42、接雨水\n\n第三道困难题，本来还想通过自己通过的，但是还是被最极端的用例给爆内存了\n\n```python\n\n#自己的解法， 通过每一层进行扫描，但是前提是根据给出的数据创建一个相关的矩阵判断边界，有点像是模拟的做法\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        \n        #创建一个矩阵记录边界\n        n = len(height)\n        max_height = max(height)\n        bow = [[0 for _ in range(n)] for _ in range(max_height)]\n        for i in range(n):\n            for j in range(height[i]):\n                bow[j][i] = 1\n        \n        #只有判断到一行中两个一之间的区域的时候，直接将其充满，毕竟没说石柱会有空隙\n        rain = 0\n        start=end=0\n        for i in range(max_height):\n            start=end=0\n            for j in range(n):\n                if bow[i][j] == 1 :\n                     rain += end - start\n                     start = end = j\n                else:\n                    if bow[i][start] ==1:\n                        end += 1\n        return rain\n    \n    \n#总体来说，在构建矩阵的时候，内存消耗过大，被极端用例给爆了\n```\n\n## 202.快乐数\n\n本身题目并不难, 思路也比较好像, 但是双指针的思路我一时间还是没有想到的, 同时关于他的时间优化我觉得还是有必要记录一下的\n\n```python\n#第一遍的双指针\nclass Solution:\n    def doit(self,n: int):\n        nums=[]\n        res = 0\n        while(n!=0):\n            nums.append(n%10)\n            n //= 10\n        for i in range(len(nums)):\n            res += nums[i]**2\n        return res\n    def isHappy(self, n: int) -> bool:\n        fast = n\n        for i in range(2):\n            if fast == 1:\n                return True\n            fast = self.doit(fast)\n        slow = n\n        while(fast != slow):\n            slow = self.doit(slow)\n            for i in range(2):\n                fast = self.doit(fast)\n                if fast == 1:\n                    return True\n        return False\n# 将每次快指针指向的数组\n```\n\n## 6、z字型变换\n\n还是比较简单的，就是纯粹的模拟，但是有一个需要注意的地方，会使题目更简单. 虽然在字体形式上在上升行中会出现很多的空, 但是对于题目要求的输出来说并没有需要按照z字的形式输出, 所以直接忽略空白即可, 所以只需要考虑每个字符应该处在哪一行,同时按照顺序执行就行.\n\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows < 2 : return s #小于两行的化和直接输出没有区别\n        res = [\"\" for _ in range(numRows)]\n        i, flag = 0,-1\n        for c in s :\n            res[i]+= c\n            if i == 0 or i == numRows-1:\n                flag = -flag\n            i+=flag\n        return \"\".join(res)            \n                \n```\n\n## [1715、分割回文字符IV](https://leetcode.cn/problems/palindrome-partitioning-iv/description/)\n\n困难题，确实有点出乎意料. 对于一般的字符来说, 还没用到过动态规划. 要考虑到对于一个字符串来说, 如何分割确保分割出来的子字符串为回文,并没有确定的公式, 所以就说明必须要进行一些枚举运算. 但是, 在枚举的过程中, 会存在很多重复的判断是否为回文的字符串, 对于一个变长的子串, 其子串如果在前面已经判断过是否为回文, 那么在对其重复计算明显浪费了算力.\n\n官方题解使用了一个动态规划数组, 在于任何子串, 其掐去两端的子串如果为回文, 那么, 掐去的两端字符如果相等, 那么其就为回文. 这样每次回文判断其实只需要两次计算.\n\n```java\nclass Solution {\n    public boolean checkPartitioning(String s) {\n        int n = s.length();\n        boolean[][] isPalindrome = new boolean[n][n];\n\n        //确定每次判断字符的长度，由于只是对判断原字符中的子字符是否是回文，所以只需要从小到大\n        //又因为设计上的动态规划\n        //本部分先将所有的子串是否为回文进行记录，虽然其中也有许多的冗余计算， 但是还是相对来说较少\n        for (int length = 1; length < n; length++) {\n            for (int start = 0; start <= n -length; start++){\n                //end是可以取到的\n                int end = start + length-1;\n                if (length == 1) {\n                    isPalindrome[start][end] = true;\n                }\n                else if(length == 2) {\n                    isPalindrome[start][end] = (s.charAt(start) == s.charAt(end));\n                }\n                else{\n                    //因为length从小到大，所以判断必定是从3->2,由4->3, 而其长度为这些的子串都会在前面的计算中判断过\n                    isPalindrome[start][end] = ((s.charAt(start)==s.charAt(end)) && isPalindrome[start+1][end-1]);\n                }\n            }\n        }\n\n        //直接确定中间字符串的位置即可\n        //1、0->start-1,2、start->end, 3、end+1->length\n        for(int start = 1;start<n-1;start ++){\n            if(!isPalindrome[0][start-1]) {\n                continue;\n            }\n            for(int end=start; end <n-1;end++){\n                if(isPalindrome[start][end] && isPalindrome[end+1][n-1]){\n                    return true;\n                }\n\n            }\n        }\n        return false;\n    }\n}\n```\n\n## [汇总区间](https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150)\n\n也不知道怎么之前就没有写出来, 非常普通的一个模拟. 但是他的判断逻辑写的有点有趣\n\n```go\nfunc summaryRanges(nums []int) []string {\n    var ans []string\n    for i, n := 0, len(nums); i<n; {\n        left := i\n        \n        //类似一个if判断语句， 但是这个写法很抽象\n        for i++; i<n && nums[i-1] + 1 == nums[i];i++ {\n        }\n        s := strconv.Itoa(nums[left])\n        if left < i-1 {\n            s += \"->\" + strconv.Itoa(nums[i-1])\n        }\n        ans = append(ans, s)\n    }\n    return ans\n}\n```\n\n## 3306.元音辅音字母计数 II\n\n当读完题目就想到了滑动窗口发,  不知道算不算种进步, 虽然我脑海中的滑动窗口并没有实现. 感觉还是欠点, 或者说感觉我的逻辑太麻烦不够简洁. \n\n```go\nfunc countOfSubstrings(word string, k int) int64 {\n    word_len = len(word)\n    var ans int64\n    for win_len := k+5; win_len <= word_len ;win_len++ {\n        occur := map[byte]int{'a':0,'e':0, 'i':0, 'o':0,'u':0}\n        other := 0\n        for i := 0 ;i <=win_len; i++ {\n            _, ok := map[word[i]]\n            if ok {\n                map[word[i]]++;\n            }else{\n                other++;\n            }\n        }\n    }\n}\n//....不行了, 太麻烦了, 确实不是一个好的答案, 不是很好模拟, 判断太多了.到后面就容易造成...\n```\n\n题解给出的答案是, 通过将统计恰好改为至少. 感觉也是一种题型.\n\n如果将题目先改成`至少出现辅音k次`, 那么判断逻辑就会减少, 只要确保形成的子字符串中, 至少保存了k个即以上就行. 而恰好则可以转化成count(k) - count(k+1)\n\n```go\nfunc countOfSubstrings(word string, k int) int64 {\n\tvowels := map[byte]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true} //用于快速判断是否为元音\n\tcount := func(m int) int64 {\n\t\tn := len(word)\n\t\tvar res int64 = 0\n\t\tconsonants := 0\n\t\toccur := make(map[byte]int)\n\t\tfor i, j := 0, 0; i < n; i++ {\n            //找到以当前i开头的子串能满足的最短子串\n\t\t\tfor j < n && (consonants < m || len(occur) < 5) {\n\t\t\t\tif vowels[word[j]] {\n\t\t\t\t\toccur[word[j]]++\n\t\t\t\t} else {\n\t\t\t\t\tconsonants++\n\t\t\t\t}\n\t\t\t\tj++\n\t\t\t}\n\t\t\tif consonants >= m && len(occur) == 5 {\n                //对于当前子串来说已经满足了条件, 那么,后面继续添加长度就必定满足条件, 不用判断\n\t\t\t\tres += int64(n - j + 1)\n\t\t\t}\n            //接下来当前子串开头i要向后移位, 需要判断是否会对当前的满足条件造成影响\n\t\t\tif vowels[word[i]] {\n\t\t\t\toccur[word[i]]--\n\t\t\t\tif occur[word[i]] == 0 {\n\t\t\t\t\tdelete(occur, word[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsonants--\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\treturn count(k) - count(k+1)\n}\n```\n\n## [1920.基于排列构建数组](https://leetcode.cn/problems/build-array-from-permutation/description/?envType=daily-question&envId=2025-05-06)\n\n从题目来说, 不考虑优化就是一件非常简单的任务.解法二的思路比较有意思. 这对数据来说, 所有的数据都不会超过1000的大小. 对于如何原地交换的问题在于, 直接交换, 可能只有一个数据满足要求, 会导致另一个数据失效, 同时也会打乱原来排序号的数据. 关键在于如何能够在一个地方同时存储两个数据, 一个代表的是原数据, 另一个代表的是更改后的数据. \n通过观察数据最大到999, 所以可以将更改数据整体存储在1000位以上, 在通过第二遍历就能够将原数据去除, 只保留1000位以上的数据\n\n```go\nfunc buildArray(nums []int) []int {\n    for i,_ :=  range nums {\n        nums[i] += 1000*(nums[nums[i]]%1000);\n    }\n    for i,_ := range nums{\n        nums[i] /= 1000\n    }\n    return nums\n}\n```\n\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        int n = nums.length;\n        for(int i = 0;i<n;i++){\n            nums[i] += 1000*(nums[nums[i]]%1000);\n        }\n        for(int i = 0;i<n;i++){\n            nums[i] /= 1000;\n        }\n        return nums;\n    }\n}\n```\n\n但是会降低运行速度, 毕竟变成O(n^2)\n","source":"_posts/Leetcode&洛谷刷题记录与思考.md","raw":"---\ntitle: Leetcode&洛谷刷题记录与思考\ndate: 2025-05-06 18:47:42\nupdated: 2025-05-06 19:56:52\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\nnoticeOutdate:\n---\n\n# Leetcode&&洛谷刷题记录与思考\n\n## p 7517\n\n题目链接：\n\n[](https://www.luogu.com.cn/problem/solution/P7517)\n\n对于第一篇题解的理解。\n\n···\n\n```c++\n#include<bits/stdc++.h>\n#define ll long long\n#define il inline\nusing namespace std;\nconst int N=5e5+10;\nint read(){//没有多大用的快读\n    int f=1,s=0;\n    char x=getchar();\n    while(x<'0'||x>'9'){\n        if(x=='-') f=-1;\n        x=getchar();\n    }\n    while(x>='0'&&x<='9'){\n        s=s*10+x-'0';\n        x=getchar();\n    }\n    return f*s;\n}\nint a[N],b[N];//b即为桶\nint main(){\n    int n=read();\n    for(int i=1;i<=n;i++){\n        a[i]=read();\n        for(int j=1;j*j<=a[i];j++){\n            if(a[i]%j!=0) continue;//关键判断\n            int ans1=j,ans2=a[i]/j;\n            b[ans1]++;\n            if(ans1!=ans2)//特判\n                b[ans2]++;\n        }\n    }\n    ll ans=0;//爆int警告\n    for(int i=1;i<=n;i++)\n        ans+=(ll)b[a[i]]-1;//累加，减一是减去自己的贡献\n    cout<<ans;\n    return 0;\n}\n```\n\n···\n\n其中有他自己创建的读取函数，目前我并不知道这样的读取函数对于直接使用系统自带函数能够提速多少，所以目前不予讨论. \n\n这篇题解的思路在于直接将每个输入的数的因数直接统计出来,在b桶中计数, a中存储的是用户输入的结果. 最后再将用户输入的结果中的数所对应的桶中的结果倒出来, 同时减去来自自己出现时的那一次` 如果是i=j可以出现的情况应该就不用了`. 这样每次用户输入的数需要判断\n$$\nO(\\sqrt{a_i})\n$$\n第二种方法:\n\n```c++\n#include<bits/stdc++.h>\n#define ll long long\n#define il inline\nusing namespace std;\nconst int N=5e5+10;\nint read(){\n    int f=1,s=0;\n    char x=getchar();\n    while(x<'0'||x>'9'){\n        if(x=='-') f=-1;\n        x=getchar();\n    }\n    while(x>='0'&&x<='9'){\n        s=s*10+x-'0';\n        x=getchar();\n    }\n    return f*s;\n}\nint a[N],b[N];\nint main(){\n    int n=read();\n    for(int i=1;i<=n;i++)\n    \tb[read()]++;\n    ll ans=0;\n    for(int i=1;i<=N;i++){\n    \tfor(int j=2;i*j<=N;j++)\n    \t\tans+=b[i]*b[i*j];\n    \tans+=b[i]*(b[i]-1);\n\t}\n    cout<<ans;\n    return 0;\n}\n```\n\n这次通过的是将尽可能的用户输入的数的倍数全部都进行计数. 如果用户输入的数的倍数曾经在用户输入的数据中, 就相当于可以组成一个数对. 不存在的话, 自然相应的数的次数为0, 最终累成和累加的结果就是0. 但是这样的操作,不经让人觉得速度并没有快多少, 应为都要将所有的数据判断一遍, 其中会有很多的含零的数据, 同时这对内存的消耗也很大.\n\n\n\n### 总结\n\n对于这道题, 看基本上的解题思路都是直接通过设置桶, 然后直接统计倍数. 这道题的数据都是`a_i<=5e5` 所以直接将最大定位.\n\n### 自己根据学习写的代码\n\n```C\n#include<stdio.h>\n#include<string.h>\nconst long long Maxn=5e5+10;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    long long a[Maxn];\n    memset(a,0,sizeof(a));\n    \n    for(long long i=0;i<n;i++)\n    {\n        long long temp;\n        scanf(\"%lld\",&temp);\n        a[temp]++;\n    }\n    long long ans=0;\n    for(long long i=1;i<Maxn;i++){\n        ans+=a[i]*(a[i]-1);\n        for(long long j=2*i;j<Maxn;j+=i){\n            ans+=a[i]*a[j];\n        }\n    }\n    \n    printf(\"%lld\",ans);\n    return 0;\n        \n}\n```\n\n## p 2701\n\n[洛谷](https://www.luogu.com.cn/problem/P2701)\n\n根据提供的题解是通过动态规划进行解答. \n\n对于动态规划, 首先, 能够进行动态规划的题目首先可以满足暴力枚举, 但是由于数据量较大, 时间消耗过多. 其次, 可以根据节点, 会出现重复搜索或枚举,  将这部分的重复枚举进行删除或者记录, 达到省去的操作, 就可以称作是动态规划.  ==仅代表个人理解==  .\n\n对于这道题, 选取每一个点作为起点向别处延伸, 很明显可以通过暴力枚举进行解答, 同时, 通过不同的点进行容易想到, 会有很多重复, 所以就可以通过动态规划进行解题.\n\n由于面积的延伸是正方形,倘若任意一点向想对边进行延伸,即 都需要考虑他周围的点,  \n\n```c\n#include<stdio.h>\nint min_3(int ,int ,int);\nint main()\n{\n    int n,t;\n    scanf(\"%d %d\",&n,&t);\n    int a[n][n],b[n][n];\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            a[i][j]=1;\n\n    for(int i=0;i<t;i++)\n    {\n        int x,y;\n        scanf(\"%d %d\",&x,&y);\n        a[x-1][y-1]=0;\n    }\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            b[i][j]=a[i][j];\n    //到这为止已经将所有的数据进行了初始化。\n    //同时，此时的为0是第一行开始，0表示此处有树\n    //当以点为右下角,此处同时可以代表就是此处可以达到的最大面积\n\n    //将每一个点代表的正方形可视化，或者是略加思考，可以的到每个点与周围点的关系\n\n   for(int i=1;i<n;i++)\n        for(int j=1;j<n;j++)\n            if(a[i][j])\n                b[i][j]+=min_3(b[i-1][j-1],b[i][j-1],b[i-1][j]);    //不要忘记，只有当前的区域是没有树的才可能作为一个区域的右下角。\n\n    int max=0;\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            if(b[i][j]>max)\n                max=b[i][j];\n    printf(\"%d\",max);\n    return 0; \n}\n\nint min_3(int a,int b,int c)\n{\n    if(a<b)\n        if(a<c)\n            return a;\n        else\n            return c;\n    else\n        if(b<c)\n            return b;\n        else\n            return c;\n}\n\n```\n\n还是要考虑到的是，如何实现动态规划问题。关键在于如何找出者这之间的关系。\n\n## p 2678\n\n[跳石头](https://www.luogu.com.cn/problem/P2678)\n\n通过思考题目可以知道，如果是通过暴力的方法进行解答，需要每次都找到最小的那段距离，然后再将最小的那段距离加到其相邻的两端距离中最小的那一段距离中去，然后再多次重复此方法，知道达到搬移石头的次数用尽。\n\n很明显，这样的算法思路十分简单，但是遇到数据量大的题目时就略显费劲，先寻找最小的值为N，在判断最小值附近的值，这样的操作要做N遍，所以这是一个 O( n^2^ )的算法。\n\n对于题解中大佬给出的二分答案法，我一开始并没有想明白对于一个无法进行排序的距离数组，如何使用需要有序为前提的二分查找. 但是通过阅读代码发现, 其中, 解题人的思路并非是将搬移次数作为了循环条件, 而是将搬移次数M当做了一个判断二分答案是否有效的条件. 其思路是, ==如果存在一个最大的最短距离为X,那么很明显, 其他的任何一段距离必定大于等于这段最短距离== . \n\n所以, 更具解题人的思路, 只需要查找在最长距离中的能够满足搬运次数少于或等于M次的x的最大值就行了~~当然其实应该不会存在有小于的情况, 不然的话再搬一次不就有新的最大最小距离了吗~~ ,而这个答案明显一定在这之中,当然也可能会包括两端. 对于每个差找到的值, 判断如果需要达到这个查找值,对于当前数组所需要搬运的次数, 如果大于了M次的话, 就说明是太大, 将右边左移, 如果是小于M次就是将左边界右移,应为说明还可以有更大的距离.(其实,这样的算法,同样也会造成很多的数据其实不用算的,毕竟有些数据, 不可能是当前的这个数组能够组成的数据,但是, 在对于巨量的数据来说, 这多出来的计算量, 可能还没有暴力一个节点循环一遍计算量来得多 :cry: )\n\n\n\n## 14、最长公共前缀\n\n```c\nint SearchForMinString(char** strs, int strsSize) {\n    int minsize = strlen(strs[0]);  //初始化最小的长度为第一个字符串的长度\n    for (int i = 1; i < strsSize; i++) {\n        if (strlen(strs[i]) < minsize)  //如果有字符串的长度小于就取最小的\n            minsize = strlen(strs[i]);\n    }\n    return minsize;\n}\n\nchar* longestCommonPrefix(char** strs, int strsSize) {\n    int minsize = SearchForMinString(strs, strsSize);   //得到最小的字符串长度\n    char* answer = (char*)malloc(sizeof(char) * minsize+1);\n    memset(answer,0,sizeof(char) * minsize+1);\n    int answersize = 0;\n    for (int i = 0; i < minsize; i++) {\n        for (int j = 1; j < strsSize; j++) {\n            if (strs[j][i] != strs[0][i]) //有不一样的就直接返回答案\n                return answer;\n        }\n        answer[answersize] = strs[0][i]; \n        answersize++;\n        //说明所有的字符串该为位字符一样，将其赋值到结果的字符串中\n    }\n    return answer;\n}\n```\n\n对于其中的字符串的malloc应用, 定要记住字符串结尾有一个`\\0`, 但同时,`strlen`函数不会将这个计入字符长度内, 所以直接用这样的到的字符长度去创建一个字符串会导致最后一个`\\0`消失, 导致构不成一个字符串. \n\n与此同时, 对于malloc其分配的地址空间并不会直接给你初始化好, 所以建议搭配memset一起使用, 同时容易记住申请空间的大小.\n\n## 11、盛水最多的容器\n\n这道题，其实就是现实中的短板效应。任意选择的两个板能够盛水容量取决于最短的板. \n\n对于这道题直接进行暴力求解非常简单. 但是对于一些测试用例会有超时的可能.\n\n对于得到的木板数组处于无序状态,  对于任何的一个组合, 两端的木板选择只有两种. 假设从两端开始选取, 如果将两端任意一段的木板移动, 如果移动长版, 那么, 不论移动后的到的木板长度比原来大, 还是比原来小, 由于短板效应不会变, 但是底边必定变小, 所以选择的是的到的容积必定变小. 所以每次移动, 每次移动短板, 才能够是短板的长度进行变化. 这样的行为,可以一减小一定计算量.\n\n```c\nint maxArea(int* height, int heightSize) {\n    int head,tail;\n    head=0;tail=heightSize-1;\n    int maxCapacity=(height[head]<height[tail]?height[head]:height[tail])*(tail-head);\n    while(head!=tail)\n    {\n        if(height[head]>height[tail])\n            tail--;\n        else\n            head++;\n        int temp;\n        temp=(height[head]<height[tail]?height[head]:height[tail])*(tail-head);\n        if(temp>maxCapacity)\n            maxCapacity=temp;\n    }\n    return maxCapacity;\n}\n```\n\n## 209、长度最小的子数组\n\n### 解法一、滑动窗口解法\n\n对于滑动窗口来说, 本题要求的子数组连续, 所以可以想象成一个窗口进行滑动. 如果该窗口是不变的话, 那么就需要每次对窗口的大小进行调整, 将窗口的大小从1~numsSize进行尝试, 显然,这样的尝试只比O(n2)暴力搜索快一点. 无法在时间限度内完成.\n\n直接从小到大的对窗口进行增大, 存在的问题就是, 会有很多的较小的窗口其实没有计算的必要. 如果使用的是动态大小的窗口的话,可以对此进行一定的减少计算.\n\n先逐步的扩大窗口,直到, 窗口中的数能够直接达到target, 然后再考虑是否对窗口中的数进行出队操作.(对于数组前面的数来说, 必须要是窗口达到当前的大小才能够达到target所以, 应去除窗口前面的数, 看看后面的数有没有可能.) 对窗口中的数进行出队, 当窗口内数的和,小于target的时候, 这时, 就当前的子数组的子数组长度+1的长度, 就是当前子数组能到达到的最小长度, 然后再向后进行查找.\n\n```c\n// 纯粹的窗口会导致许多小窗口的无谓计算, 尤其是当target和numsSize较大的时候\n\nint minSubArrayLen(int target, int* nums, int numsSize) {\n    int windowlenth=1;\n    while(windowlenth<=numsSize){\n        for(int i=0;i<=numsSize-windowlenth;i++){\n            int sum=0;\n            for(int j=i;j-i<windowlenth;j++){\n                sum+=nums[j];\n            }\n            if(sum>=target){\n                return windowlenth;\n            }\n        }\n        windowlenth++;\n    }\n    return 0;\n}\n\n//通过动态窗口的大小进行搜索,先找到一个能够达到target的子数组\n\nint minSubArrayLen(int target, int* nums, int numsSize) {\n    int queue[numsSize],head,tail;\n    int queuesum=0;\n    int ans=numsSize+1;\n    head=tail=0;\n    for(int i=0;i<numsSize;i++){\n\n        //进行入队操作同时统计队内和\n        int temp_ans;\n        queue[tail]=nums[i];\n        tail++;\n        queuesum+=nums[i];\n\n        //达到target的时候就从头出队\n        if(queuesum>=target){\n\n            //将能够缩小的全部出队\n            while(queuesum>=target){\n                queuesum-=queue[head];\n                head++;\n            }\n\n\n            temp_ans=tail-head+1;\n            if(ans>temp_ans)\n                ans=temp_ans;\n        }\n    }\n    if (ans == numsSize+1)\n        return 0;\n    return ans;\n}\n```\n\n\n\n## p1002\n\n[过河卒](https://www.luogu.com.cn/problem/P1002)\n\n其实就是经典动态规划，需要想清楚，几个状态，通过状态的转移找到公式，然后根据公式进行推理即可。\n\n## p1004\n\n[方格取数](https://www.luogu.com.cn/problem/P1004)\n\n通过我的思考，也是动态规划根据题目的意思，但是，这次需要遍历两次，需要在第一次的时候，将取到的数置零。让后再进行第二次遍历，进行同样的操作。但是需要进行。但是对于一个直接的动态规划而言，并没有对路劲进行记忆，所以，如何对于一个数组进行置零是很大的问题，对于我的思维来说，我会考虑在加上一个大小合适的记忆数组，对于每一次的路径进行记忆，但是，我认为这十分地耗费空间，而且代码也并不优雅。\n\n通过题解的思考，这道题的解法是一个四维的动态规划，由于平时遇到的数据二维居多，对于思维的数组，一时间难以理解。最主要的在于，第一遍与第二遍是否应该分开思考的问题。\n\n通过前面对于二维动态规划的思考，如果是按照模拟的方法，对于每次数组的遍历都采用分离的思想，则每次都是贪心算法，最终获得的是局部最优解，难以证明就是整体最优解。所以在思考四维的动态规划时，也不能将两次遍历分开思考。\n\n对于相关的四维动态规划数组，其存储的应该就是，一次和第二次走到相关x，y位置是取到的最大值。两次走法应该是在相同时空观下的。但是，由于第一次走后会取走数，所以最终，在走到相同位置时，要减去相关位置的数。一定要将动态规划数组在某某位置的值和相应数组在某某位置的值分开思考。\n\n## 1010\n\n[幂次方](https://www.luogu.com.cn/problem/P1010)\n\n通过提示，想到对于一个数进行问题的分解，每次只做一层，用递归的方法。\n\n很容易想到需要用到二进制进行求解。\n\n通过阅读大佬的题解能得到一个很新的思路\n\n```c++\n#include<iostream>\n#include<cmath>\nusing namespace std;\nint a;\nvoid fff(int x)\n{\n    for(int i=14;i>=0;i--) //两万的数据最多是2（14）\n    {\n        if(pow(2,i)<=x){\n        //pow（n，m）在cmath库中，返回n^m；枚举出第一个幂次方\n            if(i==1) cout<<\"2\"; //2（1）不用再往后分解了且2^1输出为2，单独出来\n            else if(i==0) cout<<\"2(0)\"; //2（0）也不用再往后分解了，单独出来\n            else{ //若i>1则继续分解指数i\n                cout<<\"2(\";\n            fff(i);\n            cout<<\")\";\n            }\n            x-=pow(2,i); //继续循环分解余下的\n            if(x!=0) cout<<\"+\";\n            //加号处理的最简单方法：若此x还没分解完，则后面还有项，所以输出一个+号\n        }\n    }\n}\nint main()\n{\n    cin>>a;\n    fff(a);\n    return 0;\n}\n \n```\n\n## DFS的算法学习\n\n[LCR 175. 计算二叉树的深度 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/)\n\n非常简单的一道DFS的算法题目，计算二叉树的深度， 其实计算什么的深度都是一样的。这道题目相当于已经将应用的场景抽象化了，所以难度不高，在正式的应用中，真正的难度在于如何能够想到这个算法。\n\nDFS算法的根本是枚举，将所有可能的情况都按照一定的顺序进行了枚举。关键在于回溯的机制。当一条路走到底后，就进行回溯，将之前还存在有路没走的节点再次进行。\n\n话不多说上源码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\n * right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int calculateDepth(TreeNode* root) {\n        if (root == nullptr)\n            return 0;\n        int ldepth = 1;\n        int rdepth = 1;\n        ldepth += calculateDepth(root->left);\n        rdepth += calculateDepth(root->right);\n        return ldepth > rdepth ? ldepth : rdepth;\n    }\n};\n```\n\n[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/description/)\n\n简单的DFS算法可以进行实现，先找到最小的树，然后将其反转，最后在将其根节点进行反转。但是唯一的问题在于，原来又有一个疑问是有可能左右指树可能有空，但是想想，其实有空也应该进行反转，所以在写的时候疑惑解消了\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == nullptr)\n            return root;\n        invertTree(root->left);\n        invertTree(root->right);\n        TreeNode* temp;\n        temp = root->left;\n        root->left = root->right;\n        root->right = temp;\n        return root;\n    }\n};\n```\n\n[八皇后](https://www.luogu.com.cn/problem/P1219)\n\n同样需要用到DFS算法，但是这题对我来说的难点在于，如何寻找状态和判断对角线已经被占用\n\n通过题解，可得将每次下完一个棋，棋盘剩余的资源为一个状态，向下进行传递。同时，对于对角线来说，存在一定的规律，从右到左的行下标与列下标的和在同一对角线相等且唯一，从左到右，行下标与列下标的差在同一对角线值相等且唯一。\n\n```c++\n#include<iostream>\nclass Solution{\n    private:\n        int size;  //表格的大小\n        int rows[14],colunms[14],r_l[27],l_r[27];\n        int solutions;\n    public:\n        int GetSoutions() {\n            return solutions;\n        }   //用于输出解的个数\n\n        void Solve(){\n            int n;\n            std::cin>>n;\n            this->size = n;\n            queen(1);\n            printf(\"%d\",this->GetSoutions());\n        }\n\n    private:\n        void myprint(){\n            if(solutions<3){\n                for(int i = 1 ;i<=size ; i++)\n                    std::printf(\"%d \",rows[i]);\n                putchar('\\n');\n            }\n            this->solutions++;\n        }\n\n\n    // 查询合适的位置放置一枚queen，如果没有判断输出，有则标记状态，在进行下次状态转移\n        void queen(int row){\n            //row大于行数size，说明到达边界，要么是全部放置完成\n            if(row>size){\n                myprint();\n                return;\n            }\n            else{\n                //保证字典序从1开始\n                for(int col = 1 ;col<=size;col++){\n                    //说明相关列没有被占领，对角线也没有\n                    //在此处我曾将row与col差的值进行互换,输出的结果就是错误的,目前还没具体明白是为什么\n                    if((!colunms[col]) && (!r_l[col+row]) && (!l_r[row-col+size])){\n                        rows[row] = col;    //直接记录相关的列，方便下次进行输出\n                        colunms[col] = 1;\n                        r_l[col+row] = 1;\n                        l_r[row-col+size] = 1;\n                        queen(row+1);   //状态转移，按照字典序，需从行号递增\n                        \n                        //从上个函数跳出，说明已经完成了当前的这个状态的记录的所有结果需要重新进行上个状态的记录，\n                        //故清除当前状态的记录\n                        colunms[col] = r_l[col+row] = l_r[row-col+size] = 0;\n                    }\n                }\n            }\n        }      \n};\n\nint main(){\n    Solution ans = Solution();\n    ans.Solve();\n    return 0;\n}\n```\n\n[P5194](https://www.luogu.com.cn/problem/P5194)\n\n通过阅读题目，容易直接写出深度优先的算法，同时还可以想到类似背包一类。但是，分析数据的大小为1000，至少要做1000^2次运算, 除了AC的答案,其他全部超时了. \n\n所以设计到深度优先搜索的算法优化, 就是剪枝的理论.\n\n目前来说, 对于剪枝的理解就是, 通过对题目数据进行分析, 方向对于一些搜索的路径不需要再次搜索. 如题中, 但当前的砝码超出了承受范围C, 则之后的砝码都会超出, 可以直接返回, 这点只需要在判断时加上return语句即可, 但同时, 当前砝码必定大于等于前面两个砝码的质量之和, 但加上当前的砝码超出时, 直接返回后, 由于上一个状态并不能知道当前状态的下一个状态已经超出, 还会再次跳过下一个状态, 直接进行下下个, 这个对于当前的数据集来说就没有必要了, 下一个砝码超出, 则下下个砝码必定超出.\n\n同时存在关系\n\n```c++\nweight[i]+weight[i+3]<C;\nweight[i]+weight[i+1]+weight[i+2]<C;\n//所以在i状态下,可以直接跳到i+3的状态,避免了对i+1,i+2的计算,所以,也许直接从大到小搜索才是正解?\n```\n\n```c++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long sum[1005],a[1005],ans,n,c;\nvoid dfs(int cur,long long x){  //cur是为了标记当前的位置，x是记录当前的大小，防止超过C\n    if(x>c) return; //此时累加和已经超过了承受的范围\n    if(sum[cur-1]+x<=c){    //对于当前位置来说，如果前面的砝码全部取上加上现在的质量没有超过C，减少了前几次的累加操作\n        ans = max(ans,sum[cur-1]+x);\n        return;\n    }\n    ans = max(ans,x);   //当前状态已经是累加完一个数的状态了，前缀和判断的是该数之前的所有大小，进行细分\n    for(int i=1;i<cur;i++)\n        dfs(i,x+a[i]);      //从第一次最大的做不了后，他直接就从最小的开始一个个递归了，从这里开始是常态化的搜索，剪枝操作在上一步的前缀和里\n}\nint main()\n{\n    cin>>n>>c;\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n        sum[i]=sum[i-1]+a[i];   //前缀和数组\n    }\n    dfs(n+1,0);\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n[P1162 填色问题](https://www.luogu.com.cn/problem/P1162)\n\n做这道题的目的是为了能够锻炼BFS算法的思维，但是在题解中出现了比较优秀的DFS算法值得学习其中的思想\n\n```c++\n#include <iostream>\nusing namespace std;\nint a[32][32], b[32][32];\nint dx[5] = {0, -1, 1, 0, 0};\nint dy[5] = {0, 0, 0, -1, 1};\nint n, i, j;\n\nvoid dfs(int p, int q)\n{\n    int i;\n    if (p < 0 || p > n + 1 || q < 0 || q > n + 1 || a[p][q] != 0)\n        return; // 说明已经超过了搜索的范围\n    a[p][q] = 1;\n    for (i = 1; i <= 4; i++)\n        dfs(p + dx[i], q + dy[i]); // 先该点的四周进行搜索\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n        {\n            cin >> b[i][j];\n            if (b[i][j] == 0)\n                a[i][j] = 0;\n            else\n                a[i][j] = 2; // 目前这里为什么直接赋值为2还不清楚\n        }\n\n    dfs(0, 0); // 这的dfs的作用是通过染色法，将有被围墙保护起来的水进行染色\n\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j <= n; j++)\n        {\n            if (a[i][j] == 0)\n                cout << 2 << ' '; // 说明这里的水是之前被围墙保护起来的没有染色\n            else\n                cout << b[i][j] << ' ';\n        }                           // a数组中保存的是将原来包括所有墙一起染色的答案。\n            cout << '\\n';\n    }\n    return 0;\n}\n```\n\n题解的发布者的整体思想是类似在画图选择颜色中的方向选择。\n\n​\t在一开始的思考中，我都是通过正向的思维，在想，如何判断到达围墙边缘，同时判断处于围墙的内部。\n​\t从现在看来，如果我使用正向思维的DFS算算法，就需要首先找到属于围墙中心的一点，然后从这个点开始做扩散。但是如何判断这个点是围墙内的点是一个非常困难的问题，虽然从题目中已经确定，闭合圈中一定可以到达。其实可从触碰到的任意一个点进行判断，但是总感觉有点不够优雅。\n\n​\t大佬的解法是直接从外围开始，将颜料倒进水里，通过dfs的扩散效果，将除了被围墙保护起来的水进行染色，包括围墙，然后再通过和原来的状态进行对比，得到那些水是被围墙保护起来的，总体效果类似于反选。\n\n## BFS的学习\n\n对于BFS来说, 就相当于是对一棵树进行层序遍历, 然后再得出结果, 需要将每一个节点对应的下一个节点进行记录. 可以想到是先进先出的思想.\n\n[P1162 填色问题](https://www.luogu.com.cn/problem/P1162)\n\n同样也是这个问题, 但是采用的是BFS的想法\n\n题解的提供者同样也是使用的反选的方法进行搜索的. 可见思路的重要性.\n\n```c++\n#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\nconst int M = 31;   //从1开始记录图像位置\nint map[M][M];\nbool vis[M][M];     //用于记录是否是边界块，其实反向就是说这些不是被保护的块\nint n,m,a,b,c;\nqueue<int> q;\n\n\nvoid bfs(int x, int y){\n    vis[x][y] = 1;\n    q.push(x);\n    q.push(y);\n    while(!q.empty()){\n        int  w = q.front();\n        q.pop();\n        int e = q.front();\n        q.pop();\n\n        //然后向该点的四周进行判断\n        //只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断\n        if(map[w+1][e]== 0 && w!=n && !vis[w+1][e]) vis[w+1][e] = 1 , q.push(w+1), q.push(e); \n        //原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。\n        if(map[w-1][e] == 0 && w != 1 && !vis[w-1][e] )    vis[w-1][e] = 1,q.push(w-1),q.push(e);\n        if(map[w][e+1] == 0 && e != n && !vis[w][e+1] )    vis[w][e+1] = 1,q.push(w),q.push(e+1);\n        if(map[w][e-1] == 0 && e != 1 && !vis[w][e-1] )    vis[w][e-1] = 1,q.push(w),q.push(e-1);\n\n    }\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i<=n;i++){\n        for(int j =1 ;j<=n;j++){\n            cin>>map[i][j];\n            if(map[i][j] == 1) vis[i][j] = 1;\n        }\n    }\n\n    for(int i = 1;i<=n;i+=n-1){ //直接就判断两个对角上的点\n        for(int j = 1;j <= n; j++){\n            if(vis[i][j]) continue;     //说明触发到了边界点从这个点\n            bfs(i,j);\n        }\n    }\n\n    for(int i = 1 ; i <= n ; i = i + n - 1 )        //\n    {\n        for(int j = 1 ; j <= n ; j++)\n        {\n            if(vis[j][i])    continue;\n            bfs(j,i);            //十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点\n                                //但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。\n        }\n    }\n\n     for(int i = 1 ; i <= n ; i++)                //\n    {\n        for(int j = 1 ; j <= n ; j++ )\n        {\n            if(!vis[i][j])    cout<<\"2\"<<\" \";        //如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； \n            else     cout<<map[i][j]<<\" \";;\n        }\n        cout<<endl;\n    } \n    return 0;\n}\n```\n\n实现的方法还是比较符合典型的BFS的实现方法的\n\n这里放一下我根据上一个题解进行的优化尝试\n根据将外围包裹一圈, 这样就可以直接是判断点进行自由移动, 可以减少一点代码量, 但是多了一点计算.\n\n```c++\n#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\nconst int M = 32;   //从1开始记录图像位置\nint map[M][M];\nbool vis[M][M];     //用于记录是否是边界块，其实反向就是说这些不是被保护的块\nint n,m,a,b,c;\nqueue<int> q;\n\n\nvoid bfs(int x, int y){\n    vis[x][y] = 1;\n    q.push(x);\n    q.push(y);\n    while(!q.empty()){\n        int  w = q.front();\n        q.pop();\n        int e = q.front();\n        q.pop();\n\n        //然后向该点的四周进行判断\n        //只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断\n        if(map[w+1][e]== 0 && w!=n+1 && !vis[w+1][e]) vis[w+1][e] = 1 , q.push(w+1), q.push(e); \n        //原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。\n        if(map[w-1][e] == 0 && w != 0 && !vis[w-1][e] )    vis[w-1][e] = 1,q.push(w-1),q.push(e);\n        if(map[w][e+1] == 0 && e != n+1 && !vis[w][e+1] )    vis[w][e+1] = 1,q.push(w),q.push(e+1);\n        if(map[w][e-1] == 0 && e != 0 && !vis[w][e-1] )    vis[w][e-1] = 1,q.push(w),q.push(e-1);\n\n    }\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i<=n;i++){\n        for(int j =1 ;j<=n;j++){\n            cin>>map[i][j];\n            if(map[i][j] == 1) vis[i][j] = 1;\n        }\n    }\n\n    for(int i = 0;i<=n;i+=n){ //直接就判断两个对角上的点\n        for(int j = 1;j <= n; j++){\n            if(vis[i][j]) continue;     //说明触发到了边界点从这个点\n            bfs(i,j);\n        }\n    }\n\n    // for(int i = 1 ; i <= n ; i = i + n - 1 )        //\n    // {\n    //     for(int j = 1 ; j <= n ; j++)\n    //     {\n    //         if(vis[j][i])    continue;\n    //         bfs(j,i);            //十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点\n    //                             //但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。\n    //     }\n    // }\n\n     for(int i = 1 ; i <= n ; i++)                //\n    {\n        for(int j = 1 ; j <= n ; j++ )\n        {\n            if(!vis[i][j])    cout<<\"2\"<<\" \";        //如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； \n            else     cout<<map[i][j]<<\" \";;\n        }\n        cout<<endl;\n    } \n    return 0;\n}\n```\n\n[P1443](https://www.luogu.com.cn/problem/P1443)\n\n第一道自己写的题目, 但是写着写着从BFS写成了DFS, 虽然当然直接进行DFS显然超时了, 需要进行剪枝.先贴一下没有剪枝过的代码, 作为对比\n\n```c++\n#include<iostream>\n#include<queue>\nint a[401][401],b[401][401],n,m,x,y;\nint dx[]={2,1,-2,-1,2,1,-2,-1};\nint dy[]={1,2,1,2,-1,-2,-1,-2};\nbool c[401][401];\n// queue<int> q;\nusing namespace std;\n\nvoid DFS(int x,int y){\n    for(int i = 0 ;i<8;i++){\n        if(x+dx[i] < 1 || y+dy[i]< 1  || x+dx[i] > n || y+dy[i]>m || c[x][y]) continue;\n        else{\n            if(b[x+dx[i]][y+dy[i]] !=-1)\n                b[x+dx[i]][y+dy[i]] = min(b[x+dx[i]][y+dy[i]],b[x][y]+1);\n            else\n                b[x+dx[i]][y+dy[i]] = b[x][y]+1;\n            c[x][y] = 1;\n            DFS(x+dx[i],y+dy[i]);\n            c[x][y] = 0;\n        }\n    }\n    return;\n}\nint main(){\n    cin>>n>>m;\n    cin>>x>>y;\n    for(int i = 1 ;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            b[i][j] = -1;\n        }\n    }\n    b[x][y] = 0;\n    DFS(x,y);\n    for(int i = 1 ;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            cout<<b[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n想来想去没想到有什么剪枝的方法，因为本身就要判断从这个点进行会不会比另一个点进行更快，就相当于时每个点都进行判断了，要对每一条支路进行分析，剪不掉，意味着层数越深，搜索的次数就越多，因为会有很多的支路。所谓的剪枝，也许就是从层数的角度出发，但是这样就是BFS了，所以最终还是使用BFS进行求解。~~对于搜索来说，如何选择合适的搜索方式确实时需要慎重考虑的，回旋镖咋回来了~~\n\n```c++\n#include<iostream>\n#include<queue>\nint a[401][401],b[401][401],n,m,x,y;\nint dx[]={2,1,-2,-1,2,1,-2,-1};\nint dy[]={1,2,1,2,-1,-2,-1,-2};\nbool c[401][401];\t//像水扩散一样, 从一个点开始出发,将他的每层的连接进行判断,重叠部分就不用判断了,所以不用取消状态.\n\nusing namespace std;\nqueue<int> q;\nvoid BFS(int x,int y){\n    for(int i = 0 ;i<8;i++){\n        if(x+dx[i] < 1 || y+dy[i]< 1  || x+dx[i] > n || y+dy[i]>m || c[x][y]) continue;\n        else{\n            if(b[x+dx[i]][y+dy[i]] !=-1)\n                b[x+dx[i]][y+dy[i]] = min(b[x+dx[i]][y+dy[i]],b[x][y]+1);\n            else\n                b[x+dx[i]][y+dy[i]] = b[x][y]+1;\n\n            q.push(x+dx[i]);\n            q.push(y+dy[i]);\n        }\n    }\n    c[x][y] = 1;\t//之前不小心放在循环的里面了,还是要注意什么时候要对状态使用完成进行标记,放里面就有DFS的味道了\n    if(q.empty())\n        return;\n    int n_x = q.front();\n    q.pop();\n    int n_y= q.front();\n    q.pop();\n    BFS(n_x,n_y);\n    return;\n}\nint main(){\n    cin>>n>>m;\n    cin>>x>>y;\n    for(int i = 1 ;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            b[i][j] = -1;\n        }\n    }\n    b[x][y] = 0;\n    BFS(x,y);\n    for(int i = 1 ;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            cout<<b[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n## 30、串联所有单词的字串\n\n\n\n滑动窗口优化，我尝试的第一道困难题，毕竟不是算法竞赛，没有想象中难么难。当还是有一定挑战的\n\n```python\n#我的解法只使用了简单的枚举，其实并不涉及滑动窗口，在重复度高的情况中容易多次统计，造成计算重复\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m,n,ls = len(words),len(words[0]),len(s)\n        for i in range(ls):\n            if(i + m*n >ls):\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i+j*n : i+(j+1)*n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -=1\n                if differ[word] == 0:\n                    del differ[word]\n            if len(differ) == 0:\n                res.append(i)\n        return res            \n\n\n\n\n\n\n#使用滑动窗口，在最外层的循环中，循环的长度为一个单词的长度，如果是单词整体的减少，通过滑动窗口已经能够进行判断\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m, n, ls = len(words), len(words[0]), len(s)\n        for i in range(n):\n            if i + m * n > ls:\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i + j * n: i + (j + 1) * n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -= 1\n                if differ[word] == 0:\n                    del differ[word]\n                    \n                    #下一段是使用滑动窗口的优化\n                    #步长为n代表窗口的整体滑动\n            for start in range(i, ls - m * n + 1, n):\n                if start != i:\n                    #word为窗口滑动进入的新词\n                    word = s[start + (m - 1) * n: start + m * n]\n                    differ[word] += 1\n                    #可能上一个词组不是,刚好欠这个词\n                    if differ[word] == 0:\n                        del differ[word]\n                    #上一个\n                    word = s[start - n: start]\n                    differ[word] -= 1\n                    if differ[word] == 0:\n                        del differ[word]\n                if len(differ) == 0:\n                    res.append(start)\n        return res\n\n```\n\n ## 135、分发糖果\n\n第二道困难题，关于数组的，确实有难度，在于一点巧劲，常规解法的话其实需要对题目的数学模型有一定的理解\n\n```python\nint candy(int* ratings, int ratingsSize) {\n    int left[ratingsSize];\n    for (int i = 0; i < ratingsSize; i++) {\n        if (i > 0 && ratings[i] > ratings[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        } else {\n            left[i] = 1;\n        }\n    }\n    int right = 0, ret = 0;\n    for (int i = ratingsSize - 1; i >= 0; i--) {\n        if (i < ratingsSize - 1 && ratings[i] > ratings[i + 1]) {\n            right++;\n        } else {\n            right = 1;\n        }\n        ret += fmax(left[i], right);\n    }\n    return ret;\n}\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/candy/solutions/533150/fen-fa-tang-guo-by-leetcode-solution-f01p/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        ret = 1\n        inc, dec, pre = 1, 0, 1\n\n        for i in range(1, n):\n            if ratings[i] >= ratings[i - 1]:\n                dec = 0\n                pre = (1 if ratings[i] == ratings[i - 1] else pre + 1)\n                ret += pre\n                inc = pre\n            else:\n                dec += 1\n                if dec == inc:\n                    dec += 1\n                ret += dec\n                pre = 1\n        \n        return ret\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/candy/solutions/533150/fen-fa-tang-guo-by-leetcode-solution-f01p/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n## 42、接雨水\n\n第三道困难题，本来还想通过自己通过的，但是还是被最极端的用例给爆内存了\n\n```python\n\n#自己的解法， 通过每一层进行扫描，但是前提是根据给出的数据创建一个相关的矩阵判断边界，有点像是模拟的做法\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        \n        #创建一个矩阵记录边界\n        n = len(height)\n        max_height = max(height)\n        bow = [[0 for _ in range(n)] for _ in range(max_height)]\n        for i in range(n):\n            for j in range(height[i]):\n                bow[j][i] = 1\n        \n        #只有判断到一行中两个一之间的区域的时候，直接将其充满，毕竟没说石柱会有空隙\n        rain = 0\n        start=end=0\n        for i in range(max_height):\n            start=end=0\n            for j in range(n):\n                if bow[i][j] == 1 :\n                     rain += end - start\n                     start = end = j\n                else:\n                    if bow[i][start] ==1:\n                        end += 1\n        return rain\n    \n    \n#总体来说，在构建矩阵的时候，内存消耗过大，被极端用例给爆了\n```\n\n## 202.快乐数\n\n本身题目并不难, 思路也比较好像, 但是双指针的思路我一时间还是没有想到的, 同时关于他的时间优化我觉得还是有必要记录一下的\n\n```python\n#第一遍的双指针\nclass Solution:\n    def doit(self,n: int):\n        nums=[]\n        res = 0\n        while(n!=0):\n            nums.append(n%10)\n            n //= 10\n        for i in range(len(nums)):\n            res += nums[i]**2\n        return res\n    def isHappy(self, n: int) -> bool:\n        fast = n\n        for i in range(2):\n            if fast == 1:\n                return True\n            fast = self.doit(fast)\n        slow = n\n        while(fast != slow):\n            slow = self.doit(slow)\n            for i in range(2):\n                fast = self.doit(fast)\n                if fast == 1:\n                    return True\n        return False\n# 将每次快指针指向的数组\n```\n\n## 6、z字型变换\n\n还是比较简单的，就是纯粹的模拟，但是有一个需要注意的地方，会使题目更简单. 虽然在字体形式上在上升行中会出现很多的空, 但是对于题目要求的输出来说并没有需要按照z字的形式输出, 所以直接忽略空白即可, 所以只需要考虑每个字符应该处在哪一行,同时按照顺序执行就行.\n\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows < 2 : return s #小于两行的化和直接输出没有区别\n        res = [\"\" for _ in range(numRows)]\n        i, flag = 0,-1\n        for c in s :\n            res[i]+= c\n            if i == 0 or i == numRows-1:\n                flag = -flag\n            i+=flag\n        return \"\".join(res)            \n                \n```\n\n## [1715、分割回文字符IV](https://leetcode.cn/problems/palindrome-partitioning-iv/description/)\n\n困难题，确实有点出乎意料. 对于一般的字符来说, 还没用到过动态规划. 要考虑到对于一个字符串来说, 如何分割确保分割出来的子字符串为回文,并没有确定的公式, 所以就说明必须要进行一些枚举运算. 但是, 在枚举的过程中, 会存在很多重复的判断是否为回文的字符串, 对于一个变长的子串, 其子串如果在前面已经判断过是否为回文, 那么在对其重复计算明显浪费了算力.\n\n官方题解使用了一个动态规划数组, 在于任何子串, 其掐去两端的子串如果为回文, 那么, 掐去的两端字符如果相等, 那么其就为回文. 这样每次回文判断其实只需要两次计算.\n\n```java\nclass Solution {\n    public boolean checkPartitioning(String s) {\n        int n = s.length();\n        boolean[][] isPalindrome = new boolean[n][n];\n\n        //确定每次判断字符的长度，由于只是对判断原字符中的子字符是否是回文，所以只需要从小到大\n        //又因为设计上的动态规划\n        //本部分先将所有的子串是否为回文进行记录，虽然其中也有许多的冗余计算， 但是还是相对来说较少\n        for (int length = 1; length < n; length++) {\n            for (int start = 0; start <= n -length; start++){\n                //end是可以取到的\n                int end = start + length-1;\n                if (length == 1) {\n                    isPalindrome[start][end] = true;\n                }\n                else if(length == 2) {\n                    isPalindrome[start][end] = (s.charAt(start) == s.charAt(end));\n                }\n                else{\n                    //因为length从小到大，所以判断必定是从3->2,由4->3, 而其长度为这些的子串都会在前面的计算中判断过\n                    isPalindrome[start][end] = ((s.charAt(start)==s.charAt(end)) && isPalindrome[start+1][end-1]);\n                }\n            }\n        }\n\n        //直接确定中间字符串的位置即可\n        //1、0->start-1,2、start->end, 3、end+1->length\n        for(int start = 1;start<n-1;start ++){\n            if(!isPalindrome[0][start-1]) {\n                continue;\n            }\n            for(int end=start; end <n-1;end++){\n                if(isPalindrome[start][end] && isPalindrome[end+1][n-1]){\n                    return true;\n                }\n\n            }\n        }\n        return false;\n    }\n}\n```\n\n## [汇总区间](https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150)\n\n也不知道怎么之前就没有写出来, 非常普通的一个模拟. 但是他的判断逻辑写的有点有趣\n\n```go\nfunc summaryRanges(nums []int) []string {\n    var ans []string\n    for i, n := 0, len(nums); i<n; {\n        left := i\n        \n        //类似一个if判断语句， 但是这个写法很抽象\n        for i++; i<n && nums[i-1] + 1 == nums[i];i++ {\n        }\n        s := strconv.Itoa(nums[left])\n        if left < i-1 {\n            s += \"->\" + strconv.Itoa(nums[i-1])\n        }\n        ans = append(ans, s)\n    }\n    return ans\n}\n```\n\n## 3306.元音辅音字母计数 II\n\n当读完题目就想到了滑动窗口发,  不知道算不算种进步, 虽然我脑海中的滑动窗口并没有实现. 感觉还是欠点, 或者说感觉我的逻辑太麻烦不够简洁. \n\n```go\nfunc countOfSubstrings(word string, k int) int64 {\n    word_len = len(word)\n    var ans int64\n    for win_len := k+5; win_len <= word_len ;win_len++ {\n        occur := map[byte]int{'a':0,'e':0, 'i':0, 'o':0,'u':0}\n        other := 0\n        for i := 0 ;i <=win_len; i++ {\n            _, ok := map[word[i]]\n            if ok {\n                map[word[i]]++;\n            }else{\n                other++;\n            }\n        }\n    }\n}\n//....不行了, 太麻烦了, 确实不是一个好的答案, 不是很好模拟, 判断太多了.到后面就容易造成...\n```\n\n题解给出的答案是, 通过将统计恰好改为至少. 感觉也是一种题型.\n\n如果将题目先改成`至少出现辅音k次`, 那么判断逻辑就会减少, 只要确保形成的子字符串中, 至少保存了k个即以上就行. 而恰好则可以转化成count(k) - count(k+1)\n\n```go\nfunc countOfSubstrings(word string, k int) int64 {\n\tvowels := map[byte]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true} //用于快速判断是否为元音\n\tcount := func(m int) int64 {\n\t\tn := len(word)\n\t\tvar res int64 = 0\n\t\tconsonants := 0\n\t\toccur := make(map[byte]int)\n\t\tfor i, j := 0, 0; i < n; i++ {\n            //找到以当前i开头的子串能满足的最短子串\n\t\t\tfor j < n && (consonants < m || len(occur) < 5) {\n\t\t\t\tif vowels[word[j]] {\n\t\t\t\t\toccur[word[j]]++\n\t\t\t\t} else {\n\t\t\t\t\tconsonants++\n\t\t\t\t}\n\t\t\t\tj++\n\t\t\t}\n\t\t\tif consonants >= m && len(occur) == 5 {\n                //对于当前子串来说已经满足了条件, 那么,后面继续添加长度就必定满足条件, 不用判断\n\t\t\t\tres += int64(n - j + 1)\n\t\t\t}\n            //接下来当前子串开头i要向后移位, 需要判断是否会对当前的满足条件造成影响\n\t\t\tif vowels[word[i]] {\n\t\t\t\toccur[word[i]]--\n\t\t\t\tif occur[word[i]] == 0 {\n\t\t\t\t\tdelete(occur, word[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsonants--\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\treturn count(k) - count(k+1)\n}\n```\n\n## [1920.基于排列构建数组](https://leetcode.cn/problems/build-array-from-permutation/description/?envType=daily-question&envId=2025-05-06)\n\n从题目来说, 不考虑优化就是一件非常简单的任务.解法二的思路比较有意思. 这对数据来说, 所有的数据都不会超过1000的大小. 对于如何原地交换的问题在于, 直接交换, 可能只有一个数据满足要求, 会导致另一个数据失效, 同时也会打乱原来排序号的数据. 关键在于如何能够在一个地方同时存储两个数据, 一个代表的是原数据, 另一个代表的是更改后的数据. \n通过观察数据最大到999, 所以可以将更改数据整体存储在1000位以上, 在通过第二遍历就能够将原数据去除, 只保留1000位以上的数据\n\n```go\nfunc buildArray(nums []int) []int {\n    for i,_ :=  range nums {\n        nums[i] += 1000*(nums[nums[i]]%1000);\n    }\n    for i,_ := range nums{\n        nums[i] /= 1000\n    }\n    return nums\n}\n```\n\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        int n = nums.length;\n        for(int i = 0;i<n;i++){\n            nums[i] += 1000*(nums[nums[i]]%1000);\n        }\n        for(int i = 0;i<n;i++){\n            nums[i] /= 1000;\n        }\n        return nums;\n    }\n}\n```\n\n但是会降低运行速度, 毕竟变成O(n^2)\n","slug":"Leetcode&洛谷刷题记录与思考","published":1,"layout":"post","photos":[],"_id":"cmafjaxaf0003vpx5c1swfgd2","content":"<h1 id=\"Leetcode-洛谷刷题记录与思考\"><a href=\"#Leetcode-洛谷刷题记录与思考\" class=\"headerlink\" title=\"Leetcode&amp;&amp;洛谷刷题记录与思考\"></a>Leetcode&amp;&amp;洛谷刷题记录与思考</h1><h2 id=\"p-7517\"><a href=\"#p-7517\" class=\"headerlink\" title=\"p 7517\"></a>p 7517</h2><p>题目链接：</p>\n<p><a href=\"https://www.luogu.com.cn/problem/solution/P7517\"></a></p>\n<p>对于第一篇题解的理解。</p>\n<p>···</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> il inline</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">5e5</span><span class=\"number\">+10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//没有多大用的快读</span></span><br><span class=\"line\">    <span class=\"type\">int</span> f=<span class=\"number\">1</span>,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&lt;<span class=\"string\">&#x27;0&#x27;</span>||x&gt;<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==<span class=\"string\">&#x27;-&#x27;</span>) f=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;x&lt;=<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">        s=s*<span class=\"number\">10</span>+x-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f*s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> a[N],b[N];<span class=\"comment\">//b即为桶</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        a[i]=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j*j&lt;=a[i];j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i]%j!=<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//关键判断</span></span><br><span class=\"line\">            <span class=\"type\">int</span> ans1=j,ans2=a[i]/j;</span><br><span class=\"line\">            b[ans1]++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans1!=ans2)<span class=\"comment\">//特判</span></span><br><span class=\"line\">                b[ans2]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;<span class=\"comment\">//爆int警告</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        ans+=(ll)b[a[i]]<span class=\"number\">-1</span>;<span class=\"comment\">//累加，减一是减去自己的贡献</span></span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>···</p>\n<p>其中有他自己创建的读取函数，目前我并不知道这样的读取函数对于直接使用系统自带函数能够提速多少，所以目前不予讨论. </p>\n<p>这篇题解的思路在于直接将每个输入的数的因数直接统计出来,在b桶中计数, a中存储的是用户输入的结果. 最后再将用户输入的结果中的数所对应的桶中的结果倒出来, 同时减去来自自己出现时的那一次<code> 如果是i=j可以出现的情况应该就不用了</code>. 这样每次用户输入的数需要判断<br>$$<br>O(\\sqrt{a_i})<br>$$<br>第二种方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> il inline</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">5e5</span><span class=\"number\">+10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> f=<span class=\"number\">1</span>,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&lt;<span class=\"string\">&#x27;0&#x27;</span>||x&gt;<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==<span class=\"string\">&#x27;-&#x27;</span>) f=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;x&lt;=<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">        s=s*<span class=\"number\">10</span>+x-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f*s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> a[N],b[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    \tb[<span class=\"built_in\">read</span>()]++;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">2</span>;i*j&lt;=N;j++)</span><br><span class=\"line\">    \t\tans+=b[i]*b[i*j];</span><br><span class=\"line\">    \tans+=b[i]*(b[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次通过的是将尽可能的用户输入的数的倍数全部都进行计数. 如果用户输入的数的倍数曾经在用户输入的数据中, 就相当于可以组成一个数对. 不存在的话, 自然相应的数的次数为0, 最终累成和累加的结果就是0. 但是这样的操作,不经让人觉得速度并没有快多少, 应为都要将所有的数据判断一遍, 其中会有很多的含零的数据, 同时这对内存的消耗也很大.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于这道题, 看基本上的解题思路都是直接通过设置桶, 然后直接统计倍数. 这道题的数据都是<code>a_i&lt;=5e5</code> 所以直接将最大定位.</p>\n<h3 id=\"自己根据学习写的代码\"><a href=\"#自己根据学习写的代码\" class=\"headerlink\" title=\"自己根据学习写的代码\"></a>自己根据学习写的代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">long</span> <span class=\"type\">long</span> Maxn=<span class=\"number\">5e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> a[Maxn];</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(a,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(a));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> temp;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>,&amp;temp);</span><br><span class=\"line\">        a[temp]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> i=<span class=\"number\">1</span>;i&lt;Maxn;i++)&#123;</span><br><span class=\"line\">        ans+=a[i]*(a[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> j=<span class=\"number\">2</span>*i;j&lt;Maxn;j+=i)&#123;</span><br><span class=\"line\">            ans+=a[i]*a[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>,ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"p-2701\"><a href=\"#p-2701\" class=\"headerlink\" title=\"p 2701\"></a>p 2701</h2><p><a href=\"https://www.luogu.com.cn/problem/P2701\">洛谷</a></p>\n<p>根据提供的题解是通过动态规划进行解答. </p>\n<p>对于动态规划, 首先, 能够进行动态规划的题目首先可以满足暴力枚举, 但是由于数据量较大, 时间消耗过多. 其次, 可以根据节点, 会出现重复搜索或枚举,  将这部分的重复枚举进行删除或者记录, 达到省去的操作, 就可以称作是动态规划.  &#x3D;&#x3D;仅代表个人理解&#x3D;&#x3D;  .</p>\n<p>对于这道题, 选取每一个点作为起点向别处延伸, 很明显可以通过暴力枚举进行解答, 同时, 通过不同的点进行容易想到, 会有很多重复, 所以就可以通过动态规划进行解题.</p>\n<p>由于面积的延伸是正方形,倘若任意一点向想对边进行延伸,即 都需要考虑他周围的点,  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">min_3</span><span class=\"params\">(<span class=\"type\">int</span> ,<span class=\"type\">int</span> ,<span class=\"type\">int</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,t;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;n,&amp;t);</span><br><span class=\"line\">    <span class=\"type\">int</span> a[n][n],b[n][n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">            a[i][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;t;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class=\"line\">        a[x<span class=\"number\">-1</span>][y<span class=\"number\">-1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">            b[i][j]=a[i][j];</span><br><span class=\"line\">    <span class=\"comment\">//到这为止已经将所有的数据进行了初始化。</span></span><br><span class=\"line\">    <span class=\"comment\">//同时，此时的为0是第一行开始，0表示此处有树</span></span><br><span class=\"line\">    <span class=\"comment\">//当以点为右下角,此处同时可以代表就是此处可以达到的最大面积</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将每一个点代表的正方形可视化，或者是略加思考，可以的到每个点与周围点的关系</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i][j])</span><br><span class=\"line\">                b[i][j]+=min_3(b[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>],b[i][j<span class=\"number\">-1</span>],b[i<span class=\"number\">-1</span>][j]);    <span class=\"comment\">//不要忘记，只有当前的区域是没有树的才可能作为一个区域的右下角。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> max=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b[i][j]&gt;max)</span><br><span class=\"line\">                max=b[i][j];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,max);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">min_3</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a&lt;b)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a&lt;c)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&lt;c)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>还是要考虑到的是，如何实现动态规划问题。关键在于如何找出者这之间的关系。</p>\n<h2 id=\"p-2678\"><a href=\"#p-2678\" class=\"headerlink\" title=\"p 2678\"></a>p 2678</h2><p><a href=\"https://www.luogu.com.cn/problem/P2678\">跳石头</a></p>\n<p>通过思考题目可以知道，如果是通过暴力的方法进行解答，需要每次都找到最小的那段距离，然后再将最小的那段距离加到其相邻的两端距离中最小的那一段距离中去，然后再多次重复此方法，知道达到搬移石头的次数用尽。</p>\n<p>很明显，这样的算法思路十分简单，但是遇到数据量大的题目时就略显费劲，先寻找最小的值为N，在判断最小值附近的值，这样的操作要做N遍，所以这是一个 O( n^2^ )的算法。</p>\n<p>对于题解中大佬给出的二分答案法，我一开始并没有想明白对于一个无法进行排序的距离数组，如何使用需要有序为前提的二分查找. 但是通过阅读代码发现, 其中, 解题人的思路并非是将搬移次数作为了循环条件, 而是将搬移次数M当做了一个判断二分答案是否有效的条件. 其思路是, &#x3D;&#x3D;如果存在一个最大的最短距离为X,那么很明显, 其他的任何一段距离必定大于等于这段最短距离&#x3D;&#x3D; . </p>\n<p>所以, 更具解题人的思路, 只需要查找在最长距离中的能够满足搬运次数少于或等于M次的x的最大值就行了<del>当然其实应该不会存在有小于的情况, 不然的话再搬一次不就有新的最大最小距离了吗</del> ,而这个答案明显一定在这之中,当然也可能会包括两端. 对于每个差找到的值, 判断如果需要达到这个查找值,对于当前数组所需要搬运的次数, 如果大于了M次的话, 就说明是太大, 将右边左移, 如果是小于M次就是将左边界右移,应为说明还可以有更大的距离.(其实,这样的算法,同样也会造成很多的数据其实不用算的,毕竟有些数据, 不可能是当前的这个数组能够组成的数据,但是, 在对于巨量的数据来说, 这多出来的计算量, 可能还没有暴力一个节点循环一遍计算量来得多 :cry: )</p>\n<h2 id=\"14、最长公共前缀\"><a href=\"#14、最长公共前缀\" class=\"headerlink\" title=\"14、最长公共前缀\"></a>14、最长公共前缀</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">SearchForMinString</span><span class=\"params\">(<span class=\"type\">char</span>** strs, <span class=\"type\">int</span> strsSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> minsize = <span class=\"built_in\">strlen</span>(strs[<span class=\"number\">0</span>]);  <span class=\"comment\">//初始化最小的长度为第一个字符串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; strsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strlen</span>(strs[i]) &lt; minsize)  <span class=\"comment\">//如果有字符串的长度小于就取最小的</span></span><br><span class=\"line\">            minsize = <span class=\"built_in\">strlen</span>(strs[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minsize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">longestCommonPrefix</span><span class=\"params\">(<span class=\"type\">char</span>** strs, <span class=\"type\">int</span> strsSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> minsize = SearchForMinString(strs, strsSize);   <span class=\"comment\">//得到最小的字符串长度</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* answer = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>) * minsize+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(answer,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>) * minsize+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> answersize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; minsize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; strsSize; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (strs[j][i] != strs[<span class=\"number\">0</span>][i]) <span class=\"comment\">//有不一样的就直接返回答案</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> answer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        answer[answersize] = strs[<span class=\"number\">0</span>][i]; </span><br><span class=\"line\">        answersize++;</span><br><span class=\"line\">        <span class=\"comment\">//说明所有的字符串该为位字符一样，将其赋值到结果的字符串中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> answer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于其中的字符串的malloc应用, 定要记住字符串结尾有一个<code>\\0</code>, 但同时,<code>strlen</code>函数不会将这个计入字符长度内, 所以直接用这样的到的字符长度去创建一个字符串会导致最后一个<code>\\0</code>消失, 导致构不成一个字符串. </p>\n<p>与此同时, 对于malloc其分配的地址空间并不会直接给你初始化好, 所以建议搭配memset一起使用, 同时容易记住申请空间的大小.</p>\n<h2 id=\"11、盛水最多的容器\"><a href=\"#11、盛水最多的容器\" class=\"headerlink\" title=\"11、盛水最多的容器\"></a>11、盛水最多的容器</h2><p>这道题，其实就是现实中的短板效应。任意选择的两个板能够盛水容量取决于最短的板. </p>\n<p>对于这道题直接进行暴力求解非常简单. 但是对于一些测试用例会有超时的可能.</p>\n<p>对于得到的木板数组处于无序状态,  对于任何的一个组合, 两端的木板选择只有两种. 假设从两端开始选取, 如果将两端任意一段的木板移动, 如果移动长版, 那么, 不论移动后的到的木板长度比原来大, 还是比原来小, 由于短板效应不会变, 但是底边必定变小, 所以选择的是的到的容积必定变小. 所以每次移动, 每次移动短板, 才能够是短板的长度进行变化. 这样的行为,可以一减小一定计算量.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">maxArea</span><span class=\"params\">(<span class=\"type\">int</span>* height, <span class=\"type\">int</span> heightSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> head,tail;</span><br><span class=\"line\">    head=<span class=\"number\">0</span>;tail=heightSize<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> maxCapacity=(height[head]&lt;height[tail]?height[head]:height[tail])*(tail-head);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head!=tail)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(height[head]&gt;height[tail])</span><br><span class=\"line\">            tail--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            head++;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        temp=(height[head]&lt;height[tail]?height[head]:height[tail])*(tail-head);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp&gt;maxCapacity)</span><br><span class=\"line\">            maxCapacity=temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxCapacity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"209、长度最小的子数组\"><a href=\"#209、长度最小的子数组\" class=\"headerlink\" title=\"209、长度最小的子数组\"></a>209、长度最小的子数组</h2><h3 id=\"解法一、滑动窗口解法\"><a href=\"#解法一、滑动窗口解法\" class=\"headerlink\" title=\"解法一、滑动窗口解法\"></a>解法一、滑动窗口解法</h3><p>对于滑动窗口来说, 本题要求的子数组连续, 所以可以想象成一个窗口进行滑动. 如果该窗口是不变的话, 那么就需要每次对窗口的大小进行调整, 将窗口的大小从1~numsSize进行尝试, 显然,这样的尝试只比O(n2)暴力搜索快一点. 无法在时间限度内完成.</p>\n<p>直接从小到大的对窗口进行增大, 存在的问题就是, 会有很多的较小的窗口其实没有计算的必要. 如果使用的是动态大小的窗口的话,可以对此进行一定的减少计算.</p>\n<p>先逐步的扩大窗口,直到, 窗口中的数能够直接达到target, 然后再考虑是否对窗口中的数进行出队操作.(对于数组前面的数来说, 必须要是窗口达到当前的大小才能够达到target所以, 应去除窗口前面的数, 看看后面的数有没有可能.) 对窗口中的数进行出队, 当窗口内数的和,小于target的时候, 这时, 就当前的子数组的子数组长度+1的长度, 就是当前子数组能到达到的最小长度, 然后再向后进行查找.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 纯粹的窗口会导致许多小窗口的无谓计算, 尤其是当target和numsSize较大的时候</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, <span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> windowlenth=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(windowlenth&lt;=numsSize)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=numsSize-windowlenth;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i;j-i&lt;windowlenth;j++)&#123;</span><br><span class=\"line\">                sum+=nums[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum&gt;=target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> windowlenth;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        windowlenth++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过动态窗口的大小进行搜索,先找到一个能够达到target的子数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, <span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">queue</span>[numsSize],head,tail;</span><br><span class=\"line\">    <span class=\"type\">int</span> queuesum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans=numsSize+<span class=\"number\">1</span>;</span><br><span class=\"line\">    head=tail=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//进行入队操作同时统计队内和</span></span><br><span class=\"line\">        <span class=\"type\">int</span> temp_ans;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>[tail]=nums[i];</span><br><span class=\"line\">        tail++;</span><br><span class=\"line\">        queuesum+=nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//达到target的时候就从头出队</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(queuesum&gt;=target)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//将能够缩小的全部出队</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(queuesum&gt;=target)&#123;</span><br><span class=\"line\">                queuesum-=<span class=\"built_in\">queue</span>[head];</span><br><span class=\"line\">                head++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            temp_ans=tail-head+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans&gt;temp_ans)</span><br><span class=\"line\">                ans=temp_ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ans == numsSize+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"p1002\"><a href=\"#p1002\" class=\"headerlink\" title=\"p1002\"></a>p1002</h2><p><a href=\"https://www.luogu.com.cn/problem/P1002\">过河卒</a></p>\n<p>其实就是经典动态规划，需要想清楚，几个状态，通过状态的转移找到公式，然后根据公式进行推理即可。</p>\n<h2 id=\"p1004\"><a href=\"#p1004\" class=\"headerlink\" title=\"p1004\"></a>p1004</h2><p><a href=\"https://www.luogu.com.cn/problem/P1004\">方格取数</a></p>\n<p>通过我的思考，也是动态规划根据题目的意思，但是，这次需要遍历两次，需要在第一次的时候，将取到的数置零。让后再进行第二次遍历，进行同样的操作。但是需要进行。但是对于一个直接的动态规划而言，并没有对路劲进行记忆，所以，如何对于一个数组进行置零是很大的问题，对于我的思维来说，我会考虑在加上一个大小合适的记忆数组，对于每一次的路径进行记忆，但是，我认为这十分地耗费空间，而且代码也并不优雅。</p>\n<p>通过题解的思考，这道题的解法是一个四维的动态规划，由于平时遇到的数据二维居多，对于思维的数组，一时间难以理解。最主要的在于，第一遍与第二遍是否应该分开思考的问题。</p>\n<p>通过前面对于二维动态规划的思考，如果是按照模拟的方法，对于每次数组的遍历都采用分离的思想，则每次都是贪心算法，最终获得的是局部最优解，难以证明就是整体最优解。所以在思考四维的动态规划时，也不能将两次遍历分开思考。</p>\n<p>对于相关的四维动态规划数组，其存储的应该就是，一次和第二次走到相关x，y位置是取到的最大值。两次走法应该是在相同时空观下的。但是，由于第一次走后会取走数，所以最终，在走到相同位置时，要减去相关位置的数。一定要将动态规划数组在某某位置的值和相应数组在某某位置的值分开思考。</p>\n<h2 id=\"1010\"><a href=\"#1010\" class=\"headerlink\" title=\"1010\"></a>1010</h2><p><a href=\"https://www.luogu.com.cn/problem/P1010\">幂次方</a></p>\n<p>通过提示，想到对于一个数进行问题的分解，每次只做一层，用递归的方法。</p>\n<p>很容易想到需要用到二进制进行求解。</p>\n<p>通过阅读大佬的题解能得到一个很新的思路</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fff</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">14</span>;i&gt;=<span class=\"number\">0</span>;i--) <span class=\"comment\">//两万的数据最多是2（14）</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,i)&lt;=x)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//pow（n，m）在cmath库中，返回n^m；枚举出第一个幂次方</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==<span class=\"number\">1</span>) cout&lt;&lt;<span class=\"string\">&quot;2&quot;</span>; <span class=\"comment\">//2（1）不用再往后分解了且2^1输出为2，单独出来</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) cout&lt;&lt;<span class=\"string\">&quot;2(0)&quot;</span>; <span class=\"comment\">//2（0）也不用再往后分解了，单独出来</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123; <span class=\"comment\">//若i&gt;1则继续分解指数i</span></span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;2(&quot;</span>;</span><br><span class=\"line\">            <span class=\"built_in\">fff</span>(i);</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            x-=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,i); <span class=\"comment\">//继续循环分解余下的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(x!=<span class=\"number\">0</span>) cout&lt;&lt;<span class=\"string\">&quot;+&quot;</span>;</span><br><span class=\"line\">            <span class=\"comment\">//加号处理的最简单方法：若此x还没分解完，则后面还有项，所以输出一个+号</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    <span class=\"built_in\">fff</span>(a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DFS的算法学习\"><a href=\"#DFS的算法学习\" class=\"headerlink\" title=\"DFS的算法学习\"></a>DFS的算法学习</h2><p><a href=\"https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/\">LCR 175. 计算二叉树的深度 - 力扣（LeetCode）</a></p>\n<p>非常简单的一道DFS的算法题目，计算二叉树的深度， 其实计算什么的深度都是一样的。这道题目相当于已经将应用的场景抽象化了，所以难度不高，在正式的应用中，真正的难度在于如何能够想到这个算法。</p>\n<p>DFS算法的根本是枚举，将所有可能的情况都按照一定的顺序进行了枚举。关键在于回溯的机制。当一条路走到底后，就进行回溯，将之前还存在有路没走的节点再次进行。</p>\n<p>话不多说上源码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class=\"line\"><span class=\"comment\"> * right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">calculateDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ldepth = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> rdepth = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ldepth += <span class=\"built_in\">calculateDepth</span>(root-&gt;left);</span><br><span class=\"line\">        rdepth += <span class=\"built_in\">calculateDepth</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ldepth &gt; rdepth ? ldepth : rdepth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.cn/problems/invert-binary-tree/description/\">226. 翻转二叉树 - 力扣（LeetCode）</a></p>\n<p>简单的DFS算法可以进行实现，先找到最小的树，然后将其反转，最后在将其根节点进行反转。但是唯一的问题在于，原来又有一个疑问是有可能左右指树可能有空，但是想想，其实有空也应该进行反转，所以在写的时候疑惑解消了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"built_in\">invertTree</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">invertTree</span>(root-&gt;right);</span><br><span class=\"line\">        TreeNode* temp;</span><br><span class=\"line\">        temp = root-&gt;left;</span><br><span class=\"line\">        root-&gt;left = root-&gt;right;</span><br><span class=\"line\">        root-&gt;right = temp;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.luogu.com.cn/problem/P1219\">八皇后</a></p>\n<p>同样需要用到DFS算法，但是这题对我来说的难点在于，如何寻找状态和判断对角线已经被占用</p>\n<p>通过题解，可得将每次下完一个棋，棋盘剩余的资源为一个状态，向下进行传递。同时，对于对角线来说，存在一定的规律，从右到左的行下标与列下标的和在同一对角线相等且唯一，从左到右，行下标与列下标的差在同一对角线值相等且唯一。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"type\">int</span> size;  <span class=\"comment\">//表格的大小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> rows[<span class=\"number\">14</span>],colunms[<span class=\"number\">14</span>],r_l[<span class=\"number\">27</span>],l_r[<span class=\"number\">27</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> solutions;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">GetSoutions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> solutions;</span><br><span class=\"line\">        &#125;   <span class=\"comment\">//用于输出解的个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> n;</span><br><span class=\"line\">            std::cin&gt;&gt;n;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;size = n;</span><br><span class=\"line\">            <span class=\"built_in\">queen</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">GetSoutions</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">myprint</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(solutions&lt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=size ; i++)</span><br><span class=\"line\">                    std::<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,rows[i]);</span><br><span class=\"line\">                <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;solutions++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询合适的位置放置一枚queen，如果没有判断输出，有则标记状态，在进行下次状态转移</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">queen</span><span class=\"params\">(<span class=\"type\">int</span> row)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//row大于行数size，说明到达边界，要么是全部放置完成</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(row&gt;size)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">myprint</span>();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//保证字典序从1开始</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> col = <span class=\"number\">1</span> ;col&lt;=size;col++)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//说明相关列没有被占领，对角线也没有</span></span><br><span class=\"line\">                    <span class=\"comment\">//在此处我曾将row与col差的值进行互换,输出的结果就是错误的,目前还没具体明白是为什么</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>((!colunms[col]) &amp;&amp; (!r_l[col+row]) &amp;&amp; (!l_r[row-col+size]))&#123;</span><br><span class=\"line\">                        rows[row] = col;    <span class=\"comment\">//直接记录相关的列，方便下次进行输出</span></span><br><span class=\"line\">                        colunms[col] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        r_l[col+row] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        l_r[row-col+size] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"built_in\">queen</span>(row<span class=\"number\">+1</span>);   <span class=\"comment\">//状态转移，按照字典序，需从行号递增</span></span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"comment\">//从上个函数跳出，说明已经完成了当前的这个状态的记录的所有结果需要重新进行上个状态的记录，</span></span><br><span class=\"line\">                        <span class=\"comment\">//故清除当前状态的记录</span></span><br><span class=\"line\">                        colunms[col] = r_l[col+row] = l_r[row-col+size] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Solution ans = <span class=\"built_in\">Solution</span>();</span><br><span class=\"line\">    ans.<span class=\"built_in\">Solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.luogu.com.cn/problem/P5194\">P5194</a></p>\n<p>通过阅读题目，容易直接写出深度优先的算法，同时还可以想到类似背包一类。但是，分析数据的大小为1000，至少要做1000^2次运算, 除了AC的答案,其他全部超时了. </p>\n<p>所以设计到深度优先搜索的算法优化, 就是剪枝的理论.</p>\n<p>目前来说, 对于剪枝的理解就是, 通过对题目数据进行分析, 方向对于一些搜索的路径不需要再次搜索. 如题中, 但当前的砝码超出了承受范围C, 则之后的砝码都会超出, 可以直接返回, 这点只需要在判断时加上return语句即可, 但同时, 当前砝码必定大于等于前面两个砝码的质量之和, 但加上当前的砝码超出时, 直接返回后, 由于上一个状态并不能知道当前状态的下一个状态已经超出, 还会再次跳过下一个状态, 直接进行下下个, 这个对于当前的数据集来说就没有必要了, 下一个砝码超出, 则下下个砝码必定超出.</p>\n<p>同时存在关系</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weight[i]+weight[i<span class=\"number\">+3</span>]&lt;C;</span><br><span class=\"line\">weight[i]+weight[i<span class=\"number\">+1</span>]+weight[i<span class=\"number\">+2</span>]&lt;C;</span><br><span class=\"line\"><span class=\"comment\">//所以在i状态下,可以直接跳到i+3的状态,避免了对i+1,i+2的计算,所以,也许直接从大到小搜索才是正解?</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum[<span class=\"number\">1005</span>],a[<span class=\"number\">1005</span>],ans,n,c;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> cur,<span class=\"type\">long</span> <span class=\"type\">long</span> x)</span></span>&#123;  <span class=\"comment\">//cur是为了标记当前的位置，x是记录当前的大小，防止超过C</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;c) <span class=\"keyword\">return</span>; <span class=\"comment\">//此时累加和已经超过了承受的范围</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sum[cur<span class=\"number\">-1</span>]+x&lt;=c)&#123;    <span class=\"comment\">//对于当前位置来说，如果前面的砝码全部取上加上现在的质量没有超过C，减少了前几次的累加操作</span></span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans,sum[cur<span class=\"number\">-1</span>]+x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans,x);   <span class=\"comment\">//当前状态已经是累加完一个数的状态了，前缀和判断的是该数之前的所有大小，进行细分</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;cur;i++)</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(i,x+a[i]);      <span class=\"comment\">//从第一次最大的做不了后，他直接就从最小的开始一个个递归了，从这里开始是常态化的搜索，剪枝操作在上一步的前缀和里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">        sum[i]=sum[i<span class=\"number\">-1</span>]+a[i];   <span class=\"comment\">//前缀和数组</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(n<span class=\"number\">+1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.luogu.com.cn/problem/P1162\">P1162 填色问题</a></p>\n<p>做这道题的目的是为了能够锻炼BFS算法的思维，但是在题解中出现了比较优秀的DFS算法值得学习其中的思想</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">32</span>][<span class=\"number\">32</span>], b[<span class=\"number\">32</span>][<span class=\"number\">32</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n, i, j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">int</span> q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &lt; <span class=\"number\">0</span> || p &gt; n + <span class=\"number\">1</span> || q &lt; <span class=\"number\">0</span> || q &gt; n + <span class=\"number\">1</span> || a[p][q] != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; <span class=\"comment\">// 说明已经超过了搜索的范围</span></span><br><span class=\"line\">    a[p][q] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(p + dx[i], q + dy[i]); <span class=\"comment\">// 先该点的四周进行搜索</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cin &gt;&gt; b[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b[i][j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                a[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                a[i][j] = <span class=\"number\">2</span>; <span class=\"comment\">// 目前这里为什么直接赋值为2还不清楚</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 这的dfs的作用是通过染色法，将有被围墙保护起来的水进行染色</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"number\">2</span> &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>; <span class=\"comment\">// 说明这里的水是之前被围墙保护起来的没有染色</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                cout &lt;&lt; b[i][j] &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;                           <span class=\"comment\">// a数组中保存的是将原来包括所有墙一起染色的答案。</span></span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解的发布者的整体思想是类似在画图选择颜色中的方向选择。</p>\n<p>​\t在一开始的思考中，我都是通过正向的思维，在想，如何判断到达围墙边缘，同时判断处于围墙的内部。<br>​\t从现在看来，如果我使用正向思维的DFS算算法，就需要首先找到属于围墙中心的一点，然后从这个点开始做扩散。但是如何判断这个点是围墙内的点是一个非常困难的问题，虽然从题目中已经确定，闭合圈中一定可以到达。其实可从触碰到的任意一个点进行判断，但是总感觉有点不够优雅。</p>\n<p>​\t大佬的解法是直接从外围开始，将颜料倒进水里，通过dfs的扩散效果，将除了被围墙保护起来的水进行染色，包括围墙，然后再通过和原来的状态进行对比，得到那些水是被围墙保护起来的，总体效果类似于反选。</p>\n<h2 id=\"BFS的学习\"><a href=\"#BFS的学习\" class=\"headerlink\" title=\"BFS的学习\"></a>BFS的学习</h2><p>对于BFS来说, 就相当于是对一棵树进行层序遍历, 然后再得出结果, 需要将每一个节点对应的下一个节点进行记录. 可以想到是先进先出的思想.</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1162\">P1162 填色问题</a></p>\n<p>同样也是这个问题, 但是采用的是BFS的想法</p>\n<p>题解的提供者同样也是使用的反选的方法进行搜索的. 可见思路的重要性.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> M = <span class=\"number\">31</span>;   <span class=\"comment\">//从1开始记录图像位置</span></span><br><span class=\"line\"><span class=\"type\">int</span> map[M][M];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[M][M];     <span class=\"comment\">//用于记录是否是边界块，其实反向就是说这些不是被保护的块</span></span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a,b,c;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    vis[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>  w = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> e = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//然后向该点的四周进行判断</span></span><br><span class=\"line\">        <span class=\"comment\">//只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w<span class=\"number\">+1</span>][e]== <span class=\"number\">0</span> &amp;&amp; w!=n &amp;&amp; !vis[w<span class=\"number\">+1</span>][e]) vis[w<span class=\"number\">+1</span>][e] = <span class=\"number\">1</span> , q.<span class=\"built_in\">push</span>(w<span class=\"number\">+1</span>), q.<span class=\"built_in\">push</span>(e); </span><br><span class=\"line\">        <span class=\"comment\">//原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w<span class=\"number\">-1</span>][e] == <span class=\"number\">0</span> &amp;&amp; w != <span class=\"number\">1</span> &amp;&amp; !vis[w<span class=\"number\">-1</span>][e] )    vis[w<span class=\"number\">-1</span>][e] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w<span class=\"number\">-1</span>),q.<span class=\"built_in\">push</span>(e);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w][e<span class=\"number\">+1</span>] == <span class=\"number\">0</span> &amp;&amp; e != n &amp;&amp; !vis[w][e<span class=\"number\">+1</span>] )    vis[w][e<span class=\"number\">+1</span>] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w),q.<span class=\"built_in\">push</span>(e<span class=\"number\">+1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w][e<span class=\"number\">-1</span>] == <span class=\"number\">0</span> &amp;&amp; e != <span class=\"number\">1</span> &amp;&amp; !vis[w][e<span class=\"number\">-1</span>] )    vis[w][e<span class=\"number\">-1</span>] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w),q.<span class=\"built_in\">push</span>(e<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">1</span> ;j&lt;=n;j++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;map[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map[i][j] == <span class=\"number\">1</span>) vis[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i+=n<span class=\"number\">-1</span>)&#123; <span class=\"comment\">//直接就判断两个对角上的点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j &lt;= n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[i][j]) <span class=\"keyword\">continue</span>;     <span class=\"comment\">//说明触发到了边界点从这个点</span></span><br><span class=\"line\">            <span class=\"built_in\">bfs</span>(i,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i = i + n - <span class=\"number\">1</span> )        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span> ; j &lt;= n ; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j][i])    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"built_in\">bfs</span>(j,i);            <span class=\"comment\">//十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点</span></span><br><span class=\"line\">                                <span class=\"comment\">//但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++)                <span class=\"comment\">//</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span> ; j &lt;= n ; j++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[i][j])    cout&lt;&lt;<span class=\"string\">&quot;2&quot;</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>;        <span class=\"comment\">//如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>     cout&lt;&lt;map[i][j]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现的方法还是比较符合典型的BFS的实现方法的</p>\n<p>这里放一下我根据上一个题解进行的优化尝试<br>根据将外围包裹一圈, 这样就可以直接是判断点进行自由移动, 可以减少一点代码量, 但是多了一点计算.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> M = <span class=\"number\">32</span>;   <span class=\"comment\">//从1开始记录图像位置</span></span><br><span class=\"line\"><span class=\"type\">int</span> map[M][M];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[M][M];     <span class=\"comment\">//用于记录是否是边界块，其实反向就是说这些不是被保护的块</span></span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a,b,c;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    vis[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>  w = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> e = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//然后向该点的四周进行判断</span></span><br><span class=\"line\">        <span class=\"comment\">//只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w<span class=\"number\">+1</span>][e]== <span class=\"number\">0</span> &amp;&amp; w!=n<span class=\"number\">+1</span> &amp;&amp; !vis[w<span class=\"number\">+1</span>][e]) vis[w<span class=\"number\">+1</span>][e] = <span class=\"number\">1</span> , q.<span class=\"built_in\">push</span>(w<span class=\"number\">+1</span>), q.<span class=\"built_in\">push</span>(e); </span><br><span class=\"line\">        <span class=\"comment\">//原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w<span class=\"number\">-1</span>][e] == <span class=\"number\">0</span> &amp;&amp; w != <span class=\"number\">0</span> &amp;&amp; !vis[w<span class=\"number\">-1</span>][e] )    vis[w<span class=\"number\">-1</span>][e] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w<span class=\"number\">-1</span>),q.<span class=\"built_in\">push</span>(e);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w][e<span class=\"number\">+1</span>] == <span class=\"number\">0</span> &amp;&amp; e != n<span class=\"number\">+1</span> &amp;&amp; !vis[w][e<span class=\"number\">+1</span>] )    vis[w][e<span class=\"number\">+1</span>] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w),q.<span class=\"built_in\">push</span>(e<span class=\"number\">+1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w][e<span class=\"number\">-1</span>] == <span class=\"number\">0</span> &amp;&amp; e != <span class=\"number\">0</span> &amp;&amp; !vis[w][e<span class=\"number\">-1</span>] )    vis[w][e<span class=\"number\">-1</span>] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w),q.<span class=\"built_in\">push</span>(e<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">1</span> ;j&lt;=n;j++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;map[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map[i][j] == <span class=\"number\">1</span>) vis[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;=n;i+=n)&#123; <span class=\"comment\">//直接就判断两个对角上的点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j &lt;= n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[i][j]) <span class=\"keyword\">continue</span>;     <span class=\"comment\">//说明触发到了边界点从这个点</span></span><br><span class=\"line\">            <span class=\"built_in\">bfs</span>(i,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i = 1 ; i &lt;= n ; i = i + n - 1 )        //</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     for(int j = 1 ; j &lt;= n ; j++)</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         if(vis[j][i])    continue;</span></span><br><span class=\"line\">    <span class=\"comment\">//         bfs(j,i);            //十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点</span></span><br><span class=\"line\">    <span class=\"comment\">//                             //但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++)                <span class=\"comment\">//</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span> ; j &lt;= n ; j++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[i][j])    cout&lt;&lt;<span class=\"string\">&quot;2&quot;</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>;        <span class=\"comment\">//如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>     cout&lt;&lt;map[i][j]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.luogu.com.cn/problem/P1443\">P1443</a></p>\n<p>第一道自己写的题目, 但是写着写着从BFS写成了DFS, 虽然当然直接进行DFS显然超时了, 需要进行剪枝.先贴一下没有剪枝过的代码, 作为对比</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">401</span>][<span class=\"number\">401</span>],b[<span class=\"number\">401</span>][<span class=\"number\">401</span>],n,m,x,y;</span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">bool</span> c[<span class=\"number\">401</span>][<span class=\"number\">401</span>];</span><br><span class=\"line\"><span class=\"comment\">// queue&lt;int&gt; q;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i&lt;<span class=\"number\">8</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x+dx[i] &lt; <span class=\"number\">1</span> || y+dy[i]&lt; <span class=\"number\">1</span>  || x+dx[i] &gt; n || y+dy[i]&gt;m || c[x][y]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b[x+dx[i]][y+dy[i]] !=<span class=\"number\">-1</span>)</span><br><span class=\"line\">                b[x+dx[i]][y+dy[i]] = <span class=\"built_in\">min</span>(b[x+dx[i]][y+dy[i]],b[x][y]<span class=\"number\">+1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                b[x+dx[i]][y+dy[i]] = b[x][y]<span class=\"number\">+1</span>;</span><br><span class=\"line\">            c[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">DFS</span>(x+dx[i],y+dy[i]);</span><br><span class=\"line\">            c[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            b[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">DFS</span>(x,y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            cout&lt;&lt;b[i][j]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>想来想去没想到有什么剪枝的方法，因为本身就要判断从这个点进行会不会比另一个点进行更快，就相当于时每个点都进行判断了，要对每一条支路进行分析，剪不掉，意味着层数越深，搜索的次数就越多，因为会有很多的支路。所谓的剪枝，也许就是从层数的角度出发，但是这样就是BFS了，所以最终还是使用BFS进行求解。<del>对于搜索来说，如何选择合适的搜索方式确实时需要慎重考虑的，回旋镖咋回来了</del></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">401</span>][<span class=\"number\">401</span>],b[<span class=\"number\">401</span>][<span class=\"number\">401</span>],n,m,x,y;</span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">bool</span> c[<span class=\"number\">401</span>][<span class=\"number\">401</span>];\t<span class=\"comment\">//像水扩散一样, 从一个点开始出发,将他的每层的连接进行判断,重叠部分就不用判断了,所以不用取消状态.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i&lt;<span class=\"number\">8</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x+dx[i] &lt; <span class=\"number\">1</span> || y+dy[i]&lt; <span class=\"number\">1</span>  || x+dx[i] &gt; n || y+dy[i]&gt;m || c[x][y]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b[x+dx[i]][y+dy[i]] !=<span class=\"number\">-1</span>)</span><br><span class=\"line\">                b[x+dx[i]][y+dy[i]] = <span class=\"built_in\">min</span>(b[x+dx[i]][y+dy[i]],b[x][y]<span class=\"number\">+1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                b[x+dx[i]][y+dy[i]] = b[x][y]<span class=\"number\">+1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(x+dx[i]);</span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(y+dy[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c[x][y] = <span class=\"number\">1</span>;\t<span class=\"comment\">//之前不小心放在循环的里面了,还是要注意什么时候要对状态使用完成进行标记,放里面就有DFS的味道了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n_x = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> n_y= q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"built_in\">BFS</span>(n_x,n_y);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            b[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">BFS</span>(x,y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            cout&lt;&lt;b[i][j]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"30、串联所有单词的字串\"><a href=\"#30、串联所有单词的字串\" class=\"headerlink\" title=\"30、串联所有单词的字串\"></a>30、串联所有单词的字串</h2><p>滑动窗口优化，我尝试的第一道困难题，毕竟不是算法竞赛，没有想象中难么难。当还是有一定挑战的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#我的解法只使用了简单的枚举，其实并不涉及滑动窗口，在重复度高的情况中容易多次统计，造成计算重复</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">findSubstring</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span>, words: <span class=\"type\">List</span>[<span class=\"built_in\">str</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]:</span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        m,n,ls = <span class=\"built_in\">len</span>(words),<span class=\"built_in\">len</span>(words[<span class=\"number\">0</span>]),<span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(ls):</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i + m*n &gt;ls):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            differ = Counter()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">                word = s[i+j*n : i+(j+<span class=\"number\">1</span>)*n]</span><br><span class=\"line\">                differ[word] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">                differ[word] -=<span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> differ[word] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">del</span> differ[word]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(differ) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                res.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res            </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#使用滑动窗口，在最外层的循环中，循环的长度为一个单词的长度，如果是单词整体的减少，通过滑动窗口已经能够进行判断</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">findSubstring</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span>, words: <span class=\"type\">List</span>[<span class=\"built_in\">str</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]:</span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        m, n, ls = <span class=\"built_in\">len</span>(words), <span class=\"built_in\">len</span>(words[<span class=\"number\">0</span>]), <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i + m * n &gt; ls:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            differ = Counter()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">                word = s[i + j * n: i + (j + <span class=\"number\">1</span>) * n]</span><br><span class=\"line\">                differ[word] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">                differ[word] -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> differ[word] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">del</span> differ[word]</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">#下一段是使用滑动窗口的优化</span></span><br><span class=\"line\">                    <span class=\"comment\">#步长为n代表窗口的整体滑动</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> start <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i, ls - m * n + <span class=\"number\">1</span>, n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> start != i:</span><br><span class=\"line\">                    <span class=\"comment\">#word为窗口滑动进入的新词</span></span><br><span class=\"line\">                    word = s[start + (m - <span class=\"number\">1</span>) * n: start + m * n]</span><br><span class=\"line\">                    differ[word] += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"comment\">#可能上一个词组不是,刚好欠这个词</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> differ[word] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">del</span> differ[word]</span><br><span class=\"line\">                    <span class=\"comment\">#上一个</span></span><br><span class=\"line\">                    word = s[start - n: start]</span><br><span class=\"line\">                    differ[word] -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> differ[word] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">del</span> differ[word]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(differ) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    res.append(start)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"135、分发糖果\"><a href=\"#135、分发糖果\" class=\"headerlink\" title=\"135、分发糖果\"></a>135、分发糖果</h2><p>第二道困难题，关于数组的，确实有难度，在于一点巧劲，常规解法的话其实需要对题目的数学模型有一定的理解</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> candy(<span class=\"built_in\">int</span>* ratings, <span class=\"built_in\">int</span> ratingsSize) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> left[ratingsSize];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; ratingsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            left[i] = left[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> right = <span class=\"number\">0</span>, ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = ratingsSize - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; ratingsSize - <span class=\"number\">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret += fmax(left[i], right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：力扣官方题解</span><br><span class=\"line\">链接：https://leetcode.cn/problems/candy/solutions/<span class=\"number\">533150</span>/fen-fa-tang-guo-by-leetcode-solution-f01p/</span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">candy</span>(<span class=\"params\">self, ratings: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(ratings)</span><br><span class=\"line\">        ret = <span class=\"number\">1</span></span><br><span class=\"line\">        inc, dec, pre = <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ratings[i] &gt;= ratings[i - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                dec = <span class=\"number\">0</span></span><br><span class=\"line\">                pre = (<span class=\"number\">1</span> <span class=\"keyword\">if</span> ratings[i] == ratings[i - <span class=\"number\">1</span>] <span class=\"keyword\">else</span> pre + <span class=\"number\">1</span>)</span><br><span class=\"line\">                ret += pre</span><br><span class=\"line\">                inc = pre</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dec += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> dec == inc:</span><br><span class=\"line\">                    dec += <span class=\"number\">1</span></span><br><span class=\"line\">                ret += dec</span><br><span class=\"line\">                pre = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"></span><br><span class=\"line\">作者：力扣官方题解</span><br><span class=\"line\">链接：https://leetcode.cn/problems/candy/solutions/<span class=\"number\">533150</span>/fen-fa-tang-guo-by-leetcode-solution-f01p/</span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"42、接雨水\"><a href=\"#42、接雨水\" class=\"headerlink\" title=\"42、接雨水\"></a>42、接雨水</h2><p>第三道困难题，本来还想通过自己通过的，但是还是被最极端的用例给爆内存了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#自己的解法， 通过每一层进行扫描，但是前提是根据给出的数据创建一个相关的矩阵判断边界，有点像是模拟的做法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">trap</span>(<span class=\"params\">self, height: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">#创建一个矩阵记录边界</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(height)</span><br><span class=\"line\">        max_height = <span class=\"built_in\">max</span>(height)</span><br><span class=\"line\">        bow = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_height)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(height[i]):</span><br><span class=\"line\">                bow[j][i] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">#只有判断到一行中两个一之间的区域的时候，直接将其充满，毕竟没说石柱会有空隙</span></span><br><span class=\"line\">        rain = <span class=\"number\">0</span></span><br><span class=\"line\">        start=end=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_height):</span><br><span class=\"line\">            start=end=<span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> bow[i][j] == <span class=\"number\">1</span> :</span><br><span class=\"line\">                     rain += end - start</span><br><span class=\"line\">                     start = end = j</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> bow[i][start] ==<span class=\"number\">1</span>:</span><br><span class=\"line\">                        end += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rain</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">#总体来说，在构建矩阵的时候，内存消耗过大，被极端用例给爆了</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"202-快乐数\"><a href=\"#202-快乐数\" class=\"headerlink\" title=\"202.快乐数\"></a>202.快乐数</h2><p>本身题目并不难, 思路也比较好像, 但是双指针的思路我一时间还是没有想到的, 同时关于他的时间优化我觉得还是有必要记录一下的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#第一遍的双指针</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">doit</span>(<span class=\"params\">self,n: <span class=\"built_in\">int</span></span>):</span><br><span class=\"line\">        nums=[]</span><br><span class=\"line\">        res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n!=<span class=\"number\">0</span>):</span><br><span class=\"line\">            nums.append(n%<span class=\"number\">10</span>)</span><br><span class=\"line\">            n //= <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">            res += nums[i]**<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">isHappy</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span><br><span class=\"line\">        fast = n</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> fast == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            fast = <span class=\"variable language_\">self</span>.doit(fast)</span><br><span class=\"line\">        slow = n</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != slow):</span><br><span class=\"line\">            slow = <span class=\"variable language_\">self</span>.doit(slow)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">                fast = <span class=\"variable language_\">self</span>.doit(fast)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> fast == <span class=\"number\">1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"comment\"># 将每次快指针指向的数组</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6、z字型变换\"><a href=\"#6、z字型变换\" class=\"headerlink\" title=\"6、z字型变换\"></a>6、z字型变换</h2><p>还是比较简单的，就是纯粹的模拟，但是有一个需要注意的地方，会使题目更简单. 虽然在字体形式上在上升行中会出现很多的空, 但是对于题目要求的输出来说并没有需要按照z字的形式输出, 所以直接忽略空白即可, 所以只需要考虑每个字符应该处在哪一行,同时按照顺序执行就行.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">convert</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span>, numRows: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows &lt; <span class=\"number\">2</span> : <span class=\"keyword\">return</span> s <span class=\"comment\">#小于两行的化和直接输出没有区别</span></span><br><span class=\"line\">        res = [<span class=\"string\">&quot;&quot;</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(numRows)]</span><br><span class=\"line\">        i, flag = <span class=\"number\">0</span>,-<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s :</span><br><span class=\"line\">            res[i]+= c</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> <span class=\"keyword\">or</span> i == numRows-<span class=\"number\">1</span>:</span><br><span class=\"line\">                flag = -flag</span><br><span class=\"line\">            i+=flag</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>.join(res)            </span><br><span class=\"line\">                </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1715、分割回文字符IV\"><a href=\"#1715、分割回文字符IV\" class=\"headerlink\" title=\"1715、分割回文字符IV\"></a><a href=\"https://leetcode.cn/problems/palindrome-partitioning-iv/description/\">1715、分割回文字符IV</a></h2><p>困难题，确实有点出乎意料. 对于一般的字符来说, 还没用到过动态规划. 要考虑到对于一个字符串来说, 如何分割确保分割出来的子字符串为回文,并没有确定的公式, 所以就说明必须要进行一些枚举运算. 但是, 在枚举的过程中, 会存在很多重复的判断是否为回文的字符串, 对于一个变长的子串, 其子串如果在前面已经判断过是否为回文, 那么在对其重复计算明显浪费了算力.</p>\n<p>官方题解使用了一个动态规划数组, 在于任何子串, 其掐去两端的子串如果为回文, 那么, 掐去的两端字符如果相等, 那么其就为回文. 这样每次回文判断其实只需要两次计算.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkPartitioning</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] isPalindrome = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//确定每次判断字符的长度，由于只是对判断原字符中的子字符是否是回文，所以只需要从小到大</span></span><br><span class=\"line\">        <span class=\"comment\">//又因为设计上的动态规划</span></span><br><span class=\"line\">        <span class=\"comment\">//本部分先将所有的子串是否为回文进行记录，虽然其中也有许多的冗余计算， 但是还是相对来说较少</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; length &lt; n; length++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; start &lt;= n -length; start++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//end是可以取到的</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> start + length-<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    isPalindrome[start][end] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(length == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    isPalindrome[start][end] = (s.charAt(start) == s.charAt(end));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//因为length从小到大，所以判断必定是从3-&gt;2,由4-&gt;3, 而其长度为这些的子串都会在前面的计算中判断过</span></span><br><span class=\"line\">                    isPalindrome[start][end] = ((s.charAt(start)==s.charAt(end)) &amp;&amp; isPalindrome[start+<span class=\"number\">1</span>][end-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//直接确定中间字符串的位置即可</span></span><br><span class=\"line\">        <span class=\"comment\">//1、0-&gt;start-1,2、start-&gt;end, 3、end+1-&gt;length</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;start&lt;n-<span class=\"number\">1</span>;start ++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!isPalindrome[<span class=\"number\">0</span>][start-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> end=start; end &lt;n-<span class=\"number\">1</span>;end++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isPalindrome[start][end] &amp;&amp; isPalindrome[end+<span class=\"number\">1</span>][n-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"汇总区间\"><a href=\"#汇总区间\" class=\"headerlink\" title=\"汇总区间\"></a><a href=\"https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150\">汇总区间</a></h2><p>也不知道怎么之前就没有写出来, 非常普通的一个模拟. 但是他的判断逻辑写的有点有趣</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">summaryRanges</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans []<span class=\"type\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, n := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums); i&lt;n; &#123;</span><br><span class=\"line\">        left := i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//类似一个if判断语句， 但是这个写法很抽象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i++; i&lt;n &amp;&amp; nums[i<span class=\"number\">-1</span>] + <span class=\"number\">1</span> == nums[i];i++ &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s := strconv.Itoa(nums[left])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; i<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            s += <span class=\"string\">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">append</span>(ans, s)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3306-元音辅音字母计数-II\"><a href=\"#3306-元音辅音字母计数-II\" class=\"headerlink\" title=\"3306.元音辅音字母计数 II\"></a>3306.元音辅音字母计数 II</h2><p>当读完题目就想到了滑动窗口发,  不知道算不算种进步, 虽然我脑海中的滑动窗口并没有实现. 感觉还是欠点, 或者说感觉我的逻辑太麻烦不够简洁. </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countOfSubstrings</span><span class=\"params\">(word <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int64</span> &#123;</span><br><span class=\"line\">    word_len = <span class=\"built_in\">len</span>(word)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans <span class=\"type\">int64</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> win_len := k+<span class=\"number\">5</span>; win_len &lt;= word_len ;win_len++ &#123;</span><br><span class=\"line\">        occur := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>&#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">0</span>,<span class=\"string\">&#x27;e&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;i&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;o&#x27;</span>:<span class=\"number\">0</span>,<span class=\"string\">&#x27;u&#x27;</span>:<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        other := <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span> ;i &lt;=win_len; i++ &#123;</span><br><span class=\"line\">            _, ok := <span class=\"keyword\">map</span>[word[i]]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">                <span class=\"keyword\">map</span>[word[i]]++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                other++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//....不行了, 太麻烦了, 确实不是一个好的答案, 不是很好模拟, 判断太多了.到后面就容易造成...</span></span><br></pre></td></tr></table></figure>\n\n<p>题解给出的答案是, 通过将统计恰好改为至少. 感觉也是一种题型.</p>\n<p>如果将题目先改成<code>至少出现辅音k次</code>, 那么判断逻辑就会减少, 只要确保形成的子字符串中, 至少保存了k个即以上就行. 而恰好则可以转化成count(k) - count(k+1)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countOfSubstrings</span><span class=\"params\">(word <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int64</span> &#123;</span><br><span class=\"line\">\tvowels := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">bool</span>&#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"literal\">true</span>, <span class=\"string\">&#x27;e&#x27;</span>: <span class=\"literal\">true</span>, <span class=\"string\">&#x27;i&#x27;</span>: <span class=\"literal\">true</span>, <span class=\"string\">&#x27;o&#x27;</span>: <span class=\"literal\">true</span>, <span class=\"string\">&#x27;u&#x27;</span>: <span class=\"literal\">true</span>&#125; <span class=\"comment\">//用于快速判断是否为元音</span></span><br><span class=\"line\">\tcount := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(m <span class=\"type\">int</span>)</span></span> <span class=\"type\">int64</span> &#123;</span><br><span class=\"line\">\t\tn := <span class=\"built_in\">len</span>(word)</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> res <span class=\"type\">int64</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tconsonants := <span class=\"number\">0</span></span><br><span class=\"line\">\t\toccur := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到以当前i开头的子串能满足的最短子串</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j &lt; n &amp;&amp; (consonants &lt; m || <span class=\"built_in\">len</span>(occur) &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> vowels[word[j]] &#123;</span><br><span class=\"line\">\t\t\t\t\toccur[word[j]]++</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tconsonants++</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tj++</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> consonants &gt;= m &amp;&amp; <span class=\"built_in\">len</span>(occur) == <span class=\"number\">5</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//对于当前子串来说已经满足了条件, 那么,后面继续添加长度就必定满足条件, 不用判断</span></span><br><span class=\"line\">\t\t\t\tres += <span class=\"type\">int64</span>(n - j + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">            <span class=\"comment\">//接下来当前子串开头i要向后移位, 需要判断是否会对当前的满足条件造成影响</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> vowels[word[i]] &#123;</span><br><span class=\"line\">\t\t\t\toccur[word[i]]--</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> occur[word[i]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">delete</span>(occur, word[i])</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tconsonants--</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> count(k) - count(k+<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1920-基于排列构建数组\"><a href=\"#1920-基于排列构建数组\" class=\"headerlink\" title=\"1920.基于排列构建数组\"></a><a href=\"https://leetcode.cn/problems/build-array-from-permutation/description/?envType=daily-question&envId=2025-05-06\">1920.基于排列构建数组</a></h2><p>从题目来说, 不考虑优化就是一件非常简单的任务.解法二的思路比较有意思. 这对数据来说, 所有的数据都不会超过1000的大小. 对于如何原地交换的问题在于, 直接交换, 可能只有一个数据满足要求, 会导致另一个数据失效, 同时也会打乱原来排序号的数据. 关键在于如何能够在一个地方同时存储两个数据, 一个代表的是原数据, 另一个代表的是更改后的数据.<br>通过观察数据最大到999, 所以可以将更改数据整体存储在1000位以上, 在通过第二遍历就能够将原数据去除, 只保留1000位以上的数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildArray</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i,_ :=  <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        nums[i] += <span class=\"number\">1000</span>*(nums[nums[i]]%<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i,_ := <span class=\"keyword\">range</span> nums&#123;</span><br><span class=\"line\">        nums[i] /= <span class=\"number\">1000</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] buildArray(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            nums[i] += <span class=\"number\">1000</span>*(nums[nums[i]]%<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            nums[i] /= <span class=\"number\">1000</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是会降低运行速度, 毕竟变成O(n^2)</p>\n","excerpt":"","more":"<h1 id=\"Leetcode-洛谷刷题记录与思考\"><a href=\"#Leetcode-洛谷刷题记录与思考\" class=\"headerlink\" title=\"Leetcode&amp;&amp;洛谷刷题记录与思考\"></a>Leetcode&amp;&amp;洛谷刷题记录与思考</h1><h2 id=\"p-7517\"><a href=\"#p-7517\" class=\"headerlink\" title=\"p 7517\"></a>p 7517</h2><p>题目链接：</p>\n<p><a href=\"https://www.luogu.com.cn/problem/solution/P7517\"></a></p>\n<p>对于第一篇题解的理解。</p>\n<p>···</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> il inline</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">5e5</span><span class=\"number\">+10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//没有多大用的快读</span></span><br><span class=\"line\">    <span class=\"type\">int</span> f=<span class=\"number\">1</span>,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&lt;<span class=\"string\">&#x27;0&#x27;</span>||x&gt;<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==<span class=\"string\">&#x27;-&#x27;</span>) f=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;x&lt;=<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">        s=s*<span class=\"number\">10</span>+x-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f*s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> a[N],b[N];<span class=\"comment\">//b即为桶</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        a[i]=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j*j&lt;=a[i];j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i]%j!=<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//关键判断</span></span><br><span class=\"line\">            <span class=\"type\">int</span> ans1=j,ans2=a[i]/j;</span><br><span class=\"line\">            b[ans1]++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans1!=ans2)<span class=\"comment\">//特判</span></span><br><span class=\"line\">                b[ans2]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;<span class=\"comment\">//爆int警告</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        ans+=(ll)b[a[i]]<span class=\"number\">-1</span>;<span class=\"comment\">//累加，减一是减去自己的贡献</span></span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>···</p>\n<p>其中有他自己创建的读取函数，目前我并不知道这样的读取函数对于直接使用系统自带函数能够提速多少，所以目前不予讨论. </p>\n<p>这篇题解的思路在于直接将每个输入的数的因数直接统计出来,在b桶中计数, a中存储的是用户输入的结果. 最后再将用户输入的结果中的数所对应的桶中的结果倒出来, 同时减去来自自己出现时的那一次<code> 如果是i=j可以出现的情况应该就不用了</code>. 这样每次用户输入的数需要判断<br>$$<br>O(\\sqrt{a_i})<br>$$<br>第二种方法:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> il inline</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">5e5</span><span class=\"number\">+10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> f=<span class=\"number\">1</span>,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&lt;<span class=\"string\">&#x27;0&#x27;</span>||x&gt;<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==<span class=\"string\">&#x27;-&#x27;</span>) f=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;x&lt;=<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">        s=s*<span class=\"number\">10</span>+x-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        x=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f*s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> a[N],b[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    \tb[<span class=\"built_in\">read</span>()]++;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">2</span>;i*j&lt;=N;j++)</span><br><span class=\"line\">    \t\tans+=b[i]*b[i*j];</span><br><span class=\"line\">    \tans+=b[i]*(b[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次通过的是将尽可能的用户输入的数的倍数全部都进行计数. 如果用户输入的数的倍数曾经在用户输入的数据中, 就相当于可以组成一个数对. 不存在的话, 自然相应的数的次数为0, 最终累成和累加的结果就是0. 但是这样的操作,不经让人觉得速度并没有快多少, 应为都要将所有的数据判断一遍, 其中会有很多的含零的数据, 同时这对内存的消耗也很大.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于这道题, 看基本上的解题思路都是直接通过设置桶, 然后直接统计倍数. 这道题的数据都是<code>a_i&lt;=5e5</code> 所以直接将最大定位.</p>\n<h3 id=\"自己根据学习写的代码\"><a href=\"#自己根据学习写的代码\" class=\"headerlink\" title=\"自己根据学习写的代码\"></a>自己根据学习写的代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">long</span> <span class=\"type\">long</span> Maxn=<span class=\"number\">5e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> a[Maxn];</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(a,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(a));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> temp;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lld&quot;</span>,&amp;temp);</span><br><span class=\"line\">        a[temp]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> i=<span class=\"number\">1</span>;i&lt;Maxn;i++)&#123;</span><br><span class=\"line\">        ans+=a[i]*(a[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> j=<span class=\"number\">2</span>*i;j&lt;Maxn;j+=i)&#123;</span><br><span class=\"line\">            ans+=a[i]*a[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>,ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"p-2701\"><a href=\"#p-2701\" class=\"headerlink\" title=\"p 2701\"></a>p 2701</h2><p><a href=\"https://www.luogu.com.cn/problem/P2701\">洛谷</a></p>\n<p>根据提供的题解是通过动态规划进行解答. </p>\n<p>对于动态规划, 首先, 能够进行动态规划的题目首先可以满足暴力枚举, 但是由于数据量较大, 时间消耗过多. 其次, 可以根据节点, 会出现重复搜索或枚举,  将这部分的重复枚举进行删除或者记录, 达到省去的操作, 就可以称作是动态规划.  &#x3D;&#x3D;仅代表个人理解&#x3D;&#x3D;  .</p>\n<p>对于这道题, 选取每一个点作为起点向别处延伸, 很明显可以通过暴力枚举进行解答, 同时, 通过不同的点进行容易想到, 会有很多重复, 所以就可以通过动态规划进行解题.</p>\n<p>由于面积的延伸是正方形,倘若任意一点向想对边进行延伸,即 都需要考虑他周围的点,  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">min_3</span><span class=\"params\">(<span class=\"type\">int</span> ,<span class=\"type\">int</span> ,<span class=\"type\">int</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,t;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;n,&amp;t);</span><br><span class=\"line\">    <span class=\"type\">int</span> a[n][n],b[n][n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">            a[i][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;t;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class=\"line\">        a[x<span class=\"number\">-1</span>][y<span class=\"number\">-1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">            b[i][j]=a[i][j];</span><br><span class=\"line\">    <span class=\"comment\">//到这为止已经将所有的数据进行了初始化。</span></span><br><span class=\"line\">    <span class=\"comment\">//同时，此时的为0是第一行开始，0表示此处有树</span></span><br><span class=\"line\">    <span class=\"comment\">//当以点为右下角,此处同时可以代表就是此处可以达到的最大面积</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将每一个点代表的正方形可视化，或者是略加思考，可以的到每个点与周围点的关系</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i][j])</span><br><span class=\"line\">                b[i][j]+=min_3(b[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>],b[i][j<span class=\"number\">-1</span>],b[i<span class=\"number\">-1</span>][j]);    <span class=\"comment\">//不要忘记，只有当前的区域是没有树的才可能作为一个区域的右下角。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> max=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b[i][j]&gt;max)</span><br><span class=\"line\">                max=b[i][j];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,max);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">min_3</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a&lt;b)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a&lt;c)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&lt;c)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>还是要考虑到的是，如何实现动态规划问题。关键在于如何找出者这之间的关系。</p>\n<h2 id=\"p-2678\"><a href=\"#p-2678\" class=\"headerlink\" title=\"p 2678\"></a>p 2678</h2><p><a href=\"https://www.luogu.com.cn/problem/P2678\">跳石头</a></p>\n<p>通过思考题目可以知道，如果是通过暴力的方法进行解答，需要每次都找到最小的那段距离，然后再将最小的那段距离加到其相邻的两端距离中最小的那一段距离中去，然后再多次重复此方法，知道达到搬移石头的次数用尽。</p>\n<p>很明显，这样的算法思路十分简单，但是遇到数据量大的题目时就略显费劲，先寻找最小的值为N，在判断最小值附近的值，这样的操作要做N遍，所以这是一个 O( n^2^ )的算法。</p>\n<p>对于题解中大佬给出的二分答案法，我一开始并没有想明白对于一个无法进行排序的距离数组，如何使用需要有序为前提的二分查找. 但是通过阅读代码发现, 其中, 解题人的思路并非是将搬移次数作为了循环条件, 而是将搬移次数M当做了一个判断二分答案是否有效的条件. 其思路是, &#x3D;&#x3D;如果存在一个最大的最短距离为X,那么很明显, 其他的任何一段距离必定大于等于这段最短距离&#x3D;&#x3D; . </p>\n<p>所以, 更具解题人的思路, 只需要查找在最长距离中的能够满足搬运次数少于或等于M次的x的最大值就行了<del>当然其实应该不会存在有小于的情况, 不然的话再搬一次不就有新的最大最小距离了吗</del> ,而这个答案明显一定在这之中,当然也可能会包括两端. 对于每个差找到的值, 判断如果需要达到这个查找值,对于当前数组所需要搬运的次数, 如果大于了M次的话, 就说明是太大, 将右边左移, 如果是小于M次就是将左边界右移,应为说明还可以有更大的距离.(其实,这样的算法,同样也会造成很多的数据其实不用算的,毕竟有些数据, 不可能是当前的这个数组能够组成的数据,但是, 在对于巨量的数据来说, 这多出来的计算量, 可能还没有暴力一个节点循环一遍计算量来得多 :cry: )</p>\n<h2 id=\"14、最长公共前缀\"><a href=\"#14、最长公共前缀\" class=\"headerlink\" title=\"14、最长公共前缀\"></a>14、最长公共前缀</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">SearchForMinString</span><span class=\"params\">(<span class=\"type\">char</span>** strs, <span class=\"type\">int</span> strsSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> minsize = <span class=\"built_in\">strlen</span>(strs[<span class=\"number\">0</span>]);  <span class=\"comment\">//初始化最小的长度为第一个字符串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; strsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strlen</span>(strs[i]) &lt; minsize)  <span class=\"comment\">//如果有字符串的长度小于就取最小的</span></span><br><span class=\"line\">            minsize = <span class=\"built_in\">strlen</span>(strs[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minsize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">longestCommonPrefix</span><span class=\"params\">(<span class=\"type\">char</span>** strs, <span class=\"type\">int</span> strsSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> minsize = SearchForMinString(strs, strsSize);   <span class=\"comment\">//得到最小的字符串长度</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* answer = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>) * minsize+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(answer,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>) * minsize+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> answersize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; minsize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; strsSize; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (strs[j][i] != strs[<span class=\"number\">0</span>][i]) <span class=\"comment\">//有不一样的就直接返回答案</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> answer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        answer[answersize] = strs[<span class=\"number\">0</span>][i]; </span><br><span class=\"line\">        answersize++;</span><br><span class=\"line\">        <span class=\"comment\">//说明所有的字符串该为位字符一样，将其赋值到结果的字符串中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> answer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于其中的字符串的malloc应用, 定要记住字符串结尾有一个<code>\\0</code>, 但同时,<code>strlen</code>函数不会将这个计入字符长度内, 所以直接用这样的到的字符长度去创建一个字符串会导致最后一个<code>\\0</code>消失, 导致构不成一个字符串. </p>\n<p>与此同时, 对于malloc其分配的地址空间并不会直接给你初始化好, 所以建议搭配memset一起使用, 同时容易记住申请空间的大小.</p>\n<h2 id=\"11、盛水最多的容器\"><a href=\"#11、盛水最多的容器\" class=\"headerlink\" title=\"11、盛水最多的容器\"></a>11、盛水最多的容器</h2><p>这道题，其实就是现实中的短板效应。任意选择的两个板能够盛水容量取决于最短的板. </p>\n<p>对于这道题直接进行暴力求解非常简单. 但是对于一些测试用例会有超时的可能.</p>\n<p>对于得到的木板数组处于无序状态,  对于任何的一个组合, 两端的木板选择只有两种. 假设从两端开始选取, 如果将两端任意一段的木板移动, 如果移动长版, 那么, 不论移动后的到的木板长度比原来大, 还是比原来小, 由于短板效应不会变, 但是底边必定变小, 所以选择的是的到的容积必定变小. 所以每次移动, 每次移动短板, 才能够是短板的长度进行变化. 这样的行为,可以一减小一定计算量.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">maxArea</span><span class=\"params\">(<span class=\"type\">int</span>* height, <span class=\"type\">int</span> heightSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> head,tail;</span><br><span class=\"line\">    head=<span class=\"number\">0</span>;tail=heightSize<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> maxCapacity=(height[head]&lt;height[tail]?height[head]:height[tail])*(tail-head);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head!=tail)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(height[head]&gt;height[tail])</span><br><span class=\"line\">            tail--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            head++;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        temp=(height[head]&lt;height[tail]?height[head]:height[tail])*(tail-head);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp&gt;maxCapacity)</span><br><span class=\"line\">            maxCapacity=temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxCapacity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"209、长度最小的子数组\"><a href=\"#209、长度最小的子数组\" class=\"headerlink\" title=\"209、长度最小的子数组\"></a>209、长度最小的子数组</h2><h3 id=\"解法一、滑动窗口解法\"><a href=\"#解法一、滑动窗口解法\" class=\"headerlink\" title=\"解法一、滑动窗口解法\"></a>解法一、滑动窗口解法</h3><p>对于滑动窗口来说, 本题要求的子数组连续, 所以可以想象成一个窗口进行滑动. 如果该窗口是不变的话, 那么就需要每次对窗口的大小进行调整, 将窗口的大小从1~numsSize进行尝试, 显然,这样的尝试只比O(n2)暴力搜索快一点. 无法在时间限度内完成.</p>\n<p>直接从小到大的对窗口进行增大, 存在的问题就是, 会有很多的较小的窗口其实没有计算的必要. 如果使用的是动态大小的窗口的话,可以对此进行一定的减少计算.</p>\n<p>先逐步的扩大窗口,直到, 窗口中的数能够直接达到target, 然后再考虑是否对窗口中的数进行出队操作.(对于数组前面的数来说, 必须要是窗口达到当前的大小才能够达到target所以, 应去除窗口前面的数, 看看后面的数有没有可能.) 对窗口中的数进行出队, 当窗口内数的和,小于target的时候, 这时, 就当前的子数组的子数组长度+1的长度, 就是当前子数组能到达到的最小长度, 然后再向后进行查找.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 纯粹的窗口会导致许多小窗口的无谓计算, 尤其是当target和numsSize较大的时候</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, <span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> windowlenth=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(windowlenth&lt;=numsSize)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=numsSize-windowlenth;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i;j-i&lt;windowlenth;j++)&#123;</span><br><span class=\"line\">                sum+=nums[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum&gt;=target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> windowlenth;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        windowlenth++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过动态窗口的大小进行搜索,先找到一个能够达到target的子数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, <span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">queue</span>[numsSize],head,tail;</span><br><span class=\"line\">    <span class=\"type\">int</span> queuesum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans=numsSize+<span class=\"number\">1</span>;</span><br><span class=\"line\">    head=tail=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//进行入队操作同时统计队内和</span></span><br><span class=\"line\">        <span class=\"type\">int</span> temp_ans;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>[tail]=nums[i];</span><br><span class=\"line\">        tail++;</span><br><span class=\"line\">        queuesum+=nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//达到target的时候就从头出队</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(queuesum&gt;=target)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//将能够缩小的全部出队</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(queuesum&gt;=target)&#123;</span><br><span class=\"line\">                queuesum-=<span class=\"built_in\">queue</span>[head];</span><br><span class=\"line\">                head++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            temp_ans=tail-head+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans&gt;temp_ans)</span><br><span class=\"line\">                ans=temp_ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ans == numsSize+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"p1002\"><a href=\"#p1002\" class=\"headerlink\" title=\"p1002\"></a>p1002</h2><p><a href=\"https://www.luogu.com.cn/problem/P1002\">过河卒</a></p>\n<p>其实就是经典动态规划，需要想清楚，几个状态，通过状态的转移找到公式，然后根据公式进行推理即可。</p>\n<h2 id=\"p1004\"><a href=\"#p1004\" class=\"headerlink\" title=\"p1004\"></a>p1004</h2><p><a href=\"https://www.luogu.com.cn/problem/P1004\">方格取数</a></p>\n<p>通过我的思考，也是动态规划根据题目的意思，但是，这次需要遍历两次，需要在第一次的时候，将取到的数置零。让后再进行第二次遍历，进行同样的操作。但是需要进行。但是对于一个直接的动态规划而言，并没有对路劲进行记忆，所以，如何对于一个数组进行置零是很大的问题，对于我的思维来说，我会考虑在加上一个大小合适的记忆数组，对于每一次的路径进行记忆，但是，我认为这十分地耗费空间，而且代码也并不优雅。</p>\n<p>通过题解的思考，这道题的解法是一个四维的动态规划，由于平时遇到的数据二维居多，对于思维的数组，一时间难以理解。最主要的在于，第一遍与第二遍是否应该分开思考的问题。</p>\n<p>通过前面对于二维动态规划的思考，如果是按照模拟的方法，对于每次数组的遍历都采用分离的思想，则每次都是贪心算法，最终获得的是局部最优解，难以证明就是整体最优解。所以在思考四维的动态规划时，也不能将两次遍历分开思考。</p>\n<p>对于相关的四维动态规划数组，其存储的应该就是，一次和第二次走到相关x，y位置是取到的最大值。两次走法应该是在相同时空观下的。但是，由于第一次走后会取走数，所以最终，在走到相同位置时，要减去相关位置的数。一定要将动态规划数组在某某位置的值和相应数组在某某位置的值分开思考。</p>\n<h2 id=\"1010\"><a href=\"#1010\" class=\"headerlink\" title=\"1010\"></a>1010</h2><p><a href=\"https://www.luogu.com.cn/problem/P1010\">幂次方</a></p>\n<p>通过提示，想到对于一个数进行问题的分解，每次只做一层，用递归的方法。</p>\n<p>很容易想到需要用到二进制进行求解。</p>\n<p>通过阅读大佬的题解能得到一个很新的思路</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fff</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">14</span>;i&gt;=<span class=\"number\">0</span>;i--) <span class=\"comment\">//两万的数据最多是2（14）</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,i)&lt;=x)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//pow（n，m）在cmath库中，返回n^m；枚举出第一个幂次方</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==<span class=\"number\">1</span>) cout&lt;&lt;<span class=\"string\">&quot;2&quot;</span>; <span class=\"comment\">//2（1）不用再往后分解了且2^1输出为2，单独出来</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) cout&lt;&lt;<span class=\"string\">&quot;2(0)&quot;</span>; <span class=\"comment\">//2（0）也不用再往后分解了，单独出来</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123; <span class=\"comment\">//若i&gt;1则继续分解指数i</span></span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;2(&quot;</span>;</span><br><span class=\"line\">            <span class=\"built_in\">fff</span>(i);</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            x-=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,i); <span class=\"comment\">//继续循环分解余下的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(x!=<span class=\"number\">0</span>) cout&lt;&lt;<span class=\"string\">&quot;+&quot;</span>;</span><br><span class=\"line\">            <span class=\"comment\">//加号处理的最简单方法：若此x还没分解完，则后面还有项，所以输出一个+号</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    <span class=\"built_in\">fff</span>(a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DFS的算法学习\"><a href=\"#DFS的算法学习\" class=\"headerlink\" title=\"DFS的算法学习\"></a>DFS的算法学习</h2><p><a href=\"https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/\">LCR 175. 计算二叉树的深度 - 力扣（LeetCode）</a></p>\n<p>非常简单的一道DFS的算法题目，计算二叉树的深度， 其实计算什么的深度都是一样的。这道题目相当于已经将应用的场景抽象化了，所以难度不高，在正式的应用中，真正的难度在于如何能够想到这个算法。</p>\n<p>DFS算法的根本是枚举，将所有可能的情况都按照一定的顺序进行了枚举。关键在于回溯的机制。当一条路走到底后，就进行回溯，将之前还存在有路没走的节点再次进行。</p>\n<p>话不多说上源码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class=\"line\"><span class=\"comment\"> * right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">calculateDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ldepth = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> rdepth = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ldepth += <span class=\"built_in\">calculateDepth</span>(root-&gt;left);</span><br><span class=\"line\">        rdepth += <span class=\"built_in\">calculateDepth</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ldepth &gt; rdepth ? ldepth : rdepth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode.cn/problems/invert-binary-tree/description/\">226. 翻转二叉树 - 力扣（LeetCode）</a></p>\n<p>简单的DFS算法可以进行实现，先找到最小的树，然后将其反转，最后在将其根节点进行反转。但是唯一的问题在于，原来又有一个疑问是有可能左右指树可能有空，但是想想，其实有空也应该进行反转，所以在写的时候疑惑解消了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"built_in\">invertTree</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">invertTree</span>(root-&gt;right);</span><br><span class=\"line\">        TreeNode* temp;</span><br><span class=\"line\">        temp = root-&gt;left;</span><br><span class=\"line\">        root-&gt;left = root-&gt;right;</span><br><span class=\"line\">        root-&gt;right = temp;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.luogu.com.cn/problem/P1219\">八皇后</a></p>\n<p>同样需要用到DFS算法，但是这题对我来说的难点在于，如何寻找状态和判断对角线已经被占用</p>\n<p>通过题解，可得将每次下完一个棋，棋盘剩余的资源为一个状态，向下进行传递。同时，对于对角线来说，存在一定的规律，从右到左的行下标与列下标的和在同一对角线相等且唯一，从左到右，行下标与列下标的差在同一对角线值相等且唯一。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"type\">int</span> size;  <span class=\"comment\">//表格的大小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> rows[<span class=\"number\">14</span>],colunms[<span class=\"number\">14</span>],r_l[<span class=\"number\">27</span>],l_r[<span class=\"number\">27</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> solutions;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">GetSoutions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> solutions;</span><br><span class=\"line\">        &#125;   <span class=\"comment\">//用于输出解的个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> n;</span><br><span class=\"line\">            std::cin&gt;&gt;n;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;size = n;</span><br><span class=\"line\">            <span class=\"built_in\">queen</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">GetSoutions</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">myprint</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(solutions&lt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=size ; i++)</span><br><span class=\"line\">                    std::<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,rows[i]);</span><br><span class=\"line\">                <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;solutions++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询合适的位置放置一枚queen，如果没有判断输出，有则标记状态，在进行下次状态转移</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">queen</span><span class=\"params\">(<span class=\"type\">int</span> row)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//row大于行数size，说明到达边界，要么是全部放置完成</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(row&gt;size)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">myprint</span>();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//保证字典序从1开始</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> col = <span class=\"number\">1</span> ;col&lt;=size;col++)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//说明相关列没有被占领，对角线也没有</span></span><br><span class=\"line\">                    <span class=\"comment\">//在此处我曾将row与col差的值进行互换,输出的结果就是错误的,目前还没具体明白是为什么</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>((!colunms[col]) &amp;&amp; (!r_l[col+row]) &amp;&amp; (!l_r[row-col+size]))&#123;</span><br><span class=\"line\">                        rows[row] = col;    <span class=\"comment\">//直接记录相关的列，方便下次进行输出</span></span><br><span class=\"line\">                        colunms[col] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        r_l[col+row] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        l_r[row-col+size] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"built_in\">queen</span>(row<span class=\"number\">+1</span>);   <span class=\"comment\">//状态转移，按照字典序，需从行号递增</span></span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"comment\">//从上个函数跳出，说明已经完成了当前的这个状态的记录的所有结果需要重新进行上个状态的记录，</span></span><br><span class=\"line\">                        <span class=\"comment\">//故清除当前状态的记录</span></span><br><span class=\"line\">                        colunms[col] = r_l[col+row] = l_r[row-col+size] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Solution ans = <span class=\"built_in\">Solution</span>();</span><br><span class=\"line\">    ans.<span class=\"built_in\">Solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.luogu.com.cn/problem/P5194\">P5194</a></p>\n<p>通过阅读题目，容易直接写出深度优先的算法，同时还可以想到类似背包一类。但是，分析数据的大小为1000，至少要做1000^2次运算, 除了AC的答案,其他全部超时了. </p>\n<p>所以设计到深度优先搜索的算法优化, 就是剪枝的理论.</p>\n<p>目前来说, 对于剪枝的理解就是, 通过对题目数据进行分析, 方向对于一些搜索的路径不需要再次搜索. 如题中, 但当前的砝码超出了承受范围C, 则之后的砝码都会超出, 可以直接返回, 这点只需要在判断时加上return语句即可, 但同时, 当前砝码必定大于等于前面两个砝码的质量之和, 但加上当前的砝码超出时, 直接返回后, 由于上一个状态并不能知道当前状态的下一个状态已经超出, 还会再次跳过下一个状态, 直接进行下下个, 这个对于当前的数据集来说就没有必要了, 下一个砝码超出, 则下下个砝码必定超出.</p>\n<p>同时存在关系</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weight[i]+weight[i<span class=\"number\">+3</span>]&lt;C;</span><br><span class=\"line\">weight[i]+weight[i<span class=\"number\">+1</span>]+weight[i<span class=\"number\">+2</span>]&lt;C;</span><br><span class=\"line\"><span class=\"comment\">//所以在i状态下,可以直接跳到i+3的状态,避免了对i+1,i+2的计算,所以,也许直接从大到小搜索才是正解?</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum[<span class=\"number\">1005</span>],a[<span class=\"number\">1005</span>],ans,n,c;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> cur,<span class=\"type\">long</span> <span class=\"type\">long</span> x)</span></span>&#123;  <span class=\"comment\">//cur是为了标记当前的位置，x是记录当前的大小，防止超过C</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;c) <span class=\"keyword\">return</span>; <span class=\"comment\">//此时累加和已经超过了承受的范围</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sum[cur<span class=\"number\">-1</span>]+x&lt;=c)&#123;    <span class=\"comment\">//对于当前位置来说，如果前面的砝码全部取上加上现在的质量没有超过C，减少了前几次的累加操作</span></span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans,sum[cur<span class=\"number\">-1</span>]+x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans,x);   <span class=\"comment\">//当前状态已经是累加完一个数的状态了，前缀和判断的是该数之前的所有大小，进行细分</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;cur;i++)</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(i,x+a[i]);      <span class=\"comment\">//从第一次最大的做不了后，他直接就从最小的开始一个个递归了，从这里开始是常态化的搜索，剪枝操作在上一步的前缀和里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">        sum[i]=sum[i<span class=\"number\">-1</span>]+a[i];   <span class=\"comment\">//前缀和数组</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(n<span class=\"number\">+1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.luogu.com.cn/problem/P1162\">P1162 填色问题</a></p>\n<p>做这道题的目的是为了能够锻炼BFS算法的思维，但是在题解中出现了比较优秀的DFS算法值得学习其中的思想</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">32</span>][<span class=\"number\">32</span>], b[<span class=\"number\">32</span>][<span class=\"number\">32</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n, i, j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">int</span> q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &lt; <span class=\"number\">0</span> || p &gt; n + <span class=\"number\">1</span> || q &lt; <span class=\"number\">0</span> || q &gt; n + <span class=\"number\">1</span> || a[p][q] != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; <span class=\"comment\">// 说明已经超过了搜索的范围</span></span><br><span class=\"line\">    a[p][q] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(p + dx[i], q + dy[i]); <span class=\"comment\">// 先该点的四周进行搜索</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cin &gt;&gt; b[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b[i][j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                a[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                a[i][j] = <span class=\"number\">2</span>; <span class=\"comment\">// 目前这里为什么直接赋值为2还不清楚</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 这的dfs的作用是通过染色法，将有被围墙保护起来的水进行染色</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[i][j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"number\">2</span> &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>; <span class=\"comment\">// 说明这里的水是之前被围墙保护起来的没有染色</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                cout &lt;&lt; b[i][j] &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;                           <span class=\"comment\">// a数组中保存的是将原来包括所有墙一起染色的答案。</span></span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解的发布者的整体思想是类似在画图选择颜色中的方向选择。</p>\n<p>​\t在一开始的思考中，我都是通过正向的思维，在想，如何判断到达围墙边缘，同时判断处于围墙的内部。<br>​\t从现在看来，如果我使用正向思维的DFS算算法，就需要首先找到属于围墙中心的一点，然后从这个点开始做扩散。但是如何判断这个点是围墙内的点是一个非常困难的问题，虽然从题目中已经确定，闭合圈中一定可以到达。其实可从触碰到的任意一个点进行判断，但是总感觉有点不够优雅。</p>\n<p>​\t大佬的解法是直接从外围开始，将颜料倒进水里，通过dfs的扩散效果，将除了被围墙保护起来的水进行染色，包括围墙，然后再通过和原来的状态进行对比，得到那些水是被围墙保护起来的，总体效果类似于反选。</p>\n<h2 id=\"BFS的学习\"><a href=\"#BFS的学习\" class=\"headerlink\" title=\"BFS的学习\"></a>BFS的学习</h2><p>对于BFS来说, 就相当于是对一棵树进行层序遍历, 然后再得出结果, 需要将每一个节点对应的下一个节点进行记录. 可以想到是先进先出的思想.</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1162\">P1162 填色问题</a></p>\n<p>同样也是这个问题, 但是采用的是BFS的想法</p>\n<p>题解的提供者同样也是使用的反选的方法进行搜索的. 可见思路的重要性.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> M = <span class=\"number\">31</span>;   <span class=\"comment\">//从1开始记录图像位置</span></span><br><span class=\"line\"><span class=\"type\">int</span> map[M][M];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[M][M];     <span class=\"comment\">//用于记录是否是边界块，其实反向就是说这些不是被保护的块</span></span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a,b,c;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    vis[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>  w = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> e = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//然后向该点的四周进行判断</span></span><br><span class=\"line\">        <span class=\"comment\">//只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w<span class=\"number\">+1</span>][e]== <span class=\"number\">0</span> &amp;&amp; w!=n &amp;&amp; !vis[w<span class=\"number\">+1</span>][e]) vis[w<span class=\"number\">+1</span>][e] = <span class=\"number\">1</span> , q.<span class=\"built_in\">push</span>(w<span class=\"number\">+1</span>), q.<span class=\"built_in\">push</span>(e); </span><br><span class=\"line\">        <span class=\"comment\">//原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w<span class=\"number\">-1</span>][e] == <span class=\"number\">0</span> &amp;&amp; w != <span class=\"number\">1</span> &amp;&amp; !vis[w<span class=\"number\">-1</span>][e] )    vis[w<span class=\"number\">-1</span>][e] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w<span class=\"number\">-1</span>),q.<span class=\"built_in\">push</span>(e);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w][e<span class=\"number\">+1</span>] == <span class=\"number\">0</span> &amp;&amp; e != n &amp;&amp; !vis[w][e<span class=\"number\">+1</span>] )    vis[w][e<span class=\"number\">+1</span>] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w),q.<span class=\"built_in\">push</span>(e<span class=\"number\">+1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w][e<span class=\"number\">-1</span>] == <span class=\"number\">0</span> &amp;&amp; e != <span class=\"number\">1</span> &amp;&amp; !vis[w][e<span class=\"number\">-1</span>] )    vis[w][e<span class=\"number\">-1</span>] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w),q.<span class=\"built_in\">push</span>(e<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">1</span> ;j&lt;=n;j++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;map[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map[i][j] == <span class=\"number\">1</span>) vis[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i+=n<span class=\"number\">-1</span>)&#123; <span class=\"comment\">//直接就判断两个对角上的点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j &lt;= n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[i][j]) <span class=\"keyword\">continue</span>;     <span class=\"comment\">//说明触发到了边界点从这个点</span></span><br><span class=\"line\">            <span class=\"built_in\">bfs</span>(i,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i = i + n - <span class=\"number\">1</span> )        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span> ; j &lt;= n ; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j][i])    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"built_in\">bfs</span>(j,i);            <span class=\"comment\">//十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点</span></span><br><span class=\"line\">                                <span class=\"comment\">//但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++)                <span class=\"comment\">//</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span> ; j &lt;= n ; j++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[i][j])    cout&lt;&lt;<span class=\"string\">&quot;2&quot;</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>;        <span class=\"comment\">//如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>     cout&lt;&lt;map[i][j]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现的方法还是比较符合典型的BFS的实现方法的</p>\n<p>这里放一下我根据上一个题解进行的优化尝试<br>根据将外围包裹一圈, 这样就可以直接是判断点进行自由移动, 可以减少一点代码量, 但是多了一点计算.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> M = <span class=\"number\">32</span>;   <span class=\"comment\">//从1开始记录图像位置</span></span><br><span class=\"line\"><span class=\"type\">int</span> map[M][M];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[M][M];     <span class=\"comment\">//用于记录是否是边界块，其实反向就是说这些不是被保护的块</span></span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a,b,c;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    vis[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>  w = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> e = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//然后向该点的四周进行判断</span></span><br><span class=\"line\">        <span class=\"comment\">//只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w<span class=\"number\">+1</span>][e]== <span class=\"number\">0</span> &amp;&amp; w!=n<span class=\"number\">+1</span> &amp;&amp; !vis[w<span class=\"number\">+1</span>][e]) vis[w<span class=\"number\">+1</span>][e] = <span class=\"number\">1</span> , q.<span class=\"built_in\">push</span>(w<span class=\"number\">+1</span>), q.<span class=\"built_in\">push</span>(e); </span><br><span class=\"line\">        <span class=\"comment\">//原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w<span class=\"number\">-1</span>][e] == <span class=\"number\">0</span> &amp;&amp; w != <span class=\"number\">0</span> &amp;&amp; !vis[w<span class=\"number\">-1</span>][e] )    vis[w<span class=\"number\">-1</span>][e] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w<span class=\"number\">-1</span>),q.<span class=\"built_in\">push</span>(e);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w][e<span class=\"number\">+1</span>] == <span class=\"number\">0</span> &amp;&amp; e != n<span class=\"number\">+1</span> &amp;&amp; !vis[w][e<span class=\"number\">+1</span>] )    vis[w][e<span class=\"number\">+1</span>] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w),q.<span class=\"built_in\">push</span>(e<span class=\"number\">+1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map[w][e<span class=\"number\">-1</span>] == <span class=\"number\">0</span> &amp;&amp; e != <span class=\"number\">0</span> &amp;&amp; !vis[w][e<span class=\"number\">-1</span>] )    vis[w][e<span class=\"number\">-1</span>] = <span class=\"number\">1</span>,q.<span class=\"built_in\">push</span>(w),q.<span class=\"built_in\">push</span>(e<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">1</span> ;j&lt;=n;j++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;map[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map[i][j] == <span class=\"number\">1</span>) vis[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;=n;i+=n)&#123; <span class=\"comment\">//直接就判断两个对角上的点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j &lt;= n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[i][j]) <span class=\"keyword\">continue</span>;     <span class=\"comment\">//说明触发到了边界点从这个点</span></span><br><span class=\"line\">            <span class=\"built_in\">bfs</span>(i,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i = 1 ; i &lt;= n ; i = i + n - 1 )        //</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     for(int j = 1 ; j &lt;= n ; j++)</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         if(vis[j][i])    continue;</span></span><br><span class=\"line\">    <span class=\"comment\">//         bfs(j,i);            //十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点</span></span><br><span class=\"line\">    <span class=\"comment\">//                             //但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++)                <span class=\"comment\">//</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span> ; j &lt;= n ; j++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[i][j])    cout&lt;&lt;<span class=\"string\">&quot;2&quot;</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>;        <span class=\"comment\">//如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>     cout&lt;&lt;map[i][j]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.luogu.com.cn/problem/P1443\">P1443</a></p>\n<p>第一道自己写的题目, 但是写着写着从BFS写成了DFS, 虽然当然直接进行DFS显然超时了, 需要进行剪枝.先贴一下没有剪枝过的代码, 作为对比</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">401</span>][<span class=\"number\">401</span>],b[<span class=\"number\">401</span>][<span class=\"number\">401</span>],n,m,x,y;</span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">bool</span> c[<span class=\"number\">401</span>][<span class=\"number\">401</span>];</span><br><span class=\"line\"><span class=\"comment\">// queue&lt;int&gt; q;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i&lt;<span class=\"number\">8</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x+dx[i] &lt; <span class=\"number\">1</span> || y+dy[i]&lt; <span class=\"number\">1</span>  || x+dx[i] &gt; n || y+dy[i]&gt;m || c[x][y]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b[x+dx[i]][y+dy[i]] !=<span class=\"number\">-1</span>)</span><br><span class=\"line\">                b[x+dx[i]][y+dy[i]] = <span class=\"built_in\">min</span>(b[x+dx[i]][y+dy[i]],b[x][y]<span class=\"number\">+1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                b[x+dx[i]][y+dy[i]] = b[x][y]<span class=\"number\">+1</span>;</span><br><span class=\"line\">            c[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">DFS</span>(x+dx[i],y+dy[i]);</span><br><span class=\"line\">            c[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            b[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">DFS</span>(x,y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            cout&lt;&lt;b[i][j]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>想来想去没想到有什么剪枝的方法，因为本身就要判断从这个点进行会不会比另一个点进行更快，就相当于时每个点都进行判断了，要对每一条支路进行分析，剪不掉，意味着层数越深，搜索的次数就越多，因为会有很多的支路。所谓的剪枝，也许就是从层数的角度出发，但是这样就是BFS了，所以最终还是使用BFS进行求解。<del>对于搜索来说，如何选择合适的搜索方式确实时需要慎重考虑的，回旋镖咋回来了</del></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">401</span>][<span class=\"number\">401</span>],b[<span class=\"number\">401</span>][<span class=\"number\">401</span>],n,m,x,y;</span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">bool</span> c[<span class=\"number\">401</span>][<span class=\"number\">401</span>];\t<span class=\"comment\">//像水扩散一样, 从一个点开始出发,将他的每层的连接进行判断,重叠部分就不用判断了,所以不用取消状态.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i&lt;<span class=\"number\">8</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x+dx[i] &lt; <span class=\"number\">1</span> || y+dy[i]&lt; <span class=\"number\">1</span>  || x+dx[i] &gt; n || y+dy[i]&gt;m || c[x][y]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b[x+dx[i]][y+dy[i]] !=<span class=\"number\">-1</span>)</span><br><span class=\"line\">                b[x+dx[i]][y+dy[i]] = <span class=\"built_in\">min</span>(b[x+dx[i]][y+dy[i]],b[x][y]<span class=\"number\">+1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                b[x+dx[i]][y+dy[i]] = b[x][y]<span class=\"number\">+1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(x+dx[i]);</span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(y+dy[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c[x][y] = <span class=\"number\">1</span>;\t<span class=\"comment\">//之前不小心放在循环的里面了,还是要注意什么时候要对状态使用完成进行标记,放里面就有DFS的味道了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n_x = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> n_y= q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"built_in\">BFS</span>(n_x,n_y);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            b[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">BFS</span>(x,y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            cout&lt;&lt;b[i][j]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"30、串联所有单词的字串\"><a href=\"#30、串联所有单词的字串\" class=\"headerlink\" title=\"30、串联所有单词的字串\"></a>30、串联所有单词的字串</h2><p>滑动窗口优化，我尝试的第一道困难题，毕竟不是算法竞赛，没有想象中难么难。当还是有一定挑战的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#我的解法只使用了简单的枚举，其实并不涉及滑动窗口，在重复度高的情况中容易多次统计，造成计算重复</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">findSubstring</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span>, words: <span class=\"type\">List</span>[<span class=\"built_in\">str</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]:</span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        m,n,ls = <span class=\"built_in\">len</span>(words),<span class=\"built_in\">len</span>(words[<span class=\"number\">0</span>]),<span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(ls):</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i + m*n &gt;ls):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            differ = Counter()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">                word = s[i+j*n : i+(j+<span class=\"number\">1</span>)*n]</span><br><span class=\"line\">                differ[word] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">                differ[word] -=<span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> differ[word] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">del</span> differ[word]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(differ) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                res.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res            </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#使用滑动窗口，在最外层的循环中，循环的长度为一个单词的长度，如果是单词整体的减少，通过滑动窗口已经能够进行判断</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">findSubstring</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span>, words: <span class=\"type\">List</span>[<span class=\"built_in\">str</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]:</span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        m, n, ls = <span class=\"built_in\">len</span>(words), <span class=\"built_in\">len</span>(words[<span class=\"number\">0</span>]), <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i + m * n &gt; ls:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            differ = Counter()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">                word = s[i + j * n: i + (j + <span class=\"number\">1</span>) * n]</span><br><span class=\"line\">                differ[word] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">                differ[word] -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> differ[word] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">del</span> differ[word]</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">#下一段是使用滑动窗口的优化</span></span><br><span class=\"line\">                    <span class=\"comment\">#步长为n代表窗口的整体滑动</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> start <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i, ls - m * n + <span class=\"number\">1</span>, n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> start != i:</span><br><span class=\"line\">                    <span class=\"comment\">#word为窗口滑动进入的新词</span></span><br><span class=\"line\">                    word = s[start + (m - <span class=\"number\">1</span>) * n: start + m * n]</span><br><span class=\"line\">                    differ[word] += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"comment\">#可能上一个词组不是,刚好欠这个词</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> differ[word] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">del</span> differ[word]</span><br><span class=\"line\">                    <span class=\"comment\">#上一个</span></span><br><span class=\"line\">                    word = s[start - n: start]</span><br><span class=\"line\">                    differ[word] -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> differ[word] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">del</span> differ[word]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(differ) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    res.append(start)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"135、分发糖果\"><a href=\"#135、分发糖果\" class=\"headerlink\" title=\"135、分发糖果\"></a>135、分发糖果</h2><p>第二道困难题，关于数组的，确实有难度，在于一点巧劲，常规解法的话其实需要对题目的数学模型有一定的理解</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> candy(<span class=\"built_in\">int</span>* ratings, <span class=\"built_in\">int</span> ratingsSize) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> left[ratingsSize];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; ratingsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            left[i] = left[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> right = <span class=\"number\">0</span>, ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = ratingsSize - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; ratingsSize - <span class=\"number\">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret += fmax(left[i], right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：力扣官方题解</span><br><span class=\"line\">链接：https://leetcode.cn/problems/candy/solutions/<span class=\"number\">533150</span>/fen-fa-tang-guo-by-leetcode-solution-f01p/</span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">candy</span>(<span class=\"params\">self, ratings: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(ratings)</span><br><span class=\"line\">        ret = <span class=\"number\">1</span></span><br><span class=\"line\">        inc, dec, pre = <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ratings[i] &gt;= ratings[i - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                dec = <span class=\"number\">0</span></span><br><span class=\"line\">                pre = (<span class=\"number\">1</span> <span class=\"keyword\">if</span> ratings[i] == ratings[i - <span class=\"number\">1</span>] <span class=\"keyword\">else</span> pre + <span class=\"number\">1</span>)</span><br><span class=\"line\">                ret += pre</span><br><span class=\"line\">                inc = pre</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dec += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> dec == inc:</span><br><span class=\"line\">                    dec += <span class=\"number\">1</span></span><br><span class=\"line\">                ret += dec</span><br><span class=\"line\">                pre = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"></span><br><span class=\"line\">作者：力扣官方题解</span><br><span class=\"line\">链接：https://leetcode.cn/problems/candy/solutions/<span class=\"number\">533150</span>/fen-fa-tang-guo-by-leetcode-solution-f01p/</span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"42、接雨水\"><a href=\"#42、接雨水\" class=\"headerlink\" title=\"42、接雨水\"></a>42、接雨水</h2><p>第三道困难题，本来还想通过自己通过的，但是还是被最极端的用例给爆内存了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#自己的解法， 通过每一层进行扫描，但是前提是根据给出的数据创建一个相关的矩阵判断边界，有点像是模拟的做法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">trap</span>(<span class=\"params\">self, height: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">#创建一个矩阵记录边界</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(height)</span><br><span class=\"line\">        max_height = <span class=\"built_in\">max</span>(height)</span><br><span class=\"line\">        bow = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_height)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(height[i]):</span><br><span class=\"line\">                bow[j][i] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">#只有判断到一行中两个一之间的区域的时候，直接将其充满，毕竟没说石柱会有空隙</span></span><br><span class=\"line\">        rain = <span class=\"number\">0</span></span><br><span class=\"line\">        start=end=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_height):</span><br><span class=\"line\">            start=end=<span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> bow[i][j] == <span class=\"number\">1</span> :</span><br><span class=\"line\">                     rain += end - start</span><br><span class=\"line\">                     start = end = j</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> bow[i][start] ==<span class=\"number\">1</span>:</span><br><span class=\"line\">                        end += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rain</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">#总体来说，在构建矩阵的时候，内存消耗过大，被极端用例给爆了</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"202-快乐数\"><a href=\"#202-快乐数\" class=\"headerlink\" title=\"202.快乐数\"></a>202.快乐数</h2><p>本身题目并不难, 思路也比较好像, 但是双指针的思路我一时间还是没有想到的, 同时关于他的时间优化我觉得还是有必要记录一下的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#第一遍的双指针</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">doit</span>(<span class=\"params\">self,n: <span class=\"built_in\">int</span></span>):</span><br><span class=\"line\">        nums=[]</span><br><span class=\"line\">        res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n!=<span class=\"number\">0</span>):</span><br><span class=\"line\">            nums.append(n%<span class=\"number\">10</span>)</span><br><span class=\"line\">            n //= <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">            res += nums[i]**<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">isHappy</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span><br><span class=\"line\">        fast = n</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> fast == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            fast = <span class=\"variable language_\">self</span>.doit(fast)</span><br><span class=\"line\">        slow = n</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != slow):</span><br><span class=\"line\">            slow = <span class=\"variable language_\">self</span>.doit(slow)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">                fast = <span class=\"variable language_\">self</span>.doit(fast)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> fast == <span class=\"number\">1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"comment\"># 将每次快指针指向的数组</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6、z字型变换\"><a href=\"#6、z字型变换\" class=\"headerlink\" title=\"6、z字型变换\"></a>6、z字型变换</h2><p>还是比较简单的，就是纯粹的模拟，但是有一个需要注意的地方，会使题目更简单. 虽然在字体形式上在上升行中会出现很多的空, 但是对于题目要求的输出来说并没有需要按照z字的形式输出, 所以直接忽略空白即可, 所以只需要考虑每个字符应该处在哪一行,同时按照顺序执行就行.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">convert</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span>, numRows: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows &lt; <span class=\"number\">2</span> : <span class=\"keyword\">return</span> s <span class=\"comment\">#小于两行的化和直接输出没有区别</span></span><br><span class=\"line\">        res = [<span class=\"string\">&quot;&quot;</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(numRows)]</span><br><span class=\"line\">        i, flag = <span class=\"number\">0</span>,-<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s :</span><br><span class=\"line\">            res[i]+= c</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> <span class=\"keyword\">or</span> i == numRows-<span class=\"number\">1</span>:</span><br><span class=\"line\">                flag = -flag</span><br><span class=\"line\">            i+=flag</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>.join(res)            </span><br><span class=\"line\">                </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1715、分割回文字符IV\"><a href=\"#1715、分割回文字符IV\" class=\"headerlink\" title=\"1715、分割回文字符IV\"></a><a href=\"https://leetcode.cn/problems/palindrome-partitioning-iv/description/\">1715、分割回文字符IV</a></h2><p>困难题，确实有点出乎意料. 对于一般的字符来说, 还没用到过动态规划. 要考虑到对于一个字符串来说, 如何分割确保分割出来的子字符串为回文,并没有确定的公式, 所以就说明必须要进行一些枚举运算. 但是, 在枚举的过程中, 会存在很多重复的判断是否为回文的字符串, 对于一个变长的子串, 其子串如果在前面已经判断过是否为回文, 那么在对其重复计算明显浪费了算力.</p>\n<p>官方题解使用了一个动态规划数组, 在于任何子串, 其掐去两端的子串如果为回文, 那么, 掐去的两端字符如果相等, 那么其就为回文. 这样每次回文判断其实只需要两次计算.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkPartitioning</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] isPalindrome = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//确定每次判断字符的长度，由于只是对判断原字符中的子字符是否是回文，所以只需要从小到大</span></span><br><span class=\"line\">        <span class=\"comment\">//又因为设计上的动态规划</span></span><br><span class=\"line\">        <span class=\"comment\">//本部分先将所有的子串是否为回文进行记录，虽然其中也有许多的冗余计算， 但是还是相对来说较少</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; length &lt; n; length++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; start &lt;= n -length; start++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//end是可以取到的</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> start + length-<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    isPalindrome[start][end] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(length == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    isPalindrome[start][end] = (s.charAt(start) == s.charAt(end));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//因为length从小到大，所以判断必定是从3-&gt;2,由4-&gt;3, 而其长度为这些的子串都会在前面的计算中判断过</span></span><br><span class=\"line\">                    isPalindrome[start][end] = ((s.charAt(start)==s.charAt(end)) &amp;&amp; isPalindrome[start+<span class=\"number\">1</span>][end-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//直接确定中间字符串的位置即可</span></span><br><span class=\"line\">        <span class=\"comment\">//1、0-&gt;start-1,2、start-&gt;end, 3、end+1-&gt;length</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;start&lt;n-<span class=\"number\">1</span>;start ++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!isPalindrome[<span class=\"number\">0</span>][start-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> end=start; end &lt;n-<span class=\"number\">1</span>;end++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isPalindrome[start][end] &amp;&amp; isPalindrome[end+<span class=\"number\">1</span>][n-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"汇总区间\"><a href=\"#汇总区间\" class=\"headerlink\" title=\"汇总区间\"></a><a href=\"https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150\">汇总区间</a></h2><p>也不知道怎么之前就没有写出来, 非常普通的一个模拟. 但是他的判断逻辑写的有点有趣</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">summaryRanges</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans []<span class=\"type\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, n := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums); i&lt;n; &#123;</span><br><span class=\"line\">        left := i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//类似一个if判断语句， 但是这个写法很抽象</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i++; i&lt;n &amp;&amp; nums[i<span class=\"number\">-1</span>] + <span class=\"number\">1</span> == nums[i];i++ &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s := strconv.Itoa(nums[left])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; i<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            s += <span class=\"string\">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">append</span>(ans, s)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3306-元音辅音字母计数-II\"><a href=\"#3306-元音辅音字母计数-II\" class=\"headerlink\" title=\"3306.元音辅音字母计数 II\"></a>3306.元音辅音字母计数 II</h2><p>当读完题目就想到了滑动窗口发,  不知道算不算种进步, 虽然我脑海中的滑动窗口并没有实现. 感觉还是欠点, 或者说感觉我的逻辑太麻烦不够简洁. </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countOfSubstrings</span><span class=\"params\">(word <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int64</span> &#123;</span><br><span class=\"line\">    word_len = <span class=\"built_in\">len</span>(word)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans <span class=\"type\">int64</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> win_len := k+<span class=\"number\">5</span>; win_len &lt;= word_len ;win_len++ &#123;</span><br><span class=\"line\">        occur := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>&#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">0</span>,<span class=\"string\">&#x27;e&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;i&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;o&#x27;</span>:<span class=\"number\">0</span>,<span class=\"string\">&#x27;u&#x27;</span>:<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        other := <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span> ;i &lt;=win_len; i++ &#123;</span><br><span class=\"line\">            _, ok := <span class=\"keyword\">map</span>[word[i]]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">                <span class=\"keyword\">map</span>[word[i]]++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                other++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//....不行了, 太麻烦了, 确实不是一个好的答案, 不是很好模拟, 判断太多了.到后面就容易造成...</span></span><br></pre></td></tr></table></figure>\n\n<p>题解给出的答案是, 通过将统计恰好改为至少. 感觉也是一种题型.</p>\n<p>如果将题目先改成<code>至少出现辅音k次</code>, 那么判断逻辑就会减少, 只要确保形成的子字符串中, 至少保存了k个即以上就行. 而恰好则可以转化成count(k) - count(k+1)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countOfSubstrings</span><span class=\"params\">(word <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int64</span> &#123;</span><br><span class=\"line\">\tvowels := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">bool</span>&#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"literal\">true</span>, <span class=\"string\">&#x27;e&#x27;</span>: <span class=\"literal\">true</span>, <span class=\"string\">&#x27;i&#x27;</span>: <span class=\"literal\">true</span>, <span class=\"string\">&#x27;o&#x27;</span>: <span class=\"literal\">true</span>, <span class=\"string\">&#x27;u&#x27;</span>: <span class=\"literal\">true</span>&#125; <span class=\"comment\">//用于快速判断是否为元音</span></span><br><span class=\"line\">\tcount := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(m <span class=\"type\">int</span>)</span></span> <span class=\"type\">int64</span> &#123;</span><br><span class=\"line\">\t\tn := <span class=\"built_in\">len</span>(word)</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> res <span class=\"type\">int64</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tconsonants := <span class=\"number\">0</span></span><br><span class=\"line\">\t\toccur := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到以当前i开头的子串能满足的最短子串</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j &lt; n &amp;&amp; (consonants &lt; m || <span class=\"built_in\">len</span>(occur) &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> vowels[word[j]] &#123;</span><br><span class=\"line\">\t\t\t\t\toccur[word[j]]++</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tconsonants++</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tj++</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> consonants &gt;= m &amp;&amp; <span class=\"built_in\">len</span>(occur) == <span class=\"number\">5</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//对于当前子串来说已经满足了条件, 那么,后面继续添加长度就必定满足条件, 不用判断</span></span><br><span class=\"line\">\t\t\t\tres += <span class=\"type\">int64</span>(n - j + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">            <span class=\"comment\">//接下来当前子串开头i要向后移位, 需要判断是否会对当前的满足条件造成影响</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> vowels[word[i]] &#123;</span><br><span class=\"line\">\t\t\t\toccur[word[i]]--</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> occur[word[i]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">delete</span>(occur, word[i])</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tconsonants--</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> count(k) - count(k+<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1920-基于排列构建数组\"><a href=\"#1920-基于排列构建数组\" class=\"headerlink\" title=\"1920.基于排列构建数组\"></a><a href=\"https://leetcode.cn/problems/build-array-from-permutation/description/?envType=daily-question&envId=2025-05-06\">1920.基于排列构建数组</a></h2><p>从题目来说, 不考虑优化就是一件非常简单的任务.解法二的思路比较有意思. 这对数据来说, 所有的数据都不会超过1000的大小. 对于如何原地交换的问题在于, 直接交换, 可能只有一个数据满足要求, 会导致另一个数据失效, 同时也会打乱原来排序号的数据. 关键在于如何能够在一个地方同时存储两个数据, 一个代表的是原数据, 另一个代表的是更改后的数据.<br>通过观察数据最大到999, 所以可以将更改数据整体存储在1000位以上, 在通过第二遍历就能够将原数据去除, 只保留1000位以上的数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildArray</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i,_ :=  <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        nums[i] += <span class=\"number\">1000</span>*(nums[nums[i]]%<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i,_ := <span class=\"keyword\">range</span> nums&#123;</span><br><span class=\"line\">        nums[i] /= <span class=\"number\">1000</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] buildArray(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            nums[i] += <span class=\"number\">1000</span>*(nums[nums[i]]%<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            nums[i] /= <span class=\"number\">1000</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是会降低运行速度, 毕竟变成O(n^2)</p>\n"},{"title":"Linux云服务器捣鼓指北","date":"2025-03-05T06:08:52.000Z","updated":"2025-05-06T11:56:52.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"noticeOutdate":null,"_content":"\n# Linux云服务器捣鼓指北\n\n## 个人前言\n\n在想到写着捣鼓的经历记录的时候, 由于自己不成熟的操作, 和健忘的记性, 已经多次将自己的服务器系统重置, ~~已经重置第二遍哩~~! 本着认真工作, 踏实学习的原则, 本人认为, 这样对待服务器是十分不可取的, 毕竟目前这台服务器还是我自己的实验型服务器, 我可以随便折腾, 同时我在服务器上也没有重要文件或者是什么高端的服务, 所以我可以没有任何心理负担的删库跑路, 但是先要成为一个优秀的对对服务有用的人, 这样的做法显然是可耻的.\n\n对此,本人在此对每次进行的操作进行一定的记录和思考, 提供学习和参考. 同时也对看到这篇文章的小白提供一个思路.\n\n## 通过远程SSH连接使用云服务器\n\n本人遵从前辈的教导,通过使用远程的SSH远程连接服务使用云服务器.\n\n使用Xshell新建会话,然后通过root用户进行登录.当然输入的密码就是我自己服务器设置的密码.\n\n但是要在此注意, 这样登录进去的用户肯定是root用户, root用户在进行操作的时具有很强的危险性, 一般需要新建用户进行操作,同时需要更改权限.\n\n## 部署网站服务器核心\n\n跟着鱼皮大佬的教程, 准备安装Nginx服务器核心, 但是在直接输入命令`apt install ngnix`时, 得到错误返回![](.\\img\\QQ截图20240525002142.jpg)\n\n此时其实不太能够理解为什么, 通过包管理软件没有能够找到相应的软件源没能安装上. 一开始,我以为是ubuntu包管理器的问题, 但是在通过网上的资料提示后, 我发现可能是我的包管理器太老旧了,所以输入命令`apt update`更新包管理器. 再次输入命令`apt install nginx`就可以看到服务成功安装了.\n\n然后通过命令`nginx`启动服务,同时输入命令`netstat -ntlp`查看端口的占用可得到如下结果![](.\\img\\QQ截图20240525002925.jpg)\n\n这个时候`:80`端口就已经被nginx服务占用了\n\n此时就可以输入网站地址直接访问网站.![](.\\img\\QQ截图20240525003607.jpg)\n\n相当于是初始页面了是.\n\n对了,此时显示页面的文件位置是`/usr/share/nginx/html`.\n\n对于nginx的配置文件存在于`/etc/nginx`中, 可以对其进行修改.\n\n但是新版的nginx对应的显示网页我并没有找到, 虽然我觉得我可能也用不到, 为了一时之快, 我就先直接跳过那一个步骤了.\n\n## 对服务进行可视化管理\n\n目前来说我也只是新手小白而已, 所以直接先试用大佬推荐的宝塔面板. 安装过程的话直接通过宝塔官网的对应的脚本安装命令复制粘贴即可.\n\n根据提示放行相应的端口, 同时访问给出的面板控制页面, 通过给出的用户名和密码进行登录.\n\n其实本质上就是通过一个可视化的面板对我们服务器上的资源进行了管理, 尤其是一些服务的部署.比如docer,MySQL等等. 当然这些服务也都是可以通过手动输入命令进行安装和配置的, 也许对新手来说就是比较麻烦.\n\n\n\n## 对于web核心服务的第二次部署\n\n其实写到这了, 我其实又干了一次删库跑路的事情, 说来属实是惭愧. 但是正如上图所见, 当我的nginx服务部署完成后, 我发现无论我怎么更改html文件, 都无法修改页面. 当看到了, 要对config文件进行进一步修改的时候, 不出所料的改崩了, 由于做备份的习惯还没有养成, 所以完全无法复原. 除了重置系统外, 我一时想不到任何方法. \n\n对于这一次重装系统, 为了完全达到和大佬一样的效果, 我选择了Centos系列. 其实,除了一些表层的语法有细微的差别, 其实大部分的操作都和ubuntu一样, 但是不得不承认, 确实, 业内对ubuntu有一定忽视是有道理的, 当我直接使用包管理的时候, 我并没有去在多做一步更新, 而是直接就下载下来了. \n\n同时,这次的nginx确实达到的效果就和大佬一样![](.\\img\\QQ截图20240525025835.jpg)\n\n然后我就意识到, nginx针对不同的linux版本做的是不同的, 对于这次的我就可以很方便的去查找和修改. 但是没能解决我在ubuntu上遇到的问题,确实还是有所遗憾.\n\n## 对于web核心服务的第三次部署\n\n写到这也就意味着我有重新重置了一遍系统, 从centos8降到了centos7, 但是我认为这应该是一个更好的选择, 因为7才是稳定支持的版本, 对我来说, 稳定的支持才是最重要的.\n\n上一次部署遇到的问题是当hexo安装后无法启动, 但是其实我查找文件文件夹的时候是发现, 其实hexo已经成功安装了, 但是应该是对于系统的bin路径有问题, 相当于是windows下的环境变量的问题, 导致, 即使这个软件存在, 但是我仍然没有办法使用. 从这一面, 我也见识到了我的Linux技术的不足. 我可以说对Linux完全不懂.\n\n在这一次运用了稳定版本的centos7.3以后, 其实我做的所有事情就是把我前几次捣鼓过的事重新都做了一遍, 可以说所有的命令都背下来了,而且这一次的安装全部都行云流水, 更根本没有费劲. 有些时候不得不感叹天意弄人啊.做了一个通宵, 一秒钟都没有睡,现在是早上6:30!\n\n## 关于更换主题\n\n众所周知，对于官方给你预设的主题总是一言难尽，所以重新配置一个主题，还是很赏心悦目的。\n\n根据主题安装的教程，但是，最后的到的一个页面是，一个无法解析的页面, 根据提示下载了相关的渲染解析器, 但是仍然无法显示. 通过本地浏览启动确又是可以得到结果的. 这不禁以为会是nginx服务的问题, 但是想到, 作为业界常用的服务, 应该不会产生这个问题. 根据, 网上搜寻的到的提示, 当`_config.themes.yml`文件存在的时候, 好像会优先使用,而不会使用`_config.yml`文件, 而此时, 我看到了文件中仍然残存的`_config.landscape.yml`, 果断将其删除, 虽然我没有就此直接再次迭代, 为了方便, 我还是直接复制出了`_config.butterfly.yml`文件, 重新迭代后, 再进行部署,就成功了.\n\n\n\n## 关于生成远程的桌面\n\n### 首先在服务器上安装`GNOME Desktop` 和`vncserver`(全名我忘了), \n\n当启动vncserver服务时, 后面加的数字就是端口号, (5900+端口号). 再通过Realvnc软件进行连接.\n\n## 关于对hexo主题butterfly的配置玩法\n\n### 配置工作\n\n对于一般不想直接搬上服务器的配置资源，选择图床是一个非常好的解决方法。直接将图床上图片的地址放上即可。\n\n同时, 在配置config文件的时候注意, butterfly的形式文件根据官方文档是建议通过在根目录下重新创建一个`config.butterfly.yml` 文件进行配置的, 可以保证不影响到原有主文件. 但是注意如网站的信息和使用主题, 则是直接通过原有的`config.yml`文件进行配置的, 所以一些主要的信息如用户名等要在该文件下修改. \n\n相当于通过`config.yml`和`config.butterfly.yml`两个配置文件共同决定了最后生成页面的各种信息.\n\n### 目前遇到的问题\n\n在将网站进行部署的时候, 在本地的火狐浏览器和远端的Edge浏览器上运行都没有出现问题, 但是在chrome浏览器上, 出现了背景图片无法读取的情况. 通过检查网页的形式, 发现, 相较于Edge浏览器, 在chrome浏览器中`#web_bg`部分为空, 而在Edge部分则存在内容, 但此时, 我对与网页前端的技术并没什么了解, 通过网络查找目前没有找到合适的解决方法. \n\n\n\n## 第二次捣鼓\n\n由于某些原因, 比如ubuntu的支持比较好, 同时, 我想开发的一个服务, 提供额模型只支持Ubuntu, 还有就是所谓的实验桌面只有Ubuntu能用, 我不得不对我的服务器进行重置系统, 虽然我在想, 是否还存在开销更小的方法去实现这件事, 但是目前还是想先去做自己想做的事.\n\t在第二次重置系统时, 突然发现, 想像之前那样方便的使用Xshell进行登录, 突然不行了. 感觉是阿里云升级了SSH访问的规则, 导致需要一些更加安全的手段去对服务器进行访问. 其实感觉就是他将root用户的使用权限把拔高了. 他推出了一个密钥对, 在生成一个密钥对后, 通过加载下载下来的私钥, 还是可以通过一些复杂的方法直接对root用户进行连接的. 当然听着好像不是很规范.\n\n当然, 直接使用密码访问普通的用户还是可以像曾经一样方便的.\n\n### 后记\n\n之所以没有办法登录好像是因为重置完系统后没有办法通过以前的密码登录，重新重置完密码后就可以登录的了。但是在这之前，我曾经以为这个是新推出的密钥的问题，在尝试过一次密钥登录后，会自动在ssh登录的配置文件中禁用密码登录，所以之后我尝试过很多次的密码登录都失效了。根据其文档进行操作后，重新启用密码登录后就有效了。\n\n## Hexo的安装\n\n本来以为经过之前的安装经历，安装过程应该比较顺利。但是，属实是倒腾了我一把。同时，对于服务器的管理应该也有所分工。\n\t既然我选择了使用宝塔面板进行管理，应该尽量避免直接通过用户终端使用`sudo`权限进行安装. 用户应该只需要管理如何进行使用, 而是通过管理员对相关需要的软件进行安装. 有点像运维和开发的关系也许.\n\n直接通过Ubuntu的`apt install `进行安装, 安装的版本过低, 无法满足Hexo的使用需求.\n\n使用宝塔面板的Nodejs管理器, 没注意, 一开始安装的版本是`14.17.6`, 其实也不是高版本, 所以, 在执行`npm install -g hexo`时总是会弹出报错, 但是有无法解决. 通过另一个命令`npm install hexo`和`npx hexo`配合使用貌似可以达到效果, 这让我想到了, 这应该hexo可能就相当于时nodejs的一个库. 当然这样的执行效率实在是太低, 同时, 我无法在用户状态下执行, 所以还是放弃了.\n\n通过装最新的Nodejs版本`22.12.0`最终实现了完美的安装效果.<img src=\".\\img\\QQ20250101-005806.png\" style=\"zoom:80%;\" />\n\n## 使用宝塔面板进行文件的部署\n\n通过宝塔面板，其实，很多的接口都被宝塔面板收走了。在安装完nginx后，即使启动服务，直接访问看到的就是宝塔面板的提示页面![](.\\img\\QQ20250101-184342.png)\n说明相关的:80端口给现在时在宝塔面板的控制下的. 目前我如果直接部署的时我的Hexo博客的话其实全都时静态资源. 所以我选择直接进面板中新建一个Html项目就够了.\n\n## 第二次华为云部署\n\n所有的一切按照以前的来进行多么的轻松又愉快. 当然是假的, 主要是我又尝试更改了一些其他的配置之类的, 但是很遗憾, 总是出错, 当时debug了一个下午, 但是到最后才发现, 一是浏览器缓存的问题, 还有就是配置文件中有拼写错误. 如今, 想再截取当时的错误进行展示还是有些麻烦了, 所以最多口述一下吧.\n\n由于更改了配置中的相关字段, 但是还是造成了拼写错误, 所以没有办法正常渲染出相关css, 最后导致只有文字和ico的显示. 虽然在后面, 我又重新进行了更改, 但是发现服务器返回的还是同样的结果. 通过之前学习的知识, 想到, 可能是浏览器自带的缓存功能导致, 通过禁用缓存重新进行加载完成了正常显示. 同时, 由于我如今已经对网络有了一定了解. 我发现了为什么我以前的背景总是无法加载, 在于背景图片的选择过大, 同时服务器带宽较小, 其实并不是没法加载, 只是加载的实在是太慢了.  :sweat_smile:","source":"_posts/Linux云服务器捣鼓指北.md","raw":"---\ntitle: Linux云服务器捣鼓指北\ndate: 2025-03-05 14:08:52\nupdated: 2025-05-06 19:56:52\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\nnoticeOutdate:\n---\n\n# Linux云服务器捣鼓指北\n\n## 个人前言\n\n在想到写着捣鼓的经历记录的时候, 由于自己不成熟的操作, 和健忘的记性, 已经多次将自己的服务器系统重置, ~~已经重置第二遍哩~~! 本着认真工作, 踏实学习的原则, 本人认为, 这样对待服务器是十分不可取的, 毕竟目前这台服务器还是我自己的实验型服务器, 我可以随便折腾, 同时我在服务器上也没有重要文件或者是什么高端的服务, 所以我可以没有任何心理负担的删库跑路, 但是先要成为一个优秀的对对服务有用的人, 这样的做法显然是可耻的.\n\n对此,本人在此对每次进行的操作进行一定的记录和思考, 提供学习和参考. 同时也对看到这篇文章的小白提供一个思路.\n\n## 通过远程SSH连接使用云服务器\n\n本人遵从前辈的教导,通过使用远程的SSH远程连接服务使用云服务器.\n\n使用Xshell新建会话,然后通过root用户进行登录.当然输入的密码就是我自己服务器设置的密码.\n\n但是要在此注意, 这样登录进去的用户肯定是root用户, root用户在进行操作的时具有很强的危险性, 一般需要新建用户进行操作,同时需要更改权限.\n\n## 部署网站服务器核心\n\n跟着鱼皮大佬的教程, 准备安装Nginx服务器核心, 但是在直接输入命令`apt install ngnix`时, 得到错误返回![](.\\img\\QQ截图20240525002142.jpg)\n\n此时其实不太能够理解为什么, 通过包管理软件没有能够找到相应的软件源没能安装上. 一开始,我以为是ubuntu包管理器的问题, 但是在通过网上的资料提示后, 我发现可能是我的包管理器太老旧了,所以输入命令`apt update`更新包管理器. 再次输入命令`apt install nginx`就可以看到服务成功安装了.\n\n然后通过命令`nginx`启动服务,同时输入命令`netstat -ntlp`查看端口的占用可得到如下结果![](.\\img\\QQ截图20240525002925.jpg)\n\n这个时候`:80`端口就已经被nginx服务占用了\n\n此时就可以输入网站地址直接访问网站.![](.\\img\\QQ截图20240525003607.jpg)\n\n相当于是初始页面了是.\n\n对了,此时显示页面的文件位置是`/usr/share/nginx/html`.\n\n对于nginx的配置文件存在于`/etc/nginx`中, 可以对其进行修改.\n\n但是新版的nginx对应的显示网页我并没有找到, 虽然我觉得我可能也用不到, 为了一时之快, 我就先直接跳过那一个步骤了.\n\n## 对服务进行可视化管理\n\n目前来说我也只是新手小白而已, 所以直接先试用大佬推荐的宝塔面板. 安装过程的话直接通过宝塔官网的对应的脚本安装命令复制粘贴即可.\n\n根据提示放行相应的端口, 同时访问给出的面板控制页面, 通过给出的用户名和密码进行登录.\n\n其实本质上就是通过一个可视化的面板对我们服务器上的资源进行了管理, 尤其是一些服务的部署.比如docer,MySQL等等. 当然这些服务也都是可以通过手动输入命令进行安装和配置的, 也许对新手来说就是比较麻烦.\n\n\n\n## 对于web核心服务的第二次部署\n\n其实写到这了, 我其实又干了一次删库跑路的事情, 说来属实是惭愧. 但是正如上图所见, 当我的nginx服务部署完成后, 我发现无论我怎么更改html文件, 都无法修改页面. 当看到了, 要对config文件进行进一步修改的时候, 不出所料的改崩了, 由于做备份的习惯还没有养成, 所以完全无法复原. 除了重置系统外, 我一时想不到任何方法. \n\n对于这一次重装系统, 为了完全达到和大佬一样的效果, 我选择了Centos系列. 其实,除了一些表层的语法有细微的差别, 其实大部分的操作都和ubuntu一样, 但是不得不承认, 确实, 业内对ubuntu有一定忽视是有道理的, 当我直接使用包管理的时候, 我并没有去在多做一步更新, 而是直接就下载下来了. \n\n同时,这次的nginx确实达到的效果就和大佬一样![](.\\img\\QQ截图20240525025835.jpg)\n\n然后我就意识到, nginx针对不同的linux版本做的是不同的, 对于这次的我就可以很方便的去查找和修改. 但是没能解决我在ubuntu上遇到的问题,确实还是有所遗憾.\n\n## 对于web核心服务的第三次部署\n\n写到这也就意味着我有重新重置了一遍系统, 从centos8降到了centos7, 但是我认为这应该是一个更好的选择, 因为7才是稳定支持的版本, 对我来说, 稳定的支持才是最重要的.\n\n上一次部署遇到的问题是当hexo安装后无法启动, 但是其实我查找文件文件夹的时候是发现, 其实hexo已经成功安装了, 但是应该是对于系统的bin路径有问题, 相当于是windows下的环境变量的问题, 导致, 即使这个软件存在, 但是我仍然没有办法使用. 从这一面, 我也见识到了我的Linux技术的不足. 我可以说对Linux完全不懂.\n\n在这一次运用了稳定版本的centos7.3以后, 其实我做的所有事情就是把我前几次捣鼓过的事重新都做了一遍, 可以说所有的命令都背下来了,而且这一次的安装全部都行云流水, 更根本没有费劲. 有些时候不得不感叹天意弄人啊.做了一个通宵, 一秒钟都没有睡,现在是早上6:30!\n\n## 关于更换主题\n\n众所周知，对于官方给你预设的主题总是一言难尽，所以重新配置一个主题，还是很赏心悦目的。\n\n根据主题安装的教程，但是，最后的到的一个页面是，一个无法解析的页面, 根据提示下载了相关的渲染解析器, 但是仍然无法显示. 通过本地浏览启动确又是可以得到结果的. 这不禁以为会是nginx服务的问题, 但是想到, 作为业界常用的服务, 应该不会产生这个问题. 根据, 网上搜寻的到的提示, 当`_config.themes.yml`文件存在的时候, 好像会优先使用,而不会使用`_config.yml`文件, 而此时, 我看到了文件中仍然残存的`_config.landscape.yml`, 果断将其删除, 虽然我没有就此直接再次迭代, 为了方便, 我还是直接复制出了`_config.butterfly.yml`文件, 重新迭代后, 再进行部署,就成功了.\n\n\n\n## 关于生成远程的桌面\n\n### 首先在服务器上安装`GNOME Desktop` 和`vncserver`(全名我忘了), \n\n当启动vncserver服务时, 后面加的数字就是端口号, (5900+端口号). 再通过Realvnc软件进行连接.\n\n## 关于对hexo主题butterfly的配置玩法\n\n### 配置工作\n\n对于一般不想直接搬上服务器的配置资源，选择图床是一个非常好的解决方法。直接将图床上图片的地址放上即可。\n\n同时, 在配置config文件的时候注意, butterfly的形式文件根据官方文档是建议通过在根目录下重新创建一个`config.butterfly.yml` 文件进行配置的, 可以保证不影响到原有主文件. 但是注意如网站的信息和使用主题, 则是直接通过原有的`config.yml`文件进行配置的, 所以一些主要的信息如用户名等要在该文件下修改. \n\n相当于通过`config.yml`和`config.butterfly.yml`两个配置文件共同决定了最后生成页面的各种信息.\n\n### 目前遇到的问题\n\n在将网站进行部署的时候, 在本地的火狐浏览器和远端的Edge浏览器上运行都没有出现问题, 但是在chrome浏览器上, 出现了背景图片无法读取的情况. 通过检查网页的形式, 发现, 相较于Edge浏览器, 在chrome浏览器中`#web_bg`部分为空, 而在Edge部分则存在内容, 但此时, 我对与网页前端的技术并没什么了解, 通过网络查找目前没有找到合适的解决方法. \n\n\n\n## 第二次捣鼓\n\n由于某些原因, 比如ubuntu的支持比较好, 同时, 我想开发的一个服务, 提供额模型只支持Ubuntu, 还有就是所谓的实验桌面只有Ubuntu能用, 我不得不对我的服务器进行重置系统, 虽然我在想, 是否还存在开销更小的方法去实现这件事, 但是目前还是想先去做自己想做的事.\n\t在第二次重置系统时, 突然发现, 想像之前那样方便的使用Xshell进行登录, 突然不行了. 感觉是阿里云升级了SSH访问的规则, 导致需要一些更加安全的手段去对服务器进行访问. 其实感觉就是他将root用户的使用权限把拔高了. 他推出了一个密钥对, 在生成一个密钥对后, 通过加载下载下来的私钥, 还是可以通过一些复杂的方法直接对root用户进行连接的. 当然听着好像不是很规范.\n\n当然, 直接使用密码访问普通的用户还是可以像曾经一样方便的.\n\n### 后记\n\n之所以没有办法登录好像是因为重置完系统后没有办法通过以前的密码登录，重新重置完密码后就可以登录的了。但是在这之前，我曾经以为这个是新推出的密钥的问题，在尝试过一次密钥登录后，会自动在ssh登录的配置文件中禁用密码登录，所以之后我尝试过很多次的密码登录都失效了。根据其文档进行操作后，重新启用密码登录后就有效了。\n\n## Hexo的安装\n\n本来以为经过之前的安装经历，安装过程应该比较顺利。但是，属实是倒腾了我一把。同时，对于服务器的管理应该也有所分工。\n\t既然我选择了使用宝塔面板进行管理，应该尽量避免直接通过用户终端使用`sudo`权限进行安装. 用户应该只需要管理如何进行使用, 而是通过管理员对相关需要的软件进行安装. 有点像运维和开发的关系也许.\n\n直接通过Ubuntu的`apt install `进行安装, 安装的版本过低, 无法满足Hexo的使用需求.\n\n使用宝塔面板的Nodejs管理器, 没注意, 一开始安装的版本是`14.17.6`, 其实也不是高版本, 所以, 在执行`npm install -g hexo`时总是会弹出报错, 但是有无法解决. 通过另一个命令`npm install hexo`和`npx hexo`配合使用貌似可以达到效果, 这让我想到了, 这应该hexo可能就相当于时nodejs的一个库. 当然这样的执行效率实在是太低, 同时, 我无法在用户状态下执行, 所以还是放弃了.\n\n通过装最新的Nodejs版本`22.12.0`最终实现了完美的安装效果.<img src=\".\\img\\QQ20250101-005806.png\" style=\"zoom:80%;\" />\n\n## 使用宝塔面板进行文件的部署\n\n通过宝塔面板，其实，很多的接口都被宝塔面板收走了。在安装完nginx后，即使启动服务，直接访问看到的就是宝塔面板的提示页面![](.\\img\\QQ20250101-184342.png)\n说明相关的:80端口给现在时在宝塔面板的控制下的. 目前我如果直接部署的时我的Hexo博客的话其实全都时静态资源. 所以我选择直接进面板中新建一个Html项目就够了.\n\n## 第二次华为云部署\n\n所有的一切按照以前的来进行多么的轻松又愉快. 当然是假的, 主要是我又尝试更改了一些其他的配置之类的, 但是很遗憾, 总是出错, 当时debug了一个下午, 但是到最后才发现, 一是浏览器缓存的问题, 还有就是配置文件中有拼写错误. 如今, 想再截取当时的错误进行展示还是有些麻烦了, 所以最多口述一下吧.\n\n由于更改了配置中的相关字段, 但是还是造成了拼写错误, 所以没有办法正常渲染出相关css, 最后导致只有文字和ico的显示. 虽然在后面, 我又重新进行了更改, 但是发现服务器返回的还是同样的结果. 通过之前学习的知识, 想到, 可能是浏览器自带的缓存功能导致, 通过禁用缓存重新进行加载完成了正常显示. 同时, 由于我如今已经对网络有了一定了解. 我发现了为什么我以前的背景总是无法加载, 在于背景图片的选择过大, 同时服务器带宽较小, 其实并不是没法加载, 只是加载的实在是太慢了.  :sweat_smile:","slug":"Linux云服务器捣鼓指北","published":1,"layout":"post","photos":[],"_id":"cmafjaxag0004vpx5b42p1e00","content":"<h1 id=\"Linux云服务器捣鼓指北\"><a href=\"#Linux云服务器捣鼓指北\" class=\"headerlink\" title=\"Linux云服务器捣鼓指北\"></a>Linux云服务器捣鼓指北</h1><h2 id=\"个人前言\"><a href=\"#个人前言\" class=\"headerlink\" title=\"个人前言\"></a>个人前言</h2><p>在想到写着捣鼓的经历记录的时候, 由于自己不成熟的操作, 和健忘的记性, 已经多次将自己的服务器系统重置, <del>已经重置第二遍哩</del>! 本着认真工作, 踏实学习的原则, 本人认为, 这样对待服务器是十分不可取的, 毕竟目前这台服务器还是我自己的实验型服务器, 我可以随便折腾, 同时我在服务器上也没有重要文件或者是什么高端的服务, 所以我可以没有任何心理负担的删库跑路, 但是先要成为一个优秀的对对服务有用的人, 这样的做法显然是可耻的.</p>\n<p>对此,本人在此对每次进行的操作进行一定的记录和思考, 提供学习和参考. 同时也对看到这篇文章的小白提供一个思路.</p>\n<h2 id=\"通过远程SSH连接使用云服务器\"><a href=\"#通过远程SSH连接使用云服务器\" class=\"headerlink\" title=\"通过远程SSH连接使用云服务器\"></a>通过远程SSH连接使用云服务器</h2><p>本人遵从前辈的教导,通过使用远程的SSH远程连接服务使用云服务器.</p>\n<p>使用Xshell新建会话,然后通过root用户进行登录.当然输入的密码就是我自己服务器设置的密码.</p>\n<p>但是要在此注意, 这样登录进去的用户肯定是root用户, root用户在进行操作的时具有很强的危险性, 一般需要新建用户进行操作,同时需要更改权限.</p>\n<h2 id=\"部署网站服务器核心\"><a href=\"#部署网站服务器核心\" class=\"headerlink\" title=\"部署网站服务器核心\"></a>部署网站服务器核心</h2><p>跟着鱼皮大佬的教程, 准备安装Nginx服务器核心, 但是在直接输入命令<code>apt install ngnix</code>时, 得到错误返回<img src=\"/.%5Cimg%5CQQ%E6%88%AA%E5%9B%BE20240525002142.jpg\"></p>\n<p>此时其实不太能够理解为什么, 通过包管理软件没有能够找到相应的软件源没能安装上. 一开始,我以为是ubuntu包管理器的问题, 但是在通过网上的资料提示后, 我发现可能是我的包管理器太老旧了,所以输入命令<code>apt update</code>更新包管理器. 再次输入命令<code>apt install nginx</code>就可以看到服务成功安装了.</p>\n<p>然后通过命令<code>nginx</code>启动服务,同时输入命令<code>netstat -ntlp</code>查看端口的占用可得到如下结果<img src=\"/.%5Cimg%5CQQ%E6%88%AA%E5%9B%BE20240525002925.jpg\"></p>\n<p>这个时候<code>:80</code>端口就已经被nginx服务占用了</p>\n<p>此时就可以输入网站地址直接访问网站.<img src=\"/.%5Cimg%5CQQ%E6%88%AA%E5%9B%BE20240525003607.jpg\"></p>\n<p>相当于是初始页面了是.</p>\n<p>对了,此时显示页面的文件位置是<code>/usr/share/nginx/html</code>.</p>\n<p>对于nginx的配置文件存在于<code>/etc/nginx</code>中, 可以对其进行修改.</p>\n<p>但是新版的nginx对应的显示网页我并没有找到, 虽然我觉得我可能也用不到, 为了一时之快, 我就先直接跳过那一个步骤了.</p>\n<h2 id=\"对服务进行可视化管理\"><a href=\"#对服务进行可视化管理\" class=\"headerlink\" title=\"对服务进行可视化管理\"></a>对服务进行可视化管理</h2><p>目前来说我也只是新手小白而已, 所以直接先试用大佬推荐的宝塔面板. 安装过程的话直接通过宝塔官网的对应的脚本安装命令复制粘贴即可.</p>\n<p>根据提示放行相应的端口, 同时访问给出的面板控制页面, 通过给出的用户名和密码进行登录.</p>\n<p>其实本质上就是通过一个可视化的面板对我们服务器上的资源进行了管理, 尤其是一些服务的部署.比如docer,MySQL等等. 当然这些服务也都是可以通过手动输入命令进行安装和配置的, 也许对新手来说就是比较麻烦.</p>\n<h2 id=\"对于web核心服务的第二次部署\"><a href=\"#对于web核心服务的第二次部署\" class=\"headerlink\" title=\"对于web核心服务的第二次部署\"></a>对于web核心服务的第二次部署</h2><p>其实写到这了, 我其实又干了一次删库跑路的事情, 说来属实是惭愧. 但是正如上图所见, 当我的nginx服务部署完成后, 我发现无论我怎么更改html文件, 都无法修改页面. 当看到了, 要对config文件进行进一步修改的时候, 不出所料的改崩了, 由于做备份的习惯还没有养成, 所以完全无法复原. 除了重置系统外, 我一时想不到任何方法. </p>\n<p>对于这一次重装系统, 为了完全达到和大佬一样的效果, 我选择了Centos系列. 其实,除了一些表层的语法有细微的差别, 其实大部分的操作都和ubuntu一样, 但是不得不承认, 确实, 业内对ubuntu有一定忽视是有道理的, 当我直接使用包管理的时候, 我并没有去在多做一步更新, 而是直接就下载下来了. </p>\n<p>同时,这次的nginx确实达到的效果就和大佬一样<img src=\"/.%5Cimg%5CQQ%E6%88%AA%E5%9B%BE20240525025835.jpg\"></p>\n<p>然后我就意识到, nginx针对不同的linux版本做的是不同的, 对于这次的我就可以很方便的去查找和修改. 但是没能解决我在ubuntu上遇到的问题,确实还是有所遗憾.</p>\n<h2 id=\"对于web核心服务的第三次部署\"><a href=\"#对于web核心服务的第三次部署\" class=\"headerlink\" title=\"对于web核心服务的第三次部署\"></a>对于web核心服务的第三次部署</h2><p>写到这也就意味着我有重新重置了一遍系统, 从centos8降到了centos7, 但是我认为这应该是一个更好的选择, 因为7才是稳定支持的版本, 对我来说, 稳定的支持才是最重要的.</p>\n<p>上一次部署遇到的问题是当hexo安装后无法启动, 但是其实我查找文件文件夹的时候是发现, 其实hexo已经成功安装了, 但是应该是对于系统的bin路径有问题, 相当于是windows下的环境变量的问题, 导致, 即使这个软件存在, 但是我仍然没有办法使用. 从这一面, 我也见识到了我的Linux技术的不足. 我可以说对Linux完全不懂.</p>\n<p>在这一次运用了稳定版本的centos7.3以后, 其实我做的所有事情就是把我前几次捣鼓过的事重新都做了一遍, 可以说所有的命令都背下来了,而且这一次的安装全部都行云流水, 更根本没有费劲. 有些时候不得不感叹天意弄人啊.做了一个通宵, 一秒钟都没有睡,现在是早上6:30!</p>\n<h2 id=\"关于更换主题\"><a href=\"#关于更换主题\" class=\"headerlink\" title=\"关于更换主题\"></a>关于更换主题</h2><p>众所周知，对于官方给你预设的主题总是一言难尽，所以重新配置一个主题，还是很赏心悦目的。</p>\n<p>根据主题安装的教程，但是，最后的到的一个页面是，一个无法解析的页面, 根据提示下载了相关的渲染解析器, 但是仍然无法显示. 通过本地浏览启动确又是可以得到结果的. 这不禁以为会是nginx服务的问题, 但是想到, 作为业界常用的服务, 应该不会产生这个问题. 根据, 网上搜寻的到的提示, 当<code>_config.themes.yml</code>文件存在的时候, 好像会优先使用,而不会使用<code>_config.yml</code>文件, 而此时, 我看到了文件中仍然残存的<code>_config.landscape.yml</code>, 果断将其删除, 虽然我没有就此直接再次迭代, 为了方便, 我还是直接复制出了<code>_config.butterfly.yml</code>文件, 重新迭代后, 再进行部署,就成功了.</p>\n<h2 id=\"关于生成远程的桌面\"><a href=\"#关于生成远程的桌面\" class=\"headerlink\" title=\"关于生成远程的桌面\"></a>关于生成远程的桌面</h2><h3 id=\"首先在服务器上安装GNOME-Desktop-和vncserver-全名我忘了\"><a href=\"#首先在服务器上安装GNOME-Desktop-和vncserver-全名我忘了\" class=\"headerlink\" title=\"首先在服务器上安装GNOME Desktop 和vncserver(全名我忘了),\"></a>首先在服务器上安装<code>GNOME Desktop</code> 和<code>vncserver</code>(全名我忘了),</h3><p>当启动vncserver服务时, 后面加的数字就是端口号, (5900+端口号). 再通过Realvnc软件进行连接.</p>\n<h2 id=\"关于对hexo主题butterfly的配置玩法\"><a href=\"#关于对hexo主题butterfly的配置玩法\" class=\"headerlink\" title=\"关于对hexo主题butterfly的配置玩法\"></a>关于对hexo主题butterfly的配置玩法</h2><h3 id=\"配置工作\"><a href=\"#配置工作\" class=\"headerlink\" title=\"配置工作\"></a>配置工作</h3><p>对于一般不想直接搬上服务器的配置资源，选择图床是一个非常好的解决方法。直接将图床上图片的地址放上即可。</p>\n<p>同时, 在配置config文件的时候注意, butterfly的形式文件根据官方文档是建议通过在根目录下重新创建一个<code>config.butterfly.yml</code> 文件进行配置的, 可以保证不影响到原有主文件. 但是注意如网站的信息和使用主题, 则是直接通过原有的<code>config.yml</code>文件进行配置的, 所以一些主要的信息如用户名等要在该文件下修改. </p>\n<p>相当于通过<code>config.yml</code>和<code>config.butterfly.yml</code>两个配置文件共同决定了最后生成页面的各种信息.</p>\n<h3 id=\"目前遇到的问题\"><a href=\"#目前遇到的问题\" class=\"headerlink\" title=\"目前遇到的问题\"></a>目前遇到的问题</h3><p>在将网站进行部署的时候, 在本地的火狐浏览器和远端的Edge浏览器上运行都没有出现问题, 但是在chrome浏览器上, 出现了背景图片无法读取的情况. 通过检查网页的形式, 发现, 相较于Edge浏览器, 在chrome浏览器中<code>#web_bg</code>部分为空, 而在Edge部分则存在内容, 但此时, 我对与网页前端的技术并没什么了解, 通过网络查找目前没有找到合适的解决方法. </p>\n<h2 id=\"第二次捣鼓\"><a href=\"#第二次捣鼓\" class=\"headerlink\" title=\"第二次捣鼓\"></a>第二次捣鼓</h2><p>由于某些原因, 比如ubuntu的支持比较好, 同时, 我想开发的一个服务, 提供额模型只支持Ubuntu, 还有就是所谓的实验桌面只有Ubuntu能用, 我不得不对我的服务器进行重置系统, 虽然我在想, 是否还存在开销更小的方法去实现这件事, 但是目前还是想先去做自己想做的事.<br>    在第二次重置系统时, 突然发现, 想像之前那样方便的使用Xshell进行登录, 突然不行了. 感觉是阿里云升级了SSH访问的规则, 导致需要一些更加安全的手段去对服务器进行访问. 其实感觉就是他将root用户的使用权限把拔高了. 他推出了一个密钥对, 在生成一个密钥对后, 通过加载下载下来的私钥, 还是可以通过一些复杂的方法直接对root用户进行连接的. 当然听着好像不是很规范.</p>\n<p>当然, 直接使用密码访问普通的用户还是可以像曾经一样方便的.</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>之所以没有办法登录好像是因为重置完系统后没有办法通过以前的密码登录，重新重置完密码后就可以登录的了。但是在这之前，我曾经以为这个是新推出的密钥的问题，在尝试过一次密钥登录后，会自动在ssh登录的配置文件中禁用密码登录，所以之后我尝试过很多次的密码登录都失效了。根据其文档进行操作后，重新启用密码登录后就有效了。</p>\n<h2 id=\"Hexo的安装\"><a href=\"#Hexo的安装\" class=\"headerlink\" title=\"Hexo的安装\"></a>Hexo的安装</h2><p>本来以为经过之前的安装经历，安装过程应该比较顺利。但是，属实是倒腾了我一把。同时，对于服务器的管理应该也有所分工。<br>    既然我选择了使用宝塔面板进行管理，应该尽量避免直接通过用户终端使用<code>sudo</code>权限进行安装. 用户应该只需要管理如何进行使用, 而是通过管理员对相关需要的软件进行安装. 有点像运维和开发的关系也许.</p>\n<p>直接通过Ubuntu的<code>apt install </code>进行安装, 安装的版本过低, 无法满足Hexo的使用需求.</p>\n<p>使用宝塔面板的Nodejs管理器, 没注意, 一开始安装的版本是<code>14.17.6</code>, 其实也不是高版本, 所以, 在执行<code>npm install -g hexo</code>时总是会弹出报错, 但是有无法解决. 通过另一个命令<code>npm install hexo</code>和<code>npx hexo</code>配合使用貌似可以达到效果, 这让我想到了, 这应该hexo可能就相当于时nodejs的一个库. 当然这样的执行效率实在是太低, 同时, 我无法在用户状态下执行, 所以还是放弃了.</p>\n<p>通过装最新的Nodejs版本<code>22.12.0</code>最终实现了完美的安装效果.<img src=\".\\img\\QQ20250101-005806.png\" style=\"zoom:80%;\" /></p>\n<h2 id=\"使用宝塔面板进行文件的部署\"><a href=\"#使用宝塔面板进行文件的部署\" class=\"headerlink\" title=\"使用宝塔面板进行文件的部署\"></a>使用宝塔面板进行文件的部署</h2><p>通过宝塔面板，其实，很多的接口都被宝塔面板收走了。在安装完nginx后，即使启动服务，直接访问看到的就是宝塔面板的提示页面<img src=\"/.%5Cimg%5CQQ20250101-184342.png\"><br>说明相关的:80端口给现在时在宝塔面板的控制下的. 目前我如果直接部署的时我的Hexo博客的话其实全都时静态资源. 所以我选择直接进面板中新建一个Html项目就够了.</p>\n<h2 id=\"第二次华为云部署\"><a href=\"#第二次华为云部署\" class=\"headerlink\" title=\"第二次华为云部署\"></a>第二次华为云部署</h2><p>所有的一切按照以前的来进行多么的轻松又愉快. 当然是假的, 主要是我又尝试更改了一些其他的配置之类的, 但是很遗憾, 总是出错, 当时debug了一个下午, 但是到最后才发现, 一是浏览器缓存的问题, 还有就是配置文件中有拼写错误. 如今, 想再截取当时的错误进行展示还是有些麻烦了, 所以最多口述一下吧.</p>\n<p>由于更改了配置中的相关字段, 但是还是造成了拼写错误, 所以没有办法正常渲染出相关css, 最后导致只有文字和ico的显示. 虽然在后面, 我又重新进行了更改, 但是发现服务器返回的还是同样的结果. 通过之前学习的知识, 想到, 可能是浏览器自带的缓存功能导致, 通过禁用缓存重新进行加载完成了正常显示. 同时, 由于我如今已经对网络有了一定了解. 我发现了为什么我以前的背景总是无法加载, 在于背景图片的选择过大, 同时服务器带宽较小, 其实并不是没法加载, 只是加载的实在是太慢了.  :sweat_smile:</p>\n","excerpt":"","more":"<h1 id=\"Linux云服务器捣鼓指北\"><a href=\"#Linux云服务器捣鼓指北\" class=\"headerlink\" title=\"Linux云服务器捣鼓指北\"></a>Linux云服务器捣鼓指北</h1><h2 id=\"个人前言\"><a href=\"#个人前言\" class=\"headerlink\" title=\"个人前言\"></a>个人前言</h2><p>在想到写着捣鼓的经历记录的时候, 由于自己不成熟的操作, 和健忘的记性, 已经多次将自己的服务器系统重置, <del>已经重置第二遍哩</del>! 本着认真工作, 踏实学习的原则, 本人认为, 这样对待服务器是十分不可取的, 毕竟目前这台服务器还是我自己的实验型服务器, 我可以随便折腾, 同时我在服务器上也没有重要文件或者是什么高端的服务, 所以我可以没有任何心理负担的删库跑路, 但是先要成为一个优秀的对对服务有用的人, 这样的做法显然是可耻的.</p>\n<p>对此,本人在此对每次进行的操作进行一定的记录和思考, 提供学习和参考. 同时也对看到这篇文章的小白提供一个思路.</p>\n<h2 id=\"通过远程SSH连接使用云服务器\"><a href=\"#通过远程SSH连接使用云服务器\" class=\"headerlink\" title=\"通过远程SSH连接使用云服务器\"></a>通过远程SSH连接使用云服务器</h2><p>本人遵从前辈的教导,通过使用远程的SSH远程连接服务使用云服务器.</p>\n<p>使用Xshell新建会话,然后通过root用户进行登录.当然输入的密码就是我自己服务器设置的密码.</p>\n<p>但是要在此注意, 这样登录进去的用户肯定是root用户, root用户在进行操作的时具有很强的危险性, 一般需要新建用户进行操作,同时需要更改权限.</p>\n<h2 id=\"部署网站服务器核心\"><a href=\"#部署网站服务器核心\" class=\"headerlink\" title=\"部署网站服务器核心\"></a>部署网站服务器核心</h2><p>跟着鱼皮大佬的教程, 准备安装Nginx服务器核心, 但是在直接输入命令<code>apt install ngnix</code>时, 得到错误返回<img src=\"/.%5Cimg%5CQQ%E6%88%AA%E5%9B%BE20240525002142.jpg\"></p>\n<p>此时其实不太能够理解为什么, 通过包管理软件没有能够找到相应的软件源没能安装上. 一开始,我以为是ubuntu包管理器的问题, 但是在通过网上的资料提示后, 我发现可能是我的包管理器太老旧了,所以输入命令<code>apt update</code>更新包管理器. 再次输入命令<code>apt install nginx</code>就可以看到服务成功安装了.</p>\n<p>然后通过命令<code>nginx</code>启动服务,同时输入命令<code>netstat -ntlp</code>查看端口的占用可得到如下结果<img src=\"/.%5Cimg%5CQQ%E6%88%AA%E5%9B%BE20240525002925.jpg\"></p>\n<p>这个时候<code>:80</code>端口就已经被nginx服务占用了</p>\n<p>此时就可以输入网站地址直接访问网站.<img src=\"/.%5Cimg%5CQQ%E6%88%AA%E5%9B%BE20240525003607.jpg\"></p>\n<p>相当于是初始页面了是.</p>\n<p>对了,此时显示页面的文件位置是<code>/usr/share/nginx/html</code>.</p>\n<p>对于nginx的配置文件存在于<code>/etc/nginx</code>中, 可以对其进行修改.</p>\n<p>但是新版的nginx对应的显示网页我并没有找到, 虽然我觉得我可能也用不到, 为了一时之快, 我就先直接跳过那一个步骤了.</p>\n<h2 id=\"对服务进行可视化管理\"><a href=\"#对服务进行可视化管理\" class=\"headerlink\" title=\"对服务进行可视化管理\"></a>对服务进行可视化管理</h2><p>目前来说我也只是新手小白而已, 所以直接先试用大佬推荐的宝塔面板. 安装过程的话直接通过宝塔官网的对应的脚本安装命令复制粘贴即可.</p>\n<p>根据提示放行相应的端口, 同时访问给出的面板控制页面, 通过给出的用户名和密码进行登录.</p>\n<p>其实本质上就是通过一个可视化的面板对我们服务器上的资源进行了管理, 尤其是一些服务的部署.比如docer,MySQL等等. 当然这些服务也都是可以通过手动输入命令进行安装和配置的, 也许对新手来说就是比较麻烦.</p>\n<h2 id=\"对于web核心服务的第二次部署\"><a href=\"#对于web核心服务的第二次部署\" class=\"headerlink\" title=\"对于web核心服务的第二次部署\"></a>对于web核心服务的第二次部署</h2><p>其实写到这了, 我其实又干了一次删库跑路的事情, 说来属实是惭愧. 但是正如上图所见, 当我的nginx服务部署完成后, 我发现无论我怎么更改html文件, 都无法修改页面. 当看到了, 要对config文件进行进一步修改的时候, 不出所料的改崩了, 由于做备份的习惯还没有养成, 所以完全无法复原. 除了重置系统外, 我一时想不到任何方法. </p>\n<p>对于这一次重装系统, 为了完全达到和大佬一样的效果, 我选择了Centos系列. 其实,除了一些表层的语法有细微的差别, 其实大部分的操作都和ubuntu一样, 但是不得不承认, 确实, 业内对ubuntu有一定忽视是有道理的, 当我直接使用包管理的时候, 我并没有去在多做一步更新, 而是直接就下载下来了. </p>\n<p>同时,这次的nginx确实达到的效果就和大佬一样<img src=\"/.%5Cimg%5CQQ%E6%88%AA%E5%9B%BE20240525025835.jpg\"></p>\n<p>然后我就意识到, nginx针对不同的linux版本做的是不同的, 对于这次的我就可以很方便的去查找和修改. 但是没能解决我在ubuntu上遇到的问题,确实还是有所遗憾.</p>\n<h2 id=\"对于web核心服务的第三次部署\"><a href=\"#对于web核心服务的第三次部署\" class=\"headerlink\" title=\"对于web核心服务的第三次部署\"></a>对于web核心服务的第三次部署</h2><p>写到这也就意味着我有重新重置了一遍系统, 从centos8降到了centos7, 但是我认为这应该是一个更好的选择, 因为7才是稳定支持的版本, 对我来说, 稳定的支持才是最重要的.</p>\n<p>上一次部署遇到的问题是当hexo安装后无法启动, 但是其实我查找文件文件夹的时候是发现, 其实hexo已经成功安装了, 但是应该是对于系统的bin路径有问题, 相当于是windows下的环境变量的问题, 导致, 即使这个软件存在, 但是我仍然没有办法使用. 从这一面, 我也见识到了我的Linux技术的不足. 我可以说对Linux完全不懂.</p>\n<p>在这一次运用了稳定版本的centos7.3以后, 其实我做的所有事情就是把我前几次捣鼓过的事重新都做了一遍, 可以说所有的命令都背下来了,而且这一次的安装全部都行云流水, 更根本没有费劲. 有些时候不得不感叹天意弄人啊.做了一个通宵, 一秒钟都没有睡,现在是早上6:30!</p>\n<h2 id=\"关于更换主题\"><a href=\"#关于更换主题\" class=\"headerlink\" title=\"关于更换主题\"></a>关于更换主题</h2><p>众所周知，对于官方给你预设的主题总是一言难尽，所以重新配置一个主题，还是很赏心悦目的。</p>\n<p>根据主题安装的教程，但是，最后的到的一个页面是，一个无法解析的页面, 根据提示下载了相关的渲染解析器, 但是仍然无法显示. 通过本地浏览启动确又是可以得到结果的. 这不禁以为会是nginx服务的问题, 但是想到, 作为业界常用的服务, 应该不会产生这个问题. 根据, 网上搜寻的到的提示, 当<code>_config.themes.yml</code>文件存在的时候, 好像会优先使用,而不会使用<code>_config.yml</code>文件, 而此时, 我看到了文件中仍然残存的<code>_config.landscape.yml</code>, 果断将其删除, 虽然我没有就此直接再次迭代, 为了方便, 我还是直接复制出了<code>_config.butterfly.yml</code>文件, 重新迭代后, 再进行部署,就成功了.</p>\n<h2 id=\"关于生成远程的桌面\"><a href=\"#关于生成远程的桌面\" class=\"headerlink\" title=\"关于生成远程的桌面\"></a>关于生成远程的桌面</h2><h3 id=\"首先在服务器上安装GNOME-Desktop-和vncserver-全名我忘了\"><a href=\"#首先在服务器上安装GNOME-Desktop-和vncserver-全名我忘了\" class=\"headerlink\" title=\"首先在服务器上安装GNOME Desktop 和vncserver(全名我忘了),\"></a>首先在服务器上安装<code>GNOME Desktop</code> 和<code>vncserver</code>(全名我忘了),</h3><p>当启动vncserver服务时, 后面加的数字就是端口号, (5900+端口号). 再通过Realvnc软件进行连接.</p>\n<h2 id=\"关于对hexo主题butterfly的配置玩法\"><a href=\"#关于对hexo主题butterfly的配置玩法\" class=\"headerlink\" title=\"关于对hexo主题butterfly的配置玩法\"></a>关于对hexo主题butterfly的配置玩法</h2><h3 id=\"配置工作\"><a href=\"#配置工作\" class=\"headerlink\" title=\"配置工作\"></a>配置工作</h3><p>对于一般不想直接搬上服务器的配置资源，选择图床是一个非常好的解决方法。直接将图床上图片的地址放上即可。</p>\n<p>同时, 在配置config文件的时候注意, butterfly的形式文件根据官方文档是建议通过在根目录下重新创建一个<code>config.butterfly.yml</code> 文件进行配置的, 可以保证不影响到原有主文件. 但是注意如网站的信息和使用主题, 则是直接通过原有的<code>config.yml</code>文件进行配置的, 所以一些主要的信息如用户名等要在该文件下修改. </p>\n<p>相当于通过<code>config.yml</code>和<code>config.butterfly.yml</code>两个配置文件共同决定了最后生成页面的各种信息.</p>\n<h3 id=\"目前遇到的问题\"><a href=\"#目前遇到的问题\" class=\"headerlink\" title=\"目前遇到的问题\"></a>目前遇到的问题</h3><p>在将网站进行部署的时候, 在本地的火狐浏览器和远端的Edge浏览器上运行都没有出现问题, 但是在chrome浏览器上, 出现了背景图片无法读取的情况. 通过检查网页的形式, 发现, 相较于Edge浏览器, 在chrome浏览器中<code>#web_bg</code>部分为空, 而在Edge部分则存在内容, 但此时, 我对与网页前端的技术并没什么了解, 通过网络查找目前没有找到合适的解决方法. </p>\n<h2 id=\"第二次捣鼓\"><a href=\"#第二次捣鼓\" class=\"headerlink\" title=\"第二次捣鼓\"></a>第二次捣鼓</h2><p>由于某些原因, 比如ubuntu的支持比较好, 同时, 我想开发的一个服务, 提供额模型只支持Ubuntu, 还有就是所谓的实验桌面只有Ubuntu能用, 我不得不对我的服务器进行重置系统, 虽然我在想, 是否还存在开销更小的方法去实现这件事, 但是目前还是想先去做自己想做的事.<br>    在第二次重置系统时, 突然发现, 想像之前那样方便的使用Xshell进行登录, 突然不行了. 感觉是阿里云升级了SSH访问的规则, 导致需要一些更加安全的手段去对服务器进行访问. 其实感觉就是他将root用户的使用权限把拔高了. 他推出了一个密钥对, 在生成一个密钥对后, 通过加载下载下来的私钥, 还是可以通过一些复杂的方法直接对root用户进行连接的. 当然听着好像不是很规范.</p>\n<p>当然, 直接使用密码访问普通的用户还是可以像曾经一样方便的.</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>之所以没有办法登录好像是因为重置完系统后没有办法通过以前的密码登录，重新重置完密码后就可以登录的了。但是在这之前，我曾经以为这个是新推出的密钥的问题，在尝试过一次密钥登录后，会自动在ssh登录的配置文件中禁用密码登录，所以之后我尝试过很多次的密码登录都失效了。根据其文档进行操作后，重新启用密码登录后就有效了。</p>\n<h2 id=\"Hexo的安装\"><a href=\"#Hexo的安装\" class=\"headerlink\" title=\"Hexo的安装\"></a>Hexo的安装</h2><p>本来以为经过之前的安装经历，安装过程应该比较顺利。但是，属实是倒腾了我一把。同时，对于服务器的管理应该也有所分工。<br>    既然我选择了使用宝塔面板进行管理，应该尽量避免直接通过用户终端使用<code>sudo</code>权限进行安装. 用户应该只需要管理如何进行使用, 而是通过管理员对相关需要的软件进行安装. 有点像运维和开发的关系也许.</p>\n<p>直接通过Ubuntu的<code>apt install </code>进行安装, 安装的版本过低, 无法满足Hexo的使用需求.</p>\n<p>使用宝塔面板的Nodejs管理器, 没注意, 一开始安装的版本是<code>14.17.6</code>, 其实也不是高版本, 所以, 在执行<code>npm install -g hexo</code>时总是会弹出报错, 但是有无法解决. 通过另一个命令<code>npm install hexo</code>和<code>npx hexo</code>配合使用貌似可以达到效果, 这让我想到了, 这应该hexo可能就相当于时nodejs的一个库. 当然这样的执行效率实在是太低, 同时, 我无法在用户状态下执行, 所以还是放弃了.</p>\n<p>通过装最新的Nodejs版本<code>22.12.0</code>最终实现了完美的安装效果.<img src=\".\\img\\QQ20250101-005806.png\" style=\"zoom:80%;\" /></p>\n<h2 id=\"使用宝塔面板进行文件的部署\"><a href=\"#使用宝塔面板进行文件的部署\" class=\"headerlink\" title=\"使用宝塔面板进行文件的部署\"></a>使用宝塔面板进行文件的部署</h2><p>通过宝塔面板，其实，很多的接口都被宝塔面板收走了。在安装完nginx后，即使启动服务，直接访问看到的就是宝塔面板的提示页面<img src=\"/.%5Cimg%5CQQ20250101-184342.png\"><br>说明相关的:80端口给现在时在宝塔面板的控制下的. 目前我如果直接部署的时我的Hexo博客的话其实全都时静态资源. 所以我选择直接进面板中新建一个Html项目就够了.</p>\n<h2 id=\"第二次华为云部署\"><a href=\"#第二次华为云部署\" class=\"headerlink\" title=\"第二次华为云部署\"></a>第二次华为云部署</h2><p>所有的一切按照以前的来进行多么的轻松又愉快. 当然是假的, 主要是我又尝试更改了一些其他的配置之类的, 但是很遗憾, 总是出错, 当时debug了一个下午, 但是到最后才发现, 一是浏览器缓存的问题, 还有就是配置文件中有拼写错误. 如今, 想再截取当时的错误进行展示还是有些麻烦了, 所以最多口述一下吧.</p>\n<p>由于更改了配置中的相关字段, 但是还是造成了拼写错误, 所以没有办法正常渲染出相关css, 最后导致只有文字和ico的显示. 虽然在后面, 我又重新进行了更改, 但是发现服务器返回的还是同样的结果. 通过之前学习的知识, 想到, 可能是浏览器自带的缓存功能导致, 通过禁用缓存重新进行加载完成了正常显示. 同时, 由于我如今已经对网络有了一定了解. 我发现了为什么我以前的背景总是无法加载, 在于背景图片的选择过大, 同时服务器带宽较小, 其实并不是没法加载, 只是加载的实在是太慢了.  :sweat_smile:</p>\n"},{"title":"手写RPC框架学习","date":"2025-05-05T06:12:50.000Z","updated":"2025-05-06T11:56:52.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"noticeOutdate":null,"_content":"\n# 手写RPC框架学习\n\n## 什么是RPC\n\nRPC(Remote Procedure Call)从字面意思就是远程程序请求, 我的理解就是, 将能够分离的服务进行解耦合, 暴露出接口, 让其他服务能够通过网络直接请求调用. 能够降低服务之间的耦合度, 防止崩溃, 同时提高服务的可维护程度.\n\n通过RPC框架甚至不需要构建http请求, 相当与是RPC框架提供了一个方法, 隐藏了构建http请求的过程, 只需要关注传入的参数, 和传回的数据就足够了.\n\n![](img/RPC流程图.png)\n\n## 关于RPC的一些问题\n\n目前我理解的RPC框架相当于是一个引入的包, 通过调用相关的方法就能够直接访问相关的服务, 当然对于服务方应该也是使用相同的协议的.\n\n写RPC框架就像是在写一个现成的包一样, 其他服务通过应用这个包, 然后使用这个包中的工具, 就可以实现RPC的功能.\n\n## yu-RPC简易版\n\n### 初始化结构\n\n构建了四个模块exam-consumer,exam-provider, example-common, yu-rpc-easy. 取模拟三个端口, 其中的common模块相当于是公共模块,  使用rpc框架构成服务, 在消费者和生产者之间提供桥梁, 相当与中间注册机. \n\n### common\n\n模块中编写User类实现Serializable接口, 该接口包含了 将数据进行序列化的方法, 节省开发时间.\n\n在接口服务中定义getUser接口,\n\n### 关于Java的一些包\n\n#### lombok\n\n​\tlombok会提供一些代码的模板, 通过调用相关的注解自动生成一些方法. 在Java开发中, 会统一为一个方法开发set和get方法, 但是这些方法其实比较固定, 只需要固定生成就行, 通过应用lombok包中的@Getter等注解就可以快速生成.\n\n#### hutool\n\n​\thutool就相当一个工具包, 集成了许多可以用到的工具, 方便开发, 提升开发者的开发效率.\n\n### RPC框架中provider方面\n\nRPC服务中, 其实是否为privider提供创建服务器, 觉得可能还是很重要的, 为的就是有一个统一的协议.\n\n注册中心和本地注册器的区别. 本地注册器是用于管理本地的注册方法的, 接受请求,分析请求的方法然后调用处理. 注册中心的作用是将获得的请求, 转发给合适的provider.\n\n本项目中用到了很多Vertx框架下的知识, 对该框架还并不是非常熟悉. \n\n​\t要注意RPC框架是提供给开发者使用的，不论是consumer还是provider,都是开发者，其作用只是将两个服务解耦，而非是产品服务。通过在开发中，双方引入common模块，将一些注册信息。\n​\tconsumer通过RPC框架提供的方法将参数包装成请求，通过common中提供的一些注册信息选择服务。provider解析到本地注册器，处理完数据后，通过response返回数据。\n\n### 全局配置的添加\n\n在RPC框架包中添加, 配置文件.properties, 同时定义一个相应的.class对象接收它. 在RpcApplication中定义了一个全局变量(volatile) RpcConfig. 同时定义了两个init方法, 分别代表默认配置和自定义配置. 再定义了一个getConfig的方法, 获取config. 这些变量和方法都是static类型, 当包引用时就可以直接调用, 无需创建相关的的.class对象.\n\n### mock服务的添加\n\n#### 目前我理解的mock服务\n\n其实在api测试中也已经用到了mock. 当时相当于是接口需要构造相关的请求, 填写参数, 然后模拟正常的接口请求. 在RPC中的mock估计远不止于此. 由于是一个服务向另一个服务发送请求, 当另一个服务还没有开发完成的时候, 直接通过RPC向其请求肯定是没有用的. 但是RPC框架带来的, 就是只需要关注参数和返回, 而不需要具体的实现. 只需要能够模拟参数和返回即可. mock相当于就是构造了一个接收和返回的功能. 其返回的数据是, 预期中正确的示例数据.  主要作用是为了能够测试当前编写的模块能否正常运行.\n\n### 关于consumer端的服务代理\n\nRPC框架相当于是consumer与provider之间协商的一个协议. 两者都会应用common模块. 在common模块中, 包含这一些接口. 不同的是, 对于provider需要实现这些抽象类的接口, 而consumer是直接调用这其中的接口.\n光有包含接口的模块肯定是无法运行的, 所以需要相关的实现类. 但是如果直接将provider编写的Impl粘贴过来也就不需要RPC了. 所以在consumer端需要的是编写代理类去实现这个接口, 也就是在consumer端, 这个接口的实现不会是处理相关的数据, 而只是构造了一个网络请求, 将参数发送到provider那去.\n\n#### 静态请求\n\n就是直接根据信息构造请求, 但是这样做的话工作量太大. 应该将能够固定程式化的部分尽可能的固定.比如用户只需要关注传入参数即可. \n对于一个请求最重要的无非一下几点\n\n1. 服务提供商的相关信息\n2. 需要调用的服务名称\n3. 提供的参数\n\n返回的结果为\n\n1. 返回数据的类型\n2. 返回的数据\n\n所以将返回的数据正确绑定会数据类型即可.\n这样就完成了一次服务代理.\n服务请求商的信息由config文件提供, 调用服务的名称由用户输入, 在common模块中, 参数有用户提供.中间请求的构造, 有proxy类实现. \n\n### java SPI\n\n应该可以认为是java开发者中默认的一种开发模式. 所以在使用maven创建的项目中, ServiceLoader会自动加载在resources/META-INF下的的service文件. 当然加载的是引入依赖jar包下的配置文件.\n\n要注意Serializer只是其中的一个包, 可以通过加载不同类型的SPI包, 进行调用.\n\n### 序列化器与SPI总结\n\n使用不同的序列化器可以获得不同的性能, 使用者可以根据业务需求调用不同的序列化器进行传输数据.\n通过一个SPILoader将所有SPI接口载入, 再通过相关配置文件读取到实现类存储的路径, 将其class文件加载进map中, 通过在具体使用时, 通过反射, 将其实例化,进行调用.\n\n### 一个小bug\n\n在编写的时候会使用到一个注解`@slf4j`这是一个日志库, 用于快速的编写一些日志语句. 但是需要在项目中引入包, 但是在项目中一开始我引入的是`slf4j-api`, 其实就只是引入了接口, 还需要引入相关的实现包对接口进行实现.\n\n## 注册中心\n\n同一个服务, 可以有不同的提供者, 一方面可以减轻服务提供者的压力, 另一方面也可以根据选择不同服务者, 保障服务的稳定.\n\n其本质就是要在发送RPC请求时, 确认, 应该将这个请求发送给谁. 通过询问注册中心, 进行合理的请求.\n\n对于etcd的管理, 和mysql有点不一样. 其本质就是一个大型的树形结构. 这个树形结构只在叶子节点存储数据. 同时就它提供的几个操作脚本也让我觉得它的操作逻辑有点不一样. etcd脚本只是启动了相关的服务, 而需要使用etcdctl脚本进行交互, 还有一个脚本进行测试好像. 和其他服务启动后会有个 shell不是很一样. 感觉也体现了它的轻量化吗?\n\n在使用jetcd操作时, 一开始的逻辑有些让我看不懂. \n\n```java\nprivate Client client;\nprivate KV kvClient;\n```\n\n两个client属实让我没有见过. 因为一般服务都是直接通过不同的命令进行不同的功能的. 通过仔细阅读下面的代码才能理解其中一二.\n\n```java\n\t/**\n     * 创建一个etcd的client端与etcd服务端进行交互\n     * 这个client相当于是一个总的交互客户端. 和其设计思路有关.\n     * 比如直接通过etcd启动的就是服务, 而需要通过etcdctl脚本才能进行值交互.\n     * 通过client获取kvclient, leaseclient这些特殊工作的client\n     */\n    private Client client;\n\n    /**\n     * 由于很多的方法都需要使用到kvclient(应该也就是设置键值对的交互client)所以选择将这个client设置成了一个类变量\n     */\n    private KV kvClient;\n\n/**\n*从这个init中可以看出, client相当于是一个交互的总窗口, 可以通过这个交互窗口创建不同功能的代理.\n*/\n\t@Override\n    public void init(RegistryConfig registryConfig) {\n        client = Client.builder().endpoints(registryConfig.getAddress())\n                .connectTimeout(Duration.ofMillis(registryConfig.getTimeout())) //使用Duration将Long转化为Millis单位毫秒\n                .build();\n        kvClient = client.getKVClient();\n    }\n```\n\n","source":"_posts/手写RPC框架学习.md","raw":"---\ntitle: 手写RPC框架学习\ndate: 2025-05-05 14:12:50\nupdated: 2025-05-06 19:56:52\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\nnoticeOutdate:\n---\n\n# 手写RPC框架学习\n\n## 什么是RPC\n\nRPC(Remote Procedure Call)从字面意思就是远程程序请求, 我的理解就是, 将能够分离的服务进行解耦合, 暴露出接口, 让其他服务能够通过网络直接请求调用. 能够降低服务之间的耦合度, 防止崩溃, 同时提高服务的可维护程度.\n\n通过RPC框架甚至不需要构建http请求, 相当与是RPC框架提供了一个方法, 隐藏了构建http请求的过程, 只需要关注传入的参数, 和传回的数据就足够了.\n\n![](img/RPC流程图.png)\n\n## 关于RPC的一些问题\n\n目前我理解的RPC框架相当于是一个引入的包, 通过调用相关的方法就能够直接访问相关的服务, 当然对于服务方应该也是使用相同的协议的.\n\n写RPC框架就像是在写一个现成的包一样, 其他服务通过应用这个包, 然后使用这个包中的工具, 就可以实现RPC的功能.\n\n## yu-RPC简易版\n\n### 初始化结构\n\n构建了四个模块exam-consumer,exam-provider, example-common, yu-rpc-easy. 取模拟三个端口, 其中的common模块相当于是公共模块,  使用rpc框架构成服务, 在消费者和生产者之间提供桥梁, 相当与中间注册机. \n\n### common\n\n模块中编写User类实现Serializable接口, 该接口包含了 将数据进行序列化的方法, 节省开发时间.\n\n在接口服务中定义getUser接口,\n\n### 关于Java的一些包\n\n#### lombok\n\n​\tlombok会提供一些代码的模板, 通过调用相关的注解自动生成一些方法. 在Java开发中, 会统一为一个方法开发set和get方法, 但是这些方法其实比较固定, 只需要固定生成就行, 通过应用lombok包中的@Getter等注解就可以快速生成.\n\n#### hutool\n\n​\thutool就相当一个工具包, 集成了许多可以用到的工具, 方便开发, 提升开发者的开发效率.\n\n### RPC框架中provider方面\n\nRPC服务中, 其实是否为privider提供创建服务器, 觉得可能还是很重要的, 为的就是有一个统一的协议.\n\n注册中心和本地注册器的区别. 本地注册器是用于管理本地的注册方法的, 接受请求,分析请求的方法然后调用处理. 注册中心的作用是将获得的请求, 转发给合适的provider.\n\n本项目中用到了很多Vertx框架下的知识, 对该框架还并不是非常熟悉. \n\n​\t要注意RPC框架是提供给开发者使用的，不论是consumer还是provider,都是开发者，其作用只是将两个服务解耦，而非是产品服务。通过在开发中，双方引入common模块，将一些注册信息。\n​\tconsumer通过RPC框架提供的方法将参数包装成请求，通过common中提供的一些注册信息选择服务。provider解析到本地注册器，处理完数据后，通过response返回数据。\n\n### 全局配置的添加\n\n在RPC框架包中添加, 配置文件.properties, 同时定义一个相应的.class对象接收它. 在RpcApplication中定义了一个全局变量(volatile) RpcConfig. 同时定义了两个init方法, 分别代表默认配置和自定义配置. 再定义了一个getConfig的方法, 获取config. 这些变量和方法都是static类型, 当包引用时就可以直接调用, 无需创建相关的的.class对象.\n\n### mock服务的添加\n\n#### 目前我理解的mock服务\n\n其实在api测试中也已经用到了mock. 当时相当于是接口需要构造相关的请求, 填写参数, 然后模拟正常的接口请求. 在RPC中的mock估计远不止于此. 由于是一个服务向另一个服务发送请求, 当另一个服务还没有开发完成的时候, 直接通过RPC向其请求肯定是没有用的. 但是RPC框架带来的, 就是只需要关注参数和返回, 而不需要具体的实现. 只需要能够模拟参数和返回即可. mock相当于就是构造了一个接收和返回的功能. 其返回的数据是, 预期中正确的示例数据.  主要作用是为了能够测试当前编写的模块能否正常运行.\n\n### 关于consumer端的服务代理\n\nRPC框架相当于是consumer与provider之间协商的一个协议. 两者都会应用common模块. 在common模块中, 包含这一些接口. 不同的是, 对于provider需要实现这些抽象类的接口, 而consumer是直接调用这其中的接口.\n光有包含接口的模块肯定是无法运行的, 所以需要相关的实现类. 但是如果直接将provider编写的Impl粘贴过来也就不需要RPC了. 所以在consumer端需要的是编写代理类去实现这个接口, 也就是在consumer端, 这个接口的实现不会是处理相关的数据, 而只是构造了一个网络请求, 将参数发送到provider那去.\n\n#### 静态请求\n\n就是直接根据信息构造请求, 但是这样做的话工作量太大. 应该将能够固定程式化的部分尽可能的固定.比如用户只需要关注传入参数即可. \n对于一个请求最重要的无非一下几点\n\n1. 服务提供商的相关信息\n2. 需要调用的服务名称\n3. 提供的参数\n\n返回的结果为\n\n1. 返回数据的类型\n2. 返回的数据\n\n所以将返回的数据正确绑定会数据类型即可.\n这样就完成了一次服务代理.\n服务请求商的信息由config文件提供, 调用服务的名称由用户输入, 在common模块中, 参数有用户提供.中间请求的构造, 有proxy类实现. \n\n### java SPI\n\n应该可以认为是java开发者中默认的一种开发模式. 所以在使用maven创建的项目中, ServiceLoader会自动加载在resources/META-INF下的的service文件. 当然加载的是引入依赖jar包下的配置文件.\n\n要注意Serializer只是其中的一个包, 可以通过加载不同类型的SPI包, 进行调用.\n\n### 序列化器与SPI总结\n\n使用不同的序列化器可以获得不同的性能, 使用者可以根据业务需求调用不同的序列化器进行传输数据.\n通过一个SPILoader将所有SPI接口载入, 再通过相关配置文件读取到实现类存储的路径, 将其class文件加载进map中, 通过在具体使用时, 通过反射, 将其实例化,进行调用.\n\n### 一个小bug\n\n在编写的时候会使用到一个注解`@slf4j`这是一个日志库, 用于快速的编写一些日志语句. 但是需要在项目中引入包, 但是在项目中一开始我引入的是`slf4j-api`, 其实就只是引入了接口, 还需要引入相关的实现包对接口进行实现.\n\n## 注册中心\n\n同一个服务, 可以有不同的提供者, 一方面可以减轻服务提供者的压力, 另一方面也可以根据选择不同服务者, 保障服务的稳定.\n\n其本质就是要在发送RPC请求时, 确认, 应该将这个请求发送给谁. 通过询问注册中心, 进行合理的请求.\n\n对于etcd的管理, 和mysql有点不一样. 其本质就是一个大型的树形结构. 这个树形结构只在叶子节点存储数据. 同时就它提供的几个操作脚本也让我觉得它的操作逻辑有点不一样. etcd脚本只是启动了相关的服务, 而需要使用etcdctl脚本进行交互, 还有一个脚本进行测试好像. 和其他服务启动后会有个 shell不是很一样. 感觉也体现了它的轻量化吗?\n\n在使用jetcd操作时, 一开始的逻辑有些让我看不懂. \n\n```java\nprivate Client client;\nprivate KV kvClient;\n```\n\n两个client属实让我没有见过. 因为一般服务都是直接通过不同的命令进行不同的功能的. 通过仔细阅读下面的代码才能理解其中一二.\n\n```java\n\t/**\n     * 创建一个etcd的client端与etcd服务端进行交互\n     * 这个client相当于是一个总的交互客户端. 和其设计思路有关.\n     * 比如直接通过etcd启动的就是服务, 而需要通过etcdctl脚本才能进行值交互.\n     * 通过client获取kvclient, leaseclient这些特殊工作的client\n     */\n    private Client client;\n\n    /**\n     * 由于很多的方法都需要使用到kvclient(应该也就是设置键值对的交互client)所以选择将这个client设置成了一个类变量\n     */\n    private KV kvClient;\n\n/**\n*从这个init中可以看出, client相当于是一个交互的总窗口, 可以通过这个交互窗口创建不同功能的代理.\n*/\n\t@Override\n    public void init(RegistryConfig registryConfig) {\n        client = Client.builder().endpoints(registryConfig.getAddress())\n                .connectTimeout(Duration.ofMillis(registryConfig.getTimeout())) //使用Duration将Long转化为Millis单位毫秒\n                .build();\n        kvClient = client.getKVClient();\n    }\n```\n\n","slug":"手写RPC框架学习","published":1,"layout":"post","photos":[],"_id":"cmafjaxag0005vpx52fs68oja","content":"<h1 id=\"手写RPC框架学习\"><a href=\"#手写RPC框架学习\" class=\"headerlink\" title=\"手写RPC框架学习\"></a>手写RPC框架学习</h1><h2 id=\"什么是RPC\"><a href=\"#什么是RPC\" class=\"headerlink\" title=\"什么是RPC\"></a>什么是RPC</h2><p>RPC(Remote Procedure Call)从字面意思就是远程程序请求, 我的理解就是, 将能够分离的服务进行解耦合, 暴露出接口, 让其他服务能够通过网络直接请求调用. 能够降低服务之间的耦合度, 防止崩溃, 同时提高服务的可维护程度.</p>\n<p>通过RPC框架甚至不需要构建http请求, 相当与是RPC框架提供了一个方法, 隐藏了构建http请求的过程, 只需要关注传入的参数, 和传回的数据就足够了.</p>\n<p><img src=\"/img/RPC%E6%B5%81%E7%A8%8B%E5%9B%BE.png\"></p>\n<h2 id=\"关于RPC的一些问题\"><a href=\"#关于RPC的一些问题\" class=\"headerlink\" title=\"关于RPC的一些问题\"></a>关于RPC的一些问题</h2><p>目前我理解的RPC框架相当于是一个引入的包, 通过调用相关的方法就能够直接访问相关的服务, 当然对于服务方应该也是使用相同的协议的.</p>\n<p>写RPC框架就像是在写一个现成的包一样, 其他服务通过应用这个包, 然后使用这个包中的工具, 就可以实现RPC的功能.</p>\n<h2 id=\"yu-RPC简易版\"><a href=\"#yu-RPC简易版\" class=\"headerlink\" title=\"yu-RPC简易版\"></a>yu-RPC简易版</h2><h3 id=\"初始化结构\"><a href=\"#初始化结构\" class=\"headerlink\" title=\"初始化结构\"></a>初始化结构</h3><p>构建了四个模块exam-consumer,exam-provider, example-common, yu-rpc-easy. 取模拟三个端口, 其中的common模块相当于是公共模块,  使用rpc框架构成服务, 在消费者和生产者之间提供桥梁, 相当与中间注册机. </p>\n<h3 id=\"common\"><a href=\"#common\" class=\"headerlink\" title=\"common\"></a>common</h3><p>模块中编写User类实现Serializable接口, 该接口包含了 将数据进行序列化的方法, 节省开发时间.</p>\n<p>在接口服务中定义getUser接口,</p>\n<h3 id=\"关于Java的一些包\"><a href=\"#关于Java的一些包\" class=\"headerlink\" title=\"关于Java的一些包\"></a>关于Java的一些包</h3><h4 id=\"lombok\"><a href=\"#lombok\" class=\"headerlink\" title=\"lombok\"></a>lombok</h4><p>​\tlombok会提供一些代码的模板, 通过调用相关的注解自动生成一些方法. 在Java开发中, 会统一为一个方法开发set和get方法, 但是这些方法其实比较固定, 只需要固定生成就行, 通过应用lombok包中的@Getter等注解就可以快速生成.</p>\n<h4 id=\"hutool\"><a href=\"#hutool\" class=\"headerlink\" title=\"hutool\"></a>hutool</h4><p>​\thutool就相当一个工具包, 集成了许多可以用到的工具, 方便开发, 提升开发者的开发效率.</p>\n<h3 id=\"RPC框架中provider方面\"><a href=\"#RPC框架中provider方面\" class=\"headerlink\" title=\"RPC框架中provider方面\"></a>RPC框架中provider方面</h3><p>RPC服务中, 其实是否为privider提供创建服务器, 觉得可能还是很重要的, 为的就是有一个统一的协议.</p>\n<p>注册中心和本地注册器的区别. 本地注册器是用于管理本地的注册方法的, 接受请求,分析请求的方法然后调用处理. 注册中心的作用是将获得的请求, 转发给合适的provider.</p>\n<p>本项目中用到了很多Vertx框架下的知识, 对该框架还并不是非常熟悉. </p>\n<p>​\t要注意RPC框架是提供给开发者使用的，不论是consumer还是provider,都是开发者，其作用只是将两个服务解耦，而非是产品服务。通过在开发中，双方引入common模块，将一些注册信息。<br>​\tconsumer通过RPC框架提供的方法将参数包装成请求，通过common中提供的一些注册信息选择服务。provider解析到本地注册器，处理完数据后，通过response返回数据。</p>\n<h3 id=\"全局配置的添加\"><a href=\"#全局配置的添加\" class=\"headerlink\" title=\"全局配置的添加\"></a>全局配置的添加</h3><p>在RPC框架包中添加, 配置文件.properties, 同时定义一个相应的.class对象接收它. 在RpcApplication中定义了一个全局变量(volatile) RpcConfig. 同时定义了两个init方法, 分别代表默认配置和自定义配置. 再定义了一个getConfig的方法, 获取config. 这些变量和方法都是static类型, 当包引用时就可以直接调用, 无需创建相关的的.class对象.</p>\n<h3 id=\"mock服务的添加\"><a href=\"#mock服务的添加\" class=\"headerlink\" title=\"mock服务的添加\"></a>mock服务的添加</h3><h4 id=\"目前我理解的mock服务\"><a href=\"#目前我理解的mock服务\" class=\"headerlink\" title=\"目前我理解的mock服务\"></a>目前我理解的mock服务</h4><p>其实在api测试中也已经用到了mock. 当时相当于是接口需要构造相关的请求, 填写参数, 然后模拟正常的接口请求. 在RPC中的mock估计远不止于此. 由于是一个服务向另一个服务发送请求, 当另一个服务还没有开发完成的时候, 直接通过RPC向其请求肯定是没有用的. 但是RPC框架带来的, 就是只需要关注参数和返回, 而不需要具体的实现. 只需要能够模拟参数和返回即可. mock相当于就是构造了一个接收和返回的功能. 其返回的数据是, 预期中正确的示例数据.  主要作用是为了能够测试当前编写的模块能否正常运行.</p>\n<h3 id=\"关于consumer端的服务代理\"><a href=\"#关于consumer端的服务代理\" class=\"headerlink\" title=\"关于consumer端的服务代理\"></a>关于consumer端的服务代理</h3><p>RPC框架相当于是consumer与provider之间协商的一个协议. 两者都会应用common模块. 在common模块中, 包含这一些接口. 不同的是, 对于provider需要实现这些抽象类的接口, 而consumer是直接调用这其中的接口.<br>光有包含接口的模块肯定是无法运行的, 所以需要相关的实现类. 但是如果直接将provider编写的Impl粘贴过来也就不需要RPC了. 所以在consumer端需要的是编写代理类去实现这个接口, 也就是在consumer端, 这个接口的实现不会是处理相关的数据, 而只是构造了一个网络请求, 将参数发送到provider那去.</p>\n<h4 id=\"静态请求\"><a href=\"#静态请求\" class=\"headerlink\" title=\"静态请求\"></a>静态请求</h4><p>就是直接根据信息构造请求, 但是这样做的话工作量太大. 应该将能够固定程式化的部分尽可能的固定.比如用户只需要关注传入参数即可.<br>对于一个请求最重要的无非一下几点</p>\n<ol>\n<li>服务提供商的相关信息</li>\n<li>需要调用的服务名称</li>\n<li>提供的参数</li>\n</ol>\n<p>返回的结果为</p>\n<ol>\n<li>返回数据的类型</li>\n<li>返回的数据</li>\n</ol>\n<p>所以将返回的数据正确绑定会数据类型即可.<br>这样就完成了一次服务代理.<br>服务请求商的信息由config文件提供, 调用服务的名称由用户输入, 在common模块中, 参数有用户提供.中间请求的构造, 有proxy类实现. </p>\n<h3 id=\"java-SPI\"><a href=\"#java-SPI\" class=\"headerlink\" title=\"java SPI\"></a>java SPI</h3><p>应该可以认为是java开发者中默认的一种开发模式. 所以在使用maven创建的项目中, ServiceLoader会自动加载在resources&#x2F;META-INF下的的service文件. 当然加载的是引入依赖jar包下的配置文件.</p>\n<p>要注意Serializer只是其中的一个包, 可以通过加载不同类型的SPI包, 进行调用.</p>\n<h3 id=\"序列化器与SPI总结\"><a href=\"#序列化器与SPI总结\" class=\"headerlink\" title=\"序列化器与SPI总结\"></a>序列化器与SPI总结</h3><p>使用不同的序列化器可以获得不同的性能, 使用者可以根据业务需求调用不同的序列化器进行传输数据.<br>通过一个SPILoader将所有SPI接口载入, 再通过相关配置文件读取到实现类存储的路径, 将其class文件加载进map中, 通过在具体使用时, 通过反射, 将其实例化,进行调用.</p>\n<h3 id=\"一个小bug\"><a href=\"#一个小bug\" class=\"headerlink\" title=\"一个小bug\"></a>一个小bug</h3><p>在编写的时候会使用到一个注解<code>@slf4j</code>这是一个日志库, 用于快速的编写一些日志语句. 但是需要在项目中引入包, 但是在项目中一开始我引入的是<code>slf4j-api</code>, 其实就只是引入了接口, 还需要引入相关的实现包对接口进行实现.</p>\n<h2 id=\"注册中心\"><a href=\"#注册中心\" class=\"headerlink\" title=\"注册中心\"></a>注册中心</h2><p>同一个服务, 可以有不同的提供者, 一方面可以减轻服务提供者的压力, 另一方面也可以根据选择不同服务者, 保障服务的稳定.</p>\n<p>其本质就是要在发送RPC请求时, 确认, 应该将这个请求发送给谁. 通过询问注册中心, 进行合理的请求.</p>\n<p>对于etcd的管理, 和mysql有点不一样. 其本质就是一个大型的树形结构. 这个树形结构只在叶子节点存储数据. 同时就它提供的几个操作脚本也让我觉得它的操作逻辑有点不一样. etcd脚本只是启动了相关的服务, 而需要使用etcdctl脚本进行交互, 还有一个脚本进行测试好像. 和其他服务启动后会有个 shell不是很一样. 感觉也体现了它的轻量化吗?</p>\n<p>在使用jetcd操作时, 一开始的逻辑有些让我看不懂. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Client client;</span><br><span class=\"line\"><span class=\"keyword\">private</span> KV kvClient;</span><br></pre></td></tr></table></figure>\n\n<p>两个client属实让我没有见过. 因为一般服务都是直接通过不同的命令进行不同的功能的. 通过仔细阅读下面的代码才能理解其中一二.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建一个etcd的client端与etcd服务端进行交互</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个client相当于是一个总的交互客户端. 和其设计思路有关.</span></span><br><span class=\"line\"><span class=\"comment\">     * 比如直接通过etcd启动的就是服务, 而需要通过etcdctl脚本才能进行值交互.</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过client获取kvclient, leaseclient这些特殊工作的client</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client client;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 由于很多的方法都需要使用到kvclient(应该也就是设置键值对的交互client)所以选择将这个client设置成了一个类变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KV kvClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*从这个init中可以看出, client相当于是一个交互的总窗口, 可以通过这个交互窗口创建不同功能的代理.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(RegistryConfig registryConfig)</span> &#123;</span><br><span class=\"line\">        client = Client.builder().endpoints(registryConfig.getAddress())</span><br><span class=\"line\">                .connectTimeout(Duration.ofMillis(registryConfig.getTimeout())) <span class=\"comment\">//使用Duration将Long转化为Millis单位毫秒</span></span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        kvClient = client.getKVClient();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"手写RPC框架学习\"><a href=\"#手写RPC框架学习\" class=\"headerlink\" title=\"手写RPC框架学习\"></a>手写RPC框架学习</h1><h2 id=\"什么是RPC\"><a href=\"#什么是RPC\" class=\"headerlink\" title=\"什么是RPC\"></a>什么是RPC</h2><p>RPC(Remote Procedure Call)从字面意思就是远程程序请求, 我的理解就是, 将能够分离的服务进行解耦合, 暴露出接口, 让其他服务能够通过网络直接请求调用. 能够降低服务之间的耦合度, 防止崩溃, 同时提高服务的可维护程度.</p>\n<p>通过RPC框架甚至不需要构建http请求, 相当与是RPC框架提供了一个方法, 隐藏了构建http请求的过程, 只需要关注传入的参数, 和传回的数据就足够了.</p>\n<p><img src=\"/img/RPC%E6%B5%81%E7%A8%8B%E5%9B%BE.png\"></p>\n<h2 id=\"关于RPC的一些问题\"><a href=\"#关于RPC的一些问题\" class=\"headerlink\" title=\"关于RPC的一些问题\"></a>关于RPC的一些问题</h2><p>目前我理解的RPC框架相当于是一个引入的包, 通过调用相关的方法就能够直接访问相关的服务, 当然对于服务方应该也是使用相同的协议的.</p>\n<p>写RPC框架就像是在写一个现成的包一样, 其他服务通过应用这个包, 然后使用这个包中的工具, 就可以实现RPC的功能.</p>\n<h2 id=\"yu-RPC简易版\"><a href=\"#yu-RPC简易版\" class=\"headerlink\" title=\"yu-RPC简易版\"></a>yu-RPC简易版</h2><h3 id=\"初始化结构\"><a href=\"#初始化结构\" class=\"headerlink\" title=\"初始化结构\"></a>初始化结构</h3><p>构建了四个模块exam-consumer,exam-provider, example-common, yu-rpc-easy. 取模拟三个端口, 其中的common模块相当于是公共模块,  使用rpc框架构成服务, 在消费者和生产者之间提供桥梁, 相当与中间注册机. </p>\n<h3 id=\"common\"><a href=\"#common\" class=\"headerlink\" title=\"common\"></a>common</h3><p>模块中编写User类实现Serializable接口, 该接口包含了 将数据进行序列化的方法, 节省开发时间.</p>\n<p>在接口服务中定义getUser接口,</p>\n<h3 id=\"关于Java的一些包\"><a href=\"#关于Java的一些包\" class=\"headerlink\" title=\"关于Java的一些包\"></a>关于Java的一些包</h3><h4 id=\"lombok\"><a href=\"#lombok\" class=\"headerlink\" title=\"lombok\"></a>lombok</h4><p>​\tlombok会提供一些代码的模板, 通过调用相关的注解自动生成一些方法. 在Java开发中, 会统一为一个方法开发set和get方法, 但是这些方法其实比较固定, 只需要固定生成就行, 通过应用lombok包中的@Getter等注解就可以快速生成.</p>\n<h4 id=\"hutool\"><a href=\"#hutool\" class=\"headerlink\" title=\"hutool\"></a>hutool</h4><p>​\thutool就相当一个工具包, 集成了许多可以用到的工具, 方便开发, 提升开发者的开发效率.</p>\n<h3 id=\"RPC框架中provider方面\"><a href=\"#RPC框架中provider方面\" class=\"headerlink\" title=\"RPC框架中provider方面\"></a>RPC框架中provider方面</h3><p>RPC服务中, 其实是否为privider提供创建服务器, 觉得可能还是很重要的, 为的就是有一个统一的协议.</p>\n<p>注册中心和本地注册器的区别. 本地注册器是用于管理本地的注册方法的, 接受请求,分析请求的方法然后调用处理. 注册中心的作用是将获得的请求, 转发给合适的provider.</p>\n<p>本项目中用到了很多Vertx框架下的知识, 对该框架还并不是非常熟悉. </p>\n<p>​\t要注意RPC框架是提供给开发者使用的，不论是consumer还是provider,都是开发者，其作用只是将两个服务解耦，而非是产品服务。通过在开发中，双方引入common模块，将一些注册信息。<br>​\tconsumer通过RPC框架提供的方法将参数包装成请求，通过common中提供的一些注册信息选择服务。provider解析到本地注册器，处理完数据后，通过response返回数据。</p>\n<h3 id=\"全局配置的添加\"><a href=\"#全局配置的添加\" class=\"headerlink\" title=\"全局配置的添加\"></a>全局配置的添加</h3><p>在RPC框架包中添加, 配置文件.properties, 同时定义一个相应的.class对象接收它. 在RpcApplication中定义了一个全局变量(volatile) RpcConfig. 同时定义了两个init方法, 分别代表默认配置和自定义配置. 再定义了一个getConfig的方法, 获取config. 这些变量和方法都是static类型, 当包引用时就可以直接调用, 无需创建相关的的.class对象.</p>\n<h3 id=\"mock服务的添加\"><a href=\"#mock服务的添加\" class=\"headerlink\" title=\"mock服务的添加\"></a>mock服务的添加</h3><h4 id=\"目前我理解的mock服务\"><a href=\"#目前我理解的mock服务\" class=\"headerlink\" title=\"目前我理解的mock服务\"></a>目前我理解的mock服务</h4><p>其实在api测试中也已经用到了mock. 当时相当于是接口需要构造相关的请求, 填写参数, 然后模拟正常的接口请求. 在RPC中的mock估计远不止于此. 由于是一个服务向另一个服务发送请求, 当另一个服务还没有开发完成的时候, 直接通过RPC向其请求肯定是没有用的. 但是RPC框架带来的, 就是只需要关注参数和返回, 而不需要具体的实现. 只需要能够模拟参数和返回即可. mock相当于就是构造了一个接收和返回的功能. 其返回的数据是, 预期中正确的示例数据.  主要作用是为了能够测试当前编写的模块能否正常运行.</p>\n<h3 id=\"关于consumer端的服务代理\"><a href=\"#关于consumer端的服务代理\" class=\"headerlink\" title=\"关于consumer端的服务代理\"></a>关于consumer端的服务代理</h3><p>RPC框架相当于是consumer与provider之间协商的一个协议. 两者都会应用common模块. 在common模块中, 包含这一些接口. 不同的是, 对于provider需要实现这些抽象类的接口, 而consumer是直接调用这其中的接口.<br>光有包含接口的模块肯定是无法运行的, 所以需要相关的实现类. 但是如果直接将provider编写的Impl粘贴过来也就不需要RPC了. 所以在consumer端需要的是编写代理类去实现这个接口, 也就是在consumer端, 这个接口的实现不会是处理相关的数据, 而只是构造了一个网络请求, 将参数发送到provider那去.</p>\n<h4 id=\"静态请求\"><a href=\"#静态请求\" class=\"headerlink\" title=\"静态请求\"></a>静态请求</h4><p>就是直接根据信息构造请求, 但是这样做的话工作量太大. 应该将能够固定程式化的部分尽可能的固定.比如用户只需要关注传入参数即可.<br>对于一个请求最重要的无非一下几点</p>\n<ol>\n<li>服务提供商的相关信息</li>\n<li>需要调用的服务名称</li>\n<li>提供的参数</li>\n</ol>\n<p>返回的结果为</p>\n<ol>\n<li>返回数据的类型</li>\n<li>返回的数据</li>\n</ol>\n<p>所以将返回的数据正确绑定会数据类型即可.<br>这样就完成了一次服务代理.<br>服务请求商的信息由config文件提供, 调用服务的名称由用户输入, 在common模块中, 参数有用户提供.中间请求的构造, 有proxy类实现. </p>\n<h3 id=\"java-SPI\"><a href=\"#java-SPI\" class=\"headerlink\" title=\"java SPI\"></a>java SPI</h3><p>应该可以认为是java开发者中默认的一种开发模式. 所以在使用maven创建的项目中, ServiceLoader会自动加载在resources&#x2F;META-INF下的的service文件. 当然加载的是引入依赖jar包下的配置文件.</p>\n<p>要注意Serializer只是其中的一个包, 可以通过加载不同类型的SPI包, 进行调用.</p>\n<h3 id=\"序列化器与SPI总结\"><a href=\"#序列化器与SPI总结\" class=\"headerlink\" title=\"序列化器与SPI总结\"></a>序列化器与SPI总结</h3><p>使用不同的序列化器可以获得不同的性能, 使用者可以根据业务需求调用不同的序列化器进行传输数据.<br>通过一个SPILoader将所有SPI接口载入, 再通过相关配置文件读取到实现类存储的路径, 将其class文件加载进map中, 通过在具体使用时, 通过反射, 将其实例化,进行调用.</p>\n<h3 id=\"一个小bug\"><a href=\"#一个小bug\" class=\"headerlink\" title=\"一个小bug\"></a>一个小bug</h3><p>在编写的时候会使用到一个注解<code>@slf4j</code>这是一个日志库, 用于快速的编写一些日志语句. 但是需要在项目中引入包, 但是在项目中一开始我引入的是<code>slf4j-api</code>, 其实就只是引入了接口, 还需要引入相关的实现包对接口进行实现.</p>\n<h2 id=\"注册中心\"><a href=\"#注册中心\" class=\"headerlink\" title=\"注册中心\"></a>注册中心</h2><p>同一个服务, 可以有不同的提供者, 一方面可以减轻服务提供者的压力, 另一方面也可以根据选择不同服务者, 保障服务的稳定.</p>\n<p>其本质就是要在发送RPC请求时, 确认, 应该将这个请求发送给谁. 通过询问注册中心, 进行合理的请求.</p>\n<p>对于etcd的管理, 和mysql有点不一样. 其本质就是一个大型的树形结构. 这个树形结构只在叶子节点存储数据. 同时就它提供的几个操作脚本也让我觉得它的操作逻辑有点不一样. etcd脚本只是启动了相关的服务, 而需要使用etcdctl脚本进行交互, 还有一个脚本进行测试好像. 和其他服务启动后会有个 shell不是很一样. 感觉也体现了它的轻量化吗?</p>\n<p>在使用jetcd操作时, 一开始的逻辑有些让我看不懂. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Client client;</span><br><span class=\"line\"><span class=\"keyword\">private</span> KV kvClient;</span><br></pre></td></tr></table></figure>\n\n<p>两个client属实让我没有见过. 因为一般服务都是直接通过不同的命令进行不同的功能的. 通过仔细阅读下面的代码才能理解其中一二.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建一个etcd的client端与etcd服务端进行交互</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个client相当于是一个总的交互客户端. 和其设计思路有关.</span></span><br><span class=\"line\"><span class=\"comment\">     * 比如直接通过etcd启动的就是服务, 而需要通过etcdctl脚本才能进行值交互.</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过client获取kvclient, leaseclient这些特殊工作的client</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client client;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 由于很多的方法都需要使用到kvclient(应该也就是设置键值对的交互client)所以选择将这个client设置成了一个类变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KV kvClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*从这个init中可以看出, client相当于是一个交互的总窗口, 可以通过这个交互窗口创建不同功能的代理.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(RegistryConfig registryConfig)</span> &#123;</span><br><span class=\"line\">        client = Client.builder().endpoints(registryConfig.getAddress())</span><br><span class=\"line\">                .connectTimeout(Duration.ofMillis(registryConfig.getTimeout())) <span class=\"comment\">//使用Duration将Long转化为Millis单位毫秒</span></span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        kvClient = client.getKVClient();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"杭电助手后端二面经历","date":"2025-03-05T06:06:58.000Z","updated":"2025-05-06T11:56:52.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"noticeOutdate":null,"_content":"\n# 杭电助手后端二面经历\n\n在杭电助手的开发是基于Go语言的. 对于程序来说, 其实用什么语言写的对于程序员的影响只局限于对语言的熟悉程度和开发的效率. 所以, 虽然在此之前, 我对Go语言的涉猎只局限于安装和运行了Helloworld. 这次的二面项目的构建, 是一个很好的机会, 让我去熟悉Go语言的应用, 这与当今许多公司的后端开发相关性非常强.\n\n\n\n## Go语言的初步认识\n\n在我的印象中, Go语言的介绍是为了能够综合Java多平台和C++高粒度创造出的语言, 同时也摈弃了一些这两种语言的弊端, 作为一种新兴的语言, 在很多公司的后端开发中都得到了大规模的应用.\n\n作为之中面向对象的语言, Go语言虽然目前我并没有学到他的类, 但是, 从最开始的mod来说, Go应该是基于一个包与包之间相互调用进行运行的. 当我在一个项目的文件加下, 同时写了两个main函数的时候, 语言会提示报错. \n\n对于Go语言来说，每个包中的方法都是以大写字母开头的， 如果不是大写字母开头的就不是包的导出名字。虽然目前我还不了解，这个导出与未导出的区别是什么，也许是一个方法是这个包private还是public的区别吧. (雾)\n\n变量名在数据类型的前面, 这也许是Go语言的特性吧.\n\n[关于Go语言字符风格]: https://blog.go-zh.org/gos-declaration-syntax\t\"Go&#39;s Declaration Syntax\"\n\n1. Go语言中的函数, 可以返回任意数量的返回值.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n//注意返回的顺序,输出的结果是\"world hello\"\n```\n\n2. Go语言中, 可一直直接定义返回值的名称, 在函数返回时直接写return就能根据返回变量名称的定义和函数内部相关变量名的值直接返回\n\n   ```go\n   package main\n   \n   import \"fmt\"\n   \n   func split(sum int) (x, y int) {\n   \tx = sum * 4 / 9\n   \ty = sum - x\n   \treturn\n   }\n   \n   func main() {\n   \tfmt.Println(split(17))\n   }\n   //相当于是x,y是直接在返回类型中定义的\n   ```\n\n   \n\n3. Go语言中的while循环都由for循环担任, 而且条件没有小括号的包裹\n\n4. if语句可以在执行条件判断前执行一个简短的语句*虽然我目前还不知道有什么用*, 同时,如果语句申明的是一个变量, 变量的作用域也只在这之中.  同时也在与其成对的else语句中存在. \n\n   ``` go\n   package main\n   \n   import (\n   \t\"fmt\"\n   \t\"math\"\n   )\n   \n   func pow(x, n, lim float64) float64 {\n   \tif v := math.Pow(x, n); v < lim {\n   \t\treturn v\n   \t}\n   \treturn lim\n   }\n   \n   func main() {\n   \tfmt.Println(\n   \t\tpow(3, 2, 10),\n   \t\tpow(3, 3, 20),\n   \t)\n   }\n   ```\n\n5. 在Go语言中的结构体，即使是对指针进行引用也是直接使用 '.' 进行引用。\n\n6. 使用range对for循环做遍历，每次会返回两个值，第一个是元素的下标，第二是元素的副本。这些可以通过一些语法手段进行忽略一些值的引用.\n\n   ```go\n   package main\n   \n   import \"fmt\"\n   \n   var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n   \n   func main() {\n   \tfor i, v := range pow {\n   \t\tfmt.Printf(\"2**%d = %d\\n\", i, v)\n   \t}\n   }\n   /*\n   output:\n   2**0 = 1\n   2**1 = 2\n   2**2 = 4\n   2**3 = 8\n   2**4 = 16\n   2**5 = 32\n   2**6 = 64\n   2**7 = 128\n   */\n   ```\n\n   \n\n## 从Gin项目开始构建\n\n从给出的文档来说，Gin对目前的我来说可能有点像nginx一样, 作为一个web端的服务器框架. 通过使用Gin的框架, 可以快速的部署Go的web项目.\n\n当跟着文档做出一个demo后, 我发现, Gin有点像我曾经的Hexo的本地预览一样, 可以打开本地的端口, 进行访问.\n\n所以在直接运行main.go后, 其实就是开启了一个web项目, 这时候, 再从gitbash的终端, 向本地发送请求,就像模拟了一次客户端向服务端发送请求服务的过程. 所以照理说, 直接通过shell终端应该也是可以访问的.\n\n通过验证, curl命令其实就是一个对URL发送请求的命令, 通过shell终端发送相同的命令, 得到了返回的相应报文, 同时, 其中的content内容为, 我在编写是写入的内容.\n\n## 关于docker的使用\n\n感觉在服务器上使用docker是件麻烦的事情，即使众所周知，在企业开发中，docker可以大大地节约开发的环境配置的时间，但是，我目前是在想不明白，如果对于docker来说，被在国内禁得这么惨，我这么多的换源都失效了，是在想不知道应该如何使用。\n\n## 从web应用开始开发\n\n对于从文档里面获得的知识感觉差不多了，纸上得来终觉浅。所以一到我现在开始实际上手开发就有点不知道该做什么了。\n\n通过Gin的框架构建的web应用，目前知道了是如何启动，但是我不明白其中的原理，我没有办法在其基础上做出拓展。\n\n## 关于mysql数据库的操作\n\n在这之前只是对mysql有了一定的初步了解，通过这些操作对mysql的用户管理和增删改查有了一些基本的认识。\n\n在为专门创建用来管理web数据库的用户'huning'@'%'赋予权限的时候, 遇到的'root'@'%'无法执行的操作, 通过搜索可知, 这是应为,我是通过DataGrip远程登录的数据库进行操作, 而对于'root'@'%'来说并没有赋予其他用户权限的权限. \n\n所以需要登录到'root'@'localhost'先对其进行权限的授予\n\n```sql\ngrant all privileges on *.* to 'root'@'%' with grant option\n// with grant option可以将权限授予其他的用户,虽然我不知道这样不写还能不能进行授予\n```\n\n通过引入相关的对于mysql处理的包文件, 就可以连接上数据库, 剩下的就是撰写相关的对于表结构的增删改查的函数了. 可以先通过做一些简单的案例进行尝试.\n\n## Go语言模块的测试\n\n在python中的测试模式, 现在想来确实简单不少, 其实联想c++其实模块的测试应该也是和Go语言一样需要有专门的测试模块. 但是其实我没怎么写过项目, 测试做的少所以就不是很熟悉了.\n\n在python中通常直接在运行相关的文件, 输入参数就可以直接运行写好的相关的接口函数.\n\n```python\ndef func() :\n    ******\n#这里开始其实就已经是对这个模块进行测试了，所以似乎简单的测试可以不用导入相关的测试模块进行\nif __name__ == '__main__':\n    \n```\n\n## 关于包管理\n\n在导入的包前面加上'_' , 表示当前导入的包并不使用. 提示是说将这个包视作的初始化. 但是目前还不理解这个初始化, 为什么是导入但不使用.\n\n## 关于函数\n\n对于函数来说, 需要保证需要引出的函数的开头字母是大写的, 说明这个函数是公开的, 如果是小写的说明这个函数是这文件私有的.\n\n这里算事解决了前面, 我遗留的为什么一个包的大写函数是引出名的问题.\n\n而且由于go语言是以包管理进行的, 所以, 在同一个包下,似乎可以视作是写在同一个文件下的.\n\n\n\n## 关于测试文件的编写\n\n一定要注意测试文件的命名,必须以'_test.go'结尾, 否则对于go的test来说, 这并不是一个test文件, 不会进行执行.\n\n当然在更改完这个错误后, 前面, 对于是否, 导入包的时候是对测试模块已经build了的包直接引用, 还是通过相关的源文件进行应用, 这个问题已经无法验证了, 必须要等到下次遇到再测试了.\n\n在编写链接函数\"ConnectMyDatabase\"中运用到了一个\"defer db.Close()\", 虽然我知道， 这个是在后面防止忘记关数据库的。但是确实第一次运用这语句还不太熟悉直接抄写了下了。但是由于我是通过调用一个相关的连接函数，后在进行操作的，所以我在连接函数中如果加入的这个语句，在我获取了链接后就直接将我的数据库连接关闭了，在删除数据库的连接后，通过构建测是模块，成功实现了，数据库中增加数据，剩下的删改查都是一样的套路，数据库相关的代码，之后就可以轻车熟路了。再次贴图见证成功操作数据库。![](.\\img\\QQ20241003-011900.png)\n\n## 关于路由的一些进一步理解（URL）\n\n对于一般的web服务，都运行在特定的主机上，同时，一个主机上可能还运行着其他的服务。\n\n主机的公网ip地址是能够通过ip协议向相关提供服务的主机发送服务请求的前提，同时规定了传输请求和响应的格式，用到了相关服务的协议如htttp。\n\n由于一个主机上运行的服务有很多，为了区分特定的请求是要那个服务，又为运行在同一个主机上的服务分配，不同的端口号。\n\n服务有些时候需要用户提供一些参数才能进行，可以在一个url的末尾加上一些，需要的参数进行传递。\n\n综上，其实，一个URL基本代表了一个用户什么服务，同时，这个服务存在在哪里。\n\n对相关服务器存在的接口进行访问，其实就是对服务器相关服务的路径进行访问。\n","source":"_posts/杭电助手后端二面经历.md","raw":"---\ntitle: 杭电助手后端二面经历\ndate: 2025-03-05 14:06:58\nupdated: 2025-05-06 19:56:52\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\nnoticeOutdate:\n---\n\n# 杭电助手后端二面经历\n\n在杭电助手的开发是基于Go语言的. 对于程序来说, 其实用什么语言写的对于程序员的影响只局限于对语言的熟悉程度和开发的效率. 所以, 虽然在此之前, 我对Go语言的涉猎只局限于安装和运行了Helloworld. 这次的二面项目的构建, 是一个很好的机会, 让我去熟悉Go语言的应用, 这与当今许多公司的后端开发相关性非常强.\n\n\n\n## Go语言的初步认识\n\n在我的印象中, Go语言的介绍是为了能够综合Java多平台和C++高粒度创造出的语言, 同时也摈弃了一些这两种语言的弊端, 作为一种新兴的语言, 在很多公司的后端开发中都得到了大规模的应用.\n\n作为之中面向对象的语言, Go语言虽然目前我并没有学到他的类, 但是, 从最开始的mod来说, Go应该是基于一个包与包之间相互调用进行运行的. 当我在一个项目的文件加下, 同时写了两个main函数的时候, 语言会提示报错. \n\n对于Go语言来说，每个包中的方法都是以大写字母开头的， 如果不是大写字母开头的就不是包的导出名字。虽然目前我还不了解，这个导出与未导出的区别是什么，也许是一个方法是这个包private还是public的区别吧. (雾)\n\n变量名在数据类型的前面, 这也许是Go语言的特性吧.\n\n[关于Go语言字符风格]: https://blog.go-zh.org/gos-declaration-syntax\t\"Go&#39;s Declaration Syntax\"\n\n1. Go语言中的函数, 可以返回任意数量的返回值.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n//注意返回的顺序,输出的结果是\"world hello\"\n```\n\n2. Go语言中, 可一直直接定义返回值的名称, 在函数返回时直接写return就能根据返回变量名称的定义和函数内部相关变量名的值直接返回\n\n   ```go\n   package main\n   \n   import \"fmt\"\n   \n   func split(sum int) (x, y int) {\n   \tx = sum * 4 / 9\n   \ty = sum - x\n   \treturn\n   }\n   \n   func main() {\n   \tfmt.Println(split(17))\n   }\n   //相当于是x,y是直接在返回类型中定义的\n   ```\n\n   \n\n3. Go语言中的while循环都由for循环担任, 而且条件没有小括号的包裹\n\n4. if语句可以在执行条件判断前执行一个简短的语句*虽然我目前还不知道有什么用*, 同时,如果语句申明的是一个变量, 变量的作用域也只在这之中.  同时也在与其成对的else语句中存在. \n\n   ``` go\n   package main\n   \n   import (\n   \t\"fmt\"\n   \t\"math\"\n   )\n   \n   func pow(x, n, lim float64) float64 {\n   \tif v := math.Pow(x, n); v < lim {\n   \t\treturn v\n   \t}\n   \treturn lim\n   }\n   \n   func main() {\n   \tfmt.Println(\n   \t\tpow(3, 2, 10),\n   \t\tpow(3, 3, 20),\n   \t)\n   }\n   ```\n\n5. 在Go语言中的结构体，即使是对指针进行引用也是直接使用 '.' 进行引用。\n\n6. 使用range对for循环做遍历，每次会返回两个值，第一个是元素的下标，第二是元素的副本。这些可以通过一些语法手段进行忽略一些值的引用.\n\n   ```go\n   package main\n   \n   import \"fmt\"\n   \n   var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n   \n   func main() {\n   \tfor i, v := range pow {\n   \t\tfmt.Printf(\"2**%d = %d\\n\", i, v)\n   \t}\n   }\n   /*\n   output:\n   2**0 = 1\n   2**1 = 2\n   2**2 = 4\n   2**3 = 8\n   2**4 = 16\n   2**5 = 32\n   2**6 = 64\n   2**7 = 128\n   */\n   ```\n\n   \n\n## 从Gin项目开始构建\n\n从给出的文档来说，Gin对目前的我来说可能有点像nginx一样, 作为一个web端的服务器框架. 通过使用Gin的框架, 可以快速的部署Go的web项目.\n\n当跟着文档做出一个demo后, 我发现, Gin有点像我曾经的Hexo的本地预览一样, 可以打开本地的端口, 进行访问.\n\n所以在直接运行main.go后, 其实就是开启了一个web项目, 这时候, 再从gitbash的终端, 向本地发送请求,就像模拟了一次客户端向服务端发送请求服务的过程. 所以照理说, 直接通过shell终端应该也是可以访问的.\n\n通过验证, curl命令其实就是一个对URL发送请求的命令, 通过shell终端发送相同的命令, 得到了返回的相应报文, 同时, 其中的content内容为, 我在编写是写入的内容.\n\n## 关于docker的使用\n\n感觉在服务器上使用docker是件麻烦的事情，即使众所周知，在企业开发中，docker可以大大地节约开发的环境配置的时间，但是，我目前是在想不明白，如果对于docker来说，被在国内禁得这么惨，我这么多的换源都失效了，是在想不知道应该如何使用。\n\n## 从web应用开始开发\n\n对于从文档里面获得的知识感觉差不多了，纸上得来终觉浅。所以一到我现在开始实际上手开发就有点不知道该做什么了。\n\n通过Gin的框架构建的web应用，目前知道了是如何启动，但是我不明白其中的原理，我没有办法在其基础上做出拓展。\n\n## 关于mysql数据库的操作\n\n在这之前只是对mysql有了一定的初步了解，通过这些操作对mysql的用户管理和增删改查有了一些基本的认识。\n\n在为专门创建用来管理web数据库的用户'huning'@'%'赋予权限的时候, 遇到的'root'@'%'无法执行的操作, 通过搜索可知, 这是应为,我是通过DataGrip远程登录的数据库进行操作, 而对于'root'@'%'来说并没有赋予其他用户权限的权限. \n\n所以需要登录到'root'@'localhost'先对其进行权限的授予\n\n```sql\ngrant all privileges on *.* to 'root'@'%' with grant option\n// with grant option可以将权限授予其他的用户,虽然我不知道这样不写还能不能进行授予\n```\n\n通过引入相关的对于mysql处理的包文件, 就可以连接上数据库, 剩下的就是撰写相关的对于表结构的增删改查的函数了. 可以先通过做一些简单的案例进行尝试.\n\n## Go语言模块的测试\n\n在python中的测试模式, 现在想来确实简单不少, 其实联想c++其实模块的测试应该也是和Go语言一样需要有专门的测试模块. 但是其实我没怎么写过项目, 测试做的少所以就不是很熟悉了.\n\n在python中通常直接在运行相关的文件, 输入参数就可以直接运行写好的相关的接口函数.\n\n```python\ndef func() :\n    ******\n#这里开始其实就已经是对这个模块进行测试了，所以似乎简单的测试可以不用导入相关的测试模块进行\nif __name__ == '__main__':\n    \n```\n\n## 关于包管理\n\n在导入的包前面加上'_' , 表示当前导入的包并不使用. 提示是说将这个包视作的初始化. 但是目前还不理解这个初始化, 为什么是导入但不使用.\n\n## 关于函数\n\n对于函数来说, 需要保证需要引出的函数的开头字母是大写的, 说明这个函数是公开的, 如果是小写的说明这个函数是这文件私有的.\n\n这里算事解决了前面, 我遗留的为什么一个包的大写函数是引出名的问题.\n\n而且由于go语言是以包管理进行的, 所以, 在同一个包下,似乎可以视作是写在同一个文件下的.\n\n\n\n## 关于测试文件的编写\n\n一定要注意测试文件的命名,必须以'_test.go'结尾, 否则对于go的test来说, 这并不是一个test文件, 不会进行执行.\n\n当然在更改完这个错误后, 前面, 对于是否, 导入包的时候是对测试模块已经build了的包直接引用, 还是通过相关的源文件进行应用, 这个问题已经无法验证了, 必须要等到下次遇到再测试了.\n\n在编写链接函数\"ConnectMyDatabase\"中运用到了一个\"defer db.Close()\", 虽然我知道， 这个是在后面防止忘记关数据库的。但是确实第一次运用这语句还不太熟悉直接抄写了下了。但是由于我是通过调用一个相关的连接函数，后在进行操作的，所以我在连接函数中如果加入的这个语句，在我获取了链接后就直接将我的数据库连接关闭了，在删除数据库的连接后，通过构建测是模块，成功实现了，数据库中增加数据，剩下的删改查都是一样的套路，数据库相关的代码，之后就可以轻车熟路了。再次贴图见证成功操作数据库。![](.\\img\\QQ20241003-011900.png)\n\n## 关于路由的一些进一步理解（URL）\n\n对于一般的web服务，都运行在特定的主机上，同时，一个主机上可能还运行着其他的服务。\n\n主机的公网ip地址是能够通过ip协议向相关提供服务的主机发送服务请求的前提，同时规定了传输请求和响应的格式，用到了相关服务的协议如htttp。\n\n由于一个主机上运行的服务有很多，为了区分特定的请求是要那个服务，又为运行在同一个主机上的服务分配，不同的端口号。\n\n服务有些时候需要用户提供一些参数才能进行，可以在一个url的末尾加上一些，需要的参数进行传递。\n\n综上，其实，一个URL基本代表了一个用户什么服务，同时，这个服务存在在哪里。\n\n对相关服务器存在的接口进行访问，其实就是对服务器相关服务的路径进行访问。\n","slug":"杭电助手后端二面经历","published":1,"layout":"post","photos":[],"_id":"cmafjaxah0006vpx53ot8a3uf","content":"<h1 id=\"杭电助手后端二面经历\"><a href=\"#杭电助手后端二面经历\" class=\"headerlink\" title=\"杭电助手后端二面经历\"></a>杭电助手后端二面经历</h1><p>在杭电助手的开发是基于Go语言的. 对于程序来说, 其实用什么语言写的对于程序员的影响只局限于对语言的熟悉程度和开发的效率. 所以, 虽然在此之前, 我对Go语言的涉猎只局限于安装和运行了Helloworld. 这次的二面项目的构建, 是一个很好的机会, 让我去熟悉Go语言的应用, 这与当今许多公司的后端开发相关性非常强.</p>\n<h2 id=\"Go语言的初步认识\"><a href=\"#Go语言的初步认识\" class=\"headerlink\" title=\"Go语言的初步认识\"></a>Go语言的初步认识</h2><p>在我的印象中, Go语言的介绍是为了能够综合Java多平台和C++高粒度创造出的语言, 同时也摈弃了一些这两种语言的弊端, 作为一种新兴的语言, 在很多公司的后端开发中都得到了大规模的应用.</p>\n<p>作为之中面向对象的语言, Go语言虽然目前我并没有学到他的类, 但是, 从最开始的mod来说, Go应该是基于一个包与包之间相互调用进行运行的. 当我在一个项目的文件加下, 同时写了两个main函数的时候, 语言会提示报错. </p>\n<p>对于Go语言来说，每个包中的方法都是以大写字母开头的， 如果不是大写字母开头的就不是包的导出名字。虽然目前我还不了解，这个导出与未导出的区别是什么，也许是一个方法是这个包private还是public的区别吧. (雾)</p>\n<p>变量名在数据类型的前面, 这也许是Go语言的特性吧.</p>\n<p>[关于Go语言字符风格]: <a href=\"https://blog.go-zh.org/gos-declaration-syntax\">https://blog.go-zh.org/gos-declaration-syntax</a>\t“Go&#39;s Declaration Syntax”</p>\n<ol>\n<li>Go语言中的函数, 可以返回任意数量的返回值.</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta, b := swap(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(a, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//注意返回的顺序,输出的结果是&quot;world hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>Go语言中, 可一直直接定义返回值的名称, 在函数返回时直接写return就能根据返回变量名称的定义和函数内部相关变量名的值直接返回</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">split</span><span class=\"params\">(sum <span class=\"type\">int</span>)</span></span> (x, y <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tx = sum * <span class=\"number\">4</span> / <span class=\"number\">9</span></span><br><span class=\"line\">\ty = sum - x</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(split(<span class=\"number\">17</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//相当于是x,y是直接在返回类型中定义的</span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>Go语言中的while循环都由for循环担任, 而且条件没有小括号的包裹</p>\n</li>\n<li><p>if语句可以在执行条件判断前执行一个简短的语句<em>虽然我目前还不知道有什么用</em>, 同时,如果语句申明的是一个变量, 变量的作用域也只在这之中.  同时也在与其成对的else语句中存在. </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x, n, lim <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lim</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(</span><br><span class=\"line\">\t\tpow(<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>),</span><br><span class=\"line\">\t\tpow(<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Go语言中的结构体，即使是对指针进行引用也是直接使用 ‘.’ 进行引用。</p>\n</li>\n<li><p>使用range对for循环做遍历，每次会返回两个值，第一个是元素的下标，第二是元素的副本。这些可以通过一些语法手段进行忽略一些值的引用.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pow = []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>, <span class=\"number\">64</span>, <span class=\"number\">128</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;2**%d = %d\\n&quot;</span>, i, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">output:</span></span><br><span class=\"line\"><span class=\"comment\">2**0 = 1</span></span><br><span class=\"line\"><span class=\"comment\">2**1 = 2</span></span><br><span class=\"line\"><span class=\"comment\">2**2 = 4</span></span><br><span class=\"line\"><span class=\"comment\">2**3 = 8</span></span><br><span class=\"line\"><span class=\"comment\">2**4 = 16</span></span><br><span class=\"line\"><span class=\"comment\">2**5 = 32</span></span><br><span class=\"line\"><span class=\"comment\">2**6 = 64</span></span><br><span class=\"line\"><span class=\"comment\">2**7 = 128</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"从Gin项目开始构建\"><a href=\"#从Gin项目开始构建\" class=\"headerlink\" title=\"从Gin项目开始构建\"></a>从Gin项目开始构建</h2><p>从给出的文档来说，Gin对目前的我来说可能有点像nginx一样, 作为一个web端的服务器框架. 通过使用Gin的框架, 可以快速的部署Go的web项目.</p>\n<p>当跟着文档做出一个demo后, 我发现, Gin有点像我曾经的Hexo的本地预览一样, 可以打开本地的端口, 进行访问.</p>\n<p>所以在直接运行main.go后, 其实就是开启了一个web项目, 这时候, 再从gitbash的终端, 向本地发送请求,就像模拟了一次客户端向服务端发送请求服务的过程. 所以照理说, 直接通过shell终端应该也是可以访问的.</p>\n<p>通过验证, curl命令其实就是一个对URL发送请求的命令, 通过shell终端发送相同的命令, 得到了返回的相应报文, 同时, 其中的content内容为, 我在编写是写入的内容.</p>\n<h2 id=\"关于docker的使用\"><a href=\"#关于docker的使用\" class=\"headerlink\" title=\"关于docker的使用\"></a>关于docker的使用</h2><p>感觉在服务器上使用docker是件麻烦的事情，即使众所周知，在企业开发中，docker可以大大地节约开发的环境配置的时间，但是，我目前是在想不明白，如果对于docker来说，被在国内禁得这么惨，我这么多的换源都失效了，是在想不知道应该如何使用。</p>\n<h2 id=\"从web应用开始开发\"><a href=\"#从web应用开始开发\" class=\"headerlink\" title=\"从web应用开始开发\"></a>从web应用开始开发</h2><p>对于从文档里面获得的知识感觉差不多了，纸上得来终觉浅。所以一到我现在开始实际上手开发就有点不知道该做什么了。</p>\n<p>通过Gin的框架构建的web应用，目前知道了是如何启动，但是我不明白其中的原理，我没有办法在其基础上做出拓展。</p>\n<h2 id=\"关于mysql数据库的操作\"><a href=\"#关于mysql数据库的操作\" class=\"headerlink\" title=\"关于mysql数据库的操作\"></a>关于mysql数据库的操作</h2><p>在这之前只是对mysql有了一定的初步了解，通过这些操作对mysql的用户管理和增删改查有了一些基本的认识。</p>\n<p>在为专门创建用来管理web数据库的用户‘huning‘@’%’赋予权限的时候, 遇到的‘root‘@’%’无法执行的操作, 通过搜索可知, 这是应为,我是通过DataGrip远程登录的数据库进行操作, 而对于‘root‘@’%’来说并没有赋予其他用户权限的权限. </p>\n<p>所以需要登录到‘root‘@’localhost’先对其进行权限的授予</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">all</span> privileges <span class=\"keyword\">on</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">to</span> <span class=\"string\">&#x27;root&#x27;</span>@<span class=\"string\">&#x27;%&#x27;</span> <span class=\"keyword\">with</span> <span class=\"keyword\">grant</span> option</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> <span class=\"keyword\">with</span> <span class=\"keyword\">grant</span> option可以将权限授予其他的用户,虽然我不知道这样不写还能不能进行授予</span><br></pre></td></tr></table></figure>\n\n<p>通过引入相关的对于mysql处理的包文件, 就可以连接上数据库, 剩下的就是撰写相关的对于表结构的增删改查的函数了. 可以先通过做一些简单的案例进行尝试.</p>\n<h2 id=\"Go语言模块的测试\"><a href=\"#Go语言模块的测试\" class=\"headerlink\" title=\"Go语言模块的测试\"></a>Go语言模块的测试</h2><p>在python中的测试模式, 现在想来确实简单不少, 其实联想c++其实模块的测试应该也是和Go语言一样需要有专门的测试模块. 但是其实我没怎么写过项目, 测试做的少所以就不是很熟悉了.</p>\n<p>在python中通常直接在运行相关的文件, 输入参数就可以直接运行写好的相关的接口函数.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">func</span>() :</span><br><span class=\"line\">    ******</span><br><span class=\"line\"><span class=\"comment\">#这里开始其实就已经是对这个模块进行测试了，所以似乎简单的测试可以不用导入相关的测试模块进行</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关于包管理\"><a href=\"#关于包管理\" class=\"headerlink\" title=\"关于包管理\"></a>关于包管理</h2><p>在导入的包前面加上’_’ , 表示当前导入的包并不使用. 提示是说将这个包视作的初始化. 但是目前还不理解这个初始化, 为什么是导入但不使用.</p>\n<h2 id=\"关于函数\"><a href=\"#关于函数\" class=\"headerlink\" title=\"关于函数\"></a>关于函数</h2><p>对于函数来说, 需要保证需要引出的函数的开头字母是大写的, 说明这个函数是公开的, 如果是小写的说明这个函数是这文件私有的.</p>\n<p>这里算事解决了前面, 我遗留的为什么一个包的大写函数是引出名的问题.</p>\n<p>而且由于go语言是以包管理进行的, 所以, 在同一个包下,似乎可以视作是写在同一个文件下的.</p>\n<h2 id=\"关于测试文件的编写\"><a href=\"#关于测试文件的编写\" class=\"headerlink\" title=\"关于测试文件的编写\"></a>关于测试文件的编写</h2><p>一定要注意测试文件的命名,必须以’_test.go’结尾, 否则对于go的test来说, 这并不是一个test文件, 不会进行执行.</p>\n<p>当然在更改完这个错误后, 前面, 对于是否, 导入包的时候是对测试模块已经build了的包直接引用, 还是通过相关的源文件进行应用, 这个问题已经无法验证了, 必须要等到下次遇到再测试了.</p>\n<p>在编写链接函数”ConnectMyDatabase”中运用到了一个”defer db.Close()”, 虽然我知道， 这个是在后面防止忘记关数据库的。但是确实第一次运用这语句还不太熟悉直接抄写了下了。但是由于我是通过调用一个相关的连接函数，后在进行操作的，所以我在连接函数中如果加入的这个语句，在我获取了链接后就直接将我的数据库连接关闭了，在删除数据库的连接后，通过构建测是模块，成功实现了，数据库中增加数据，剩下的删改查都是一样的套路，数据库相关的代码，之后就可以轻车熟路了。再次贴图见证成功操作数据库。<img src=\"/.%5Cimg%5CQQ20241003-011900.png\"></p>\n<h2 id=\"关于路由的一些进一步理解（URL）\"><a href=\"#关于路由的一些进一步理解（URL）\" class=\"headerlink\" title=\"关于路由的一些进一步理解（URL）\"></a>关于路由的一些进一步理解（URL）</h2><p>对于一般的web服务，都运行在特定的主机上，同时，一个主机上可能还运行着其他的服务。</p>\n<p>主机的公网ip地址是能够通过ip协议向相关提供服务的主机发送服务请求的前提，同时规定了传输请求和响应的格式，用到了相关服务的协议如htttp。</p>\n<p>由于一个主机上运行的服务有很多，为了区分特定的请求是要那个服务，又为运行在同一个主机上的服务分配，不同的端口号。</p>\n<p>服务有些时候需要用户提供一些参数才能进行，可以在一个url的末尾加上一些，需要的参数进行传递。</p>\n<p>综上，其实，一个URL基本代表了一个用户什么服务，同时，这个服务存在在哪里。</p>\n<p>对相关服务器存在的接口进行访问，其实就是对服务器相关服务的路径进行访问。</p>\n","excerpt":"","more":"<h1 id=\"杭电助手后端二面经历\"><a href=\"#杭电助手后端二面经历\" class=\"headerlink\" title=\"杭电助手后端二面经历\"></a>杭电助手后端二面经历</h1><p>在杭电助手的开发是基于Go语言的. 对于程序来说, 其实用什么语言写的对于程序员的影响只局限于对语言的熟悉程度和开发的效率. 所以, 虽然在此之前, 我对Go语言的涉猎只局限于安装和运行了Helloworld. 这次的二面项目的构建, 是一个很好的机会, 让我去熟悉Go语言的应用, 这与当今许多公司的后端开发相关性非常强.</p>\n<h2 id=\"Go语言的初步认识\"><a href=\"#Go语言的初步认识\" class=\"headerlink\" title=\"Go语言的初步认识\"></a>Go语言的初步认识</h2><p>在我的印象中, Go语言的介绍是为了能够综合Java多平台和C++高粒度创造出的语言, 同时也摈弃了一些这两种语言的弊端, 作为一种新兴的语言, 在很多公司的后端开发中都得到了大规模的应用.</p>\n<p>作为之中面向对象的语言, Go语言虽然目前我并没有学到他的类, 但是, 从最开始的mod来说, Go应该是基于一个包与包之间相互调用进行运行的. 当我在一个项目的文件加下, 同时写了两个main函数的时候, 语言会提示报错. </p>\n<p>对于Go语言来说，每个包中的方法都是以大写字母开头的， 如果不是大写字母开头的就不是包的导出名字。虽然目前我还不了解，这个导出与未导出的区别是什么，也许是一个方法是这个包private还是public的区别吧. (雾)</p>\n<p>变量名在数据类型的前面, 这也许是Go语言的特性吧.</p>\n<p>[关于Go语言字符风格]: <a href=\"https://blog.go-zh.org/gos-declaration-syntax\">https://blog.go-zh.org/gos-declaration-syntax</a>\t“Go&#39;s Declaration Syntax”</p>\n<ol>\n<li>Go语言中的函数, 可以返回任意数量的返回值.</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta, b := swap(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(a, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//注意返回的顺序,输出的结果是&quot;world hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>Go语言中, 可一直直接定义返回值的名称, 在函数返回时直接写return就能根据返回变量名称的定义和函数内部相关变量名的值直接返回</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">split</span><span class=\"params\">(sum <span class=\"type\">int</span>)</span></span> (x, y <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tx = sum * <span class=\"number\">4</span> / <span class=\"number\">9</span></span><br><span class=\"line\">\ty = sum - x</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(split(<span class=\"number\">17</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//相当于是x,y是直接在返回类型中定义的</span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>Go语言中的while循环都由for循环担任, 而且条件没有小括号的包裹</p>\n</li>\n<li><p>if语句可以在执行条件判断前执行一个简短的语句<em>虽然我目前还不知道有什么用</em>, 同时,如果语句申明的是一个变量, 变量的作用域也只在这之中.  同时也在与其成对的else语句中存在. </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x, n, lim <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lim</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(</span><br><span class=\"line\">\t\tpow(<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>),</span><br><span class=\"line\">\t\tpow(<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Go语言中的结构体，即使是对指针进行引用也是直接使用 ‘.’ 进行引用。</p>\n</li>\n<li><p>使用range对for循环做遍历，每次会返回两个值，第一个是元素的下标，第二是元素的副本。这些可以通过一些语法手段进行忽略一些值的引用.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pow = []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>, <span class=\"number\">64</span>, <span class=\"number\">128</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;2**%d = %d\\n&quot;</span>, i, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">output:</span></span><br><span class=\"line\"><span class=\"comment\">2**0 = 1</span></span><br><span class=\"line\"><span class=\"comment\">2**1 = 2</span></span><br><span class=\"line\"><span class=\"comment\">2**2 = 4</span></span><br><span class=\"line\"><span class=\"comment\">2**3 = 8</span></span><br><span class=\"line\"><span class=\"comment\">2**4 = 16</span></span><br><span class=\"line\"><span class=\"comment\">2**5 = 32</span></span><br><span class=\"line\"><span class=\"comment\">2**6 = 64</span></span><br><span class=\"line\"><span class=\"comment\">2**7 = 128</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"从Gin项目开始构建\"><a href=\"#从Gin项目开始构建\" class=\"headerlink\" title=\"从Gin项目开始构建\"></a>从Gin项目开始构建</h2><p>从给出的文档来说，Gin对目前的我来说可能有点像nginx一样, 作为一个web端的服务器框架. 通过使用Gin的框架, 可以快速的部署Go的web项目.</p>\n<p>当跟着文档做出一个demo后, 我发现, Gin有点像我曾经的Hexo的本地预览一样, 可以打开本地的端口, 进行访问.</p>\n<p>所以在直接运行main.go后, 其实就是开启了一个web项目, 这时候, 再从gitbash的终端, 向本地发送请求,就像模拟了一次客户端向服务端发送请求服务的过程. 所以照理说, 直接通过shell终端应该也是可以访问的.</p>\n<p>通过验证, curl命令其实就是一个对URL发送请求的命令, 通过shell终端发送相同的命令, 得到了返回的相应报文, 同时, 其中的content内容为, 我在编写是写入的内容.</p>\n<h2 id=\"关于docker的使用\"><a href=\"#关于docker的使用\" class=\"headerlink\" title=\"关于docker的使用\"></a>关于docker的使用</h2><p>感觉在服务器上使用docker是件麻烦的事情，即使众所周知，在企业开发中，docker可以大大地节约开发的环境配置的时间，但是，我目前是在想不明白，如果对于docker来说，被在国内禁得这么惨，我这么多的换源都失效了，是在想不知道应该如何使用。</p>\n<h2 id=\"从web应用开始开发\"><a href=\"#从web应用开始开发\" class=\"headerlink\" title=\"从web应用开始开发\"></a>从web应用开始开发</h2><p>对于从文档里面获得的知识感觉差不多了，纸上得来终觉浅。所以一到我现在开始实际上手开发就有点不知道该做什么了。</p>\n<p>通过Gin的框架构建的web应用，目前知道了是如何启动，但是我不明白其中的原理，我没有办法在其基础上做出拓展。</p>\n<h2 id=\"关于mysql数据库的操作\"><a href=\"#关于mysql数据库的操作\" class=\"headerlink\" title=\"关于mysql数据库的操作\"></a>关于mysql数据库的操作</h2><p>在这之前只是对mysql有了一定的初步了解，通过这些操作对mysql的用户管理和增删改查有了一些基本的认识。</p>\n<p>在为专门创建用来管理web数据库的用户‘huning‘@’%’赋予权限的时候, 遇到的‘root‘@’%’无法执行的操作, 通过搜索可知, 这是应为,我是通过DataGrip远程登录的数据库进行操作, 而对于‘root‘@’%’来说并没有赋予其他用户权限的权限. </p>\n<p>所以需要登录到‘root‘@’localhost’先对其进行权限的授予</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">all</span> privileges <span class=\"keyword\">on</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">to</span> <span class=\"string\">&#x27;root&#x27;</span>@<span class=\"string\">&#x27;%&#x27;</span> <span class=\"keyword\">with</span> <span class=\"keyword\">grant</span> option</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> <span class=\"keyword\">with</span> <span class=\"keyword\">grant</span> option可以将权限授予其他的用户,虽然我不知道这样不写还能不能进行授予</span><br></pre></td></tr></table></figure>\n\n<p>通过引入相关的对于mysql处理的包文件, 就可以连接上数据库, 剩下的就是撰写相关的对于表结构的增删改查的函数了. 可以先通过做一些简单的案例进行尝试.</p>\n<h2 id=\"Go语言模块的测试\"><a href=\"#Go语言模块的测试\" class=\"headerlink\" title=\"Go语言模块的测试\"></a>Go语言模块的测试</h2><p>在python中的测试模式, 现在想来确实简单不少, 其实联想c++其实模块的测试应该也是和Go语言一样需要有专门的测试模块. 但是其实我没怎么写过项目, 测试做的少所以就不是很熟悉了.</p>\n<p>在python中通常直接在运行相关的文件, 输入参数就可以直接运行写好的相关的接口函数.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">func</span>() :</span><br><span class=\"line\">    ******</span><br><span class=\"line\"><span class=\"comment\">#这里开始其实就已经是对这个模块进行测试了，所以似乎简单的测试可以不用导入相关的测试模块进行</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关于包管理\"><a href=\"#关于包管理\" class=\"headerlink\" title=\"关于包管理\"></a>关于包管理</h2><p>在导入的包前面加上’_’ , 表示当前导入的包并不使用. 提示是说将这个包视作的初始化. 但是目前还不理解这个初始化, 为什么是导入但不使用.</p>\n<h2 id=\"关于函数\"><a href=\"#关于函数\" class=\"headerlink\" title=\"关于函数\"></a>关于函数</h2><p>对于函数来说, 需要保证需要引出的函数的开头字母是大写的, 说明这个函数是公开的, 如果是小写的说明这个函数是这文件私有的.</p>\n<p>这里算事解决了前面, 我遗留的为什么一个包的大写函数是引出名的问题.</p>\n<p>而且由于go语言是以包管理进行的, 所以, 在同一个包下,似乎可以视作是写在同一个文件下的.</p>\n<h2 id=\"关于测试文件的编写\"><a href=\"#关于测试文件的编写\" class=\"headerlink\" title=\"关于测试文件的编写\"></a>关于测试文件的编写</h2><p>一定要注意测试文件的命名,必须以’_test.go’结尾, 否则对于go的test来说, 这并不是一个test文件, 不会进行执行.</p>\n<p>当然在更改完这个错误后, 前面, 对于是否, 导入包的时候是对测试模块已经build了的包直接引用, 还是通过相关的源文件进行应用, 这个问题已经无法验证了, 必须要等到下次遇到再测试了.</p>\n<p>在编写链接函数”ConnectMyDatabase”中运用到了一个”defer db.Close()”, 虽然我知道， 这个是在后面防止忘记关数据库的。但是确实第一次运用这语句还不太熟悉直接抄写了下了。但是由于我是通过调用一个相关的连接函数，后在进行操作的，所以我在连接函数中如果加入的这个语句，在我获取了链接后就直接将我的数据库连接关闭了，在删除数据库的连接后，通过构建测是模块，成功实现了，数据库中增加数据，剩下的删改查都是一样的套路，数据库相关的代码，之后就可以轻车熟路了。再次贴图见证成功操作数据库。<img src=\"/.%5Cimg%5CQQ20241003-011900.png\"></p>\n<h2 id=\"关于路由的一些进一步理解（URL）\"><a href=\"#关于路由的一些进一步理解（URL）\" class=\"headerlink\" title=\"关于路由的一些进一步理解（URL）\"></a>关于路由的一些进一步理解（URL）</h2><p>对于一般的web服务，都运行在特定的主机上，同时，一个主机上可能还运行着其他的服务。</p>\n<p>主机的公网ip地址是能够通过ip协议向相关提供服务的主机发送服务请求的前提，同时规定了传输请求和响应的格式，用到了相关服务的协议如htttp。</p>\n<p>由于一个主机上运行的服务有很多，为了区分特定的请求是要那个服务，又为运行在同一个主机上的服务分配，不同的端口号。</p>\n<p>服务有些时候需要用户提供一些参数才能进行，可以在一个url的末尾加上一些，需要的参数进行传递。</p>\n<p>综上，其实，一个URL基本代表了一个用户什么服务，同时，这个服务存在在哪里。</p>\n<p>对相关服务器存在的接口进行访问，其实就是对服务器相关服务的路径进行访问。</p>\n"},{"title":"杭电助手后端面试总结","date":"2024-10-08T15:40:54.000Z","updated":"2025-05-06T11:56:52.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"noticeOutdate":null,"_content":"\n# 杭电助手后端面试总结\n\n## 前言\n\n经过了长达两个星期的招新流程，虽然很遗憾，并没有被成功录取，但是也很幸运能够在这次面试中学到了很多的东西，进一步深化了自己的理解，不止是停留在了解概念的阶段。不管是否进入了后端部，这里都并不是我的终点，所以，再次进行总结，根据在二面期间写下的经历与问题总结而成,为以后能够成功拿下大厂offer做好准备.\n\n## 关于二面的任务\n\n对于一面来说, 主要只是考察面试人员的面貌的, 所以并不是技术的重点. \n\n二面的任务是上线一个校园问答系统, 要求根据相关的场景, 分析具体需求, 编写相关的接口.\n\n通过简单的分析, 对于这个系统的需求, 最基础的功能肯定是\n\n1. 能够实现用户登录与注册\n2. 能够提出问题\n3. 能够回答问题\n4. 能够查找相关问题\n\n在这些基础上, 对相关功能的实现进行相关场景的更加细化的设计. 同时, 由于要设计相关的数据表格, 所以根据要实现的功能设计相关的数据库表也是十分重要的. \n\n## 关于后端的一些认识的提升\n\n在做这个项目之前, 虽然我早就对前后端分别要干什么事已经有了一定的了解. 但是对于接口这个概念也只是停留在印象里. 我认为, 由于后端处理的是传输回来的数据的处理, 同时与数据库进行交互的功能, 所以我认为, 后端的任务主要是实现对传入数据处理的函数的实现.\n\n​\t但是,通过实际的训练, 我发现, 虽然我的理解大差不差, 但是忽略了众多的细节. \n\n​\t如果是对于一个web端的应用来说, 前端传输数据请求的是相关的路由. 曾经, 由于我部署静态博客的经历, 我粗浅的认为, URL就是存放在服务器上资源的位置而已. 我只是将URL当作是一个具体的物理地址或者叫目录. 但是, 如果启动的是一个web端服务的话, 对于有些URL来说, 并不是具体的地址, 我在相关的路由上, 也许并没有相关的可执行为文件. 只是通过这个地址, 告诉了服务器, 我需要的是什么服务. 有点像输入了一串指令的样子. 通过我部署的相关服务器运行的框架, 接受到这些指令的请求, 会运行我相关的编写好的函数, 同时会先前端反馈我处理的结果.\n\n<img src=\"https://s2.loli.net/2024/10/08/EcJtCLp5H6kb13R.png\" alt=\"这些路由不会在我启动的服务端存在相关的文件夹\" style=\"zoom: 50%;\" />\n\n\n\n​\t当然对于URL接口的编写规范，这些有规则为RESful的编写规则. 对于这个规则目前我并没有深入的学习, 还需要进行总结. 对于接口传入的参数, 由于这次前后端分离的开发模式, 但是没有前端协作, 所以并没有对接口规范进行协商和规范的这样一个步骤, 当然这在正常的团队协作开发中是必不可少的.\n\n## 对于接口的调试\n\n我觉得，这次最大的收获，除了对路由的和接口的深入了解, 就是对如何对编写的接口进行调试这一步了.\n\n在这之前, 由于本身就没有编写过接口, 所以对于web开发中的这些调试并不是很了解, 说实话, 我可能一开始将这些认为是前端和网络相关的知识了. 😂\n\n通过这次的推荐也是使用上了Apifox这个工具, 对他能做的一些基础的接口规范确定, 和后端接口测试进行了一些初步的应用. 这些东西, 也许不参加这次面试, 我可能不知道要到什么时候才会去学, 没有相关的动力, 又不知道要学多久.\n\n## 对于Go语言的熟悉\n\n这次也算速通了Go语言, 当然, 有些更加深入的特性我还没去了解, 比如接口类型, 每次去找还是不清楚. \n\n当然还有一个宝藏网站, 关于Go的一些高级应用我还没看完.可惜相关的任务属于是内部资料了, 上了权限了现在. 当然, 也对我提供了思路, 需要对一个web应用设置相关的管理和访问权限.[Go语言之旅](https://tour.go-zh.org/list)\n\n对于Go语言的使用, 我感觉他非常适合作为一个项目的语言进行书写, 或者说, 他本来的设计模式就是这样的.\n\n在刚开始学Go的以前, 我总会因为他的包管理相关的内容一头雾水, 但现在可以说已经有一定认识了. 同时, 这也为我未来学习web开发提供了一条便捷之路. 对于现在许多企业的后端项目都是通过Go语言进行开发的, 包括我喜欢的老米. 所以我可以在学习C++的同时, 将Go作为我的一手选择, 虽然如果要做测试路线的话, 可能还得多写Python😅.\n\n## 关于项目\n\n这是我做的第一个web项目, 在之前并没有接触过, 正确的来说是接触了以后放弃了, 但是没有坚持下去的动力, 是Python的后端项目, 想想如果但是坚持做完了, 也许就能在这次开发中节省不少时间, 然后把项目完成的更好了. 还是缺少使自己坚持下去的动力啊.😢\n\n但是, 多做项目积累经验还是很不错的, 之后去github上找项目做也更加熟练了.","source":"_posts/杭电助手后端面试总结.md","raw":"---\ntitle: 杭电助手后端面试总结\ndate: 2024-10-08 23:40:54\nupdated: 2025-05-06 19:56:52\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\nnoticeOutdate:\n---\n\n# 杭电助手后端面试总结\n\n## 前言\n\n经过了长达两个星期的招新流程，虽然很遗憾，并没有被成功录取，但是也很幸运能够在这次面试中学到了很多的东西，进一步深化了自己的理解，不止是停留在了解概念的阶段。不管是否进入了后端部，这里都并不是我的终点，所以，再次进行总结，根据在二面期间写下的经历与问题总结而成,为以后能够成功拿下大厂offer做好准备.\n\n## 关于二面的任务\n\n对于一面来说, 主要只是考察面试人员的面貌的, 所以并不是技术的重点. \n\n二面的任务是上线一个校园问答系统, 要求根据相关的场景, 分析具体需求, 编写相关的接口.\n\n通过简单的分析, 对于这个系统的需求, 最基础的功能肯定是\n\n1. 能够实现用户登录与注册\n2. 能够提出问题\n3. 能够回答问题\n4. 能够查找相关问题\n\n在这些基础上, 对相关功能的实现进行相关场景的更加细化的设计. 同时, 由于要设计相关的数据表格, 所以根据要实现的功能设计相关的数据库表也是十分重要的. \n\n## 关于后端的一些认识的提升\n\n在做这个项目之前, 虽然我早就对前后端分别要干什么事已经有了一定的了解. 但是对于接口这个概念也只是停留在印象里. 我认为, 由于后端处理的是传输回来的数据的处理, 同时与数据库进行交互的功能, 所以我认为, 后端的任务主要是实现对传入数据处理的函数的实现.\n\n​\t但是,通过实际的训练, 我发现, 虽然我的理解大差不差, 但是忽略了众多的细节. \n\n​\t如果是对于一个web端的应用来说, 前端传输数据请求的是相关的路由. 曾经, 由于我部署静态博客的经历, 我粗浅的认为, URL就是存放在服务器上资源的位置而已. 我只是将URL当作是一个具体的物理地址或者叫目录. 但是, 如果启动的是一个web端服务的话, 对于有些URL来说, 并不是具体的地址, 我在相关的路由上, 也许并没有相关的可执行为文件. 只是通过这个地址, 告诉了服务器, 我需要的是什么服务. 有点像输入了一串指令的样子. 通过我部署的相关服务器运行的框架, 接受到这些指令的请求, 会运行我相关的编写好的函数, 同时会先前端反馈我处理的结果.\n\n<img src=\"https://s2.loli.net/2024/10/08/EcJtCLp5H6kb13R.png\" alt=\"这些路由不会在我启动的服务端存在相关的文件夹\" style=\"zoom: 50%;\" />\n\n\n\n​\t当然对于URL接口的编写规范，这些有规则为RESful的编写规则. 对于这个规则目前我并没有深入的学习, 还需要进行总结. 对于接口传入的参数, 由于这次前后端分离的开发模式, 但是没有前端协作, 所以并没有对接口规范进行协商和规范的这样一个步骤, 当然这在正常的团队协作开发中是必不可少的.\n\n## 对于接口的调试\n\n我觉得，这次最大的收获，除了对路由的和接口的深入了解, 就是对如何对编写的接口进行调试这一步了.\n\n在这之前, 由于本身就没有编写过接口, 所以对于web开发中的这些调试并不是很了解, 说实话, 我可能一开始将这些认为是前端和网络相关的知识了. 😂\n\n通过这次的推荐也是使用上了Apifox这个工具, 对他能做的一些基础的接口规范确定, 和后端接口测试进行了一些初步的应用. 这些东西, 也许不参加这次面试, 我可能不知道要到什么时候才会去学, 没有相关的动力, 又不知道要学多久.\n\n## 对于Go语言的熟悉\n\n这次也算速通了Go语言, 当然, 有些更加深入的特性我还没去了解, 比如接口类型, 每次去找还是不清楚. \n\n当然还有一个宝藏网站, 关于Go的一些高级应用我还没看完.可惜相关的任务属于是内部资料了, 上了权限了现在. 当然, 也对我提供了思路, 需要对一个web应用设置相关的管理和访问权限.[Go语言之旅](https://tour.go-zh.org/list)\n\n对于Go语言的使用, 我感觉他非常适合作为一个项目的语言进行书写, 或者说, 他本来的设计模式就是这样的.\n\n在刚开始学Go的以前, 我总会因为他的包管理相关的内容一头雾水, 但现在可以说已经有一定认识了. 同时, 这也为我未来学习web开发提供了一条便捷之路. 对于现在许多企业的后端项目都是通过Go语言进行开发的, 包括我喜欢的老米. 所以我可以在学习C++的同时, 将Go作为我的一手选择, 虽然如果要做测试路线的话, 可能还得多写Python😅.\n\n## 关于项目\n\n这是我做的第一个web项目, 在之前并没有接触过, 正确的来说是接触了以后放弃了, 但是没有坚持下去的动力, 是Python的后端项目, 想想如果但是坚持做完了, 也许就能在这次开发中节省不少时间, 然后把项目完成的更好了. 还是缺少使自己坚持下去的动力啊.😢\n\n但是, 多做项目积累经验还是很不错的, 之后去github上找项目做也更加熟练了.","slug":"杭电助手后端面试总结","published":1,"layout":"post","photos":[],"_id":"cmafjaxai0007vpx5fwgig6e3","content":"<h1 id=\"杭电助手后端面试总结\"><a href=\"#杭电助手后端面试总结\" class=\"headerlink\" title=\"杭电助手后端面试总结\"></a>杭电助手后端面试总结</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>经过了长达两个星期的招新流程，虽然很遗憾，并没有被成功录取，但是也很幸运能够在这次面试中学到了很多的东西，进一步深化了自己的理解，不止是停留在了解概念的阶段。不管是否进入了后端部，这里都并不是我的终点，所以，再次进行总结，根据在二面期间写下的经历与问题总结而成,为以后能够成功拿下大厂offer做好准备.</p>\n<h2 id=\"关于二面的任务\"><a href=\"#关于二面的任务\" class=\"headerlink\" title=\"关于二面的任务\"></a>关于二面的任务</h2><p>对于一面来说, 主要只是考察面试人员的面貌的, 所以并不是技术的重点. </p>\n<p>二面的任务是上线一个校园问答系统, 要求根据相关的场景, 分析具体需求, 编写相关的接口.</p>\n<p>通过简单的分析, 对于这个系统的需求, 最基础的功能肯定是</p>\n<ol>\n<li>能够实现用户登录与注册</li>\n<li>能够提出问题</li>\n<li>能够回答问题</li>\n<li>能够查找相关问题</li>\n</ol>\n<p>在这些基础上, 对相关功能的实现进行相关场景的更加细化的设计. 同时, 由于要设计相关的数据表格, 所以根据要实现的功能设计相关的数据库表也是十分重要的. </p>\n<h2 id=\"关于后端的一些认识的提升\"><a href=\"#关于后端的一些认识的提升\" class=\"headerlink\" title=\"关于后端的一些认识的提升\"></a>关于后端的一些认识的提升</h2><p>在做这个项目之前, 虽然我早就对前后端分别要干什么事已经有了一定的了解. 但是对于接口这个概念也只是停留在印象里. 我认为, 由于后端处理的是传输回来的数据的处理, 同时与数据库进行交互的功能, 所以我认为, 后端的任务主要是实现对传入数据处理的函数的实现.</p>\n<p>​\t但是,通过实际的训练, 我发现, 虽然我的理解大差不差, 但是忽略了众多的细节. </p>\n<p>​\t如果是对于一个web端的应用来说, 前端传输数据请求的是相关的路由. 曾经, 由于我部署静态博客的经历, 我粗浅的认为, URL就是存放在服务器上资源的位置而已. 我只是将URL当作是一个具体的物理地址或者叫目录. 但是, 如果启动的是一个web端服务的话, 对于有些URL来说, 并不是具体的地址, 我在相关的路由上, 也许并没有相关的可执行为文件. 只是通过这个地址, 告诉了服务器, 我需要的是什么服务. 有点像输入了一串指令的样子. 通过我部署的相关服务器运行的框架, 接受到这些指令的请求, 会运行我相关的编写好的函数, 同时会先前端反馈我处理的结果.</p>\n<img src=\"https://s2.loli.net/2024/10/08/EcJtCLp5H6kb13R.png\" alt=\"这些路由不会在我启动的服务端存在相关的文件夹\" style=\"zoom: 50%;\" />\n\n\n\n<p>​\t当然对于URL接口的编写规范，这些有规则为RESful的编写规则. 对于这个规则目前我并没有深入的学习, 还需要进行总结. 对于接口传入的参数, 由于这次前后端分离的开发模式, 但是没有前端协作, 所以并没有对接口规范进行协商和规范的这样一个步骤, 当然这在正常的团队协作开发中是必不可少的.</p>\n<h2 id=\"对于接口的调试\"><a href=\"#对于接口的调试\" class=\"headerlink\" title=\"对于接口的调试\"></a>对于接口的调试</h2><p>我觉得，这次最大的收获，除了对路由的和接口的深入了解, 就是对如何对编写的接口进行调试这一步了.</p>\n<p>在这之前, 由于本身就没有编写过接口, 所以对于web开发中的这些调试并不是很了解, 说实话, 我可能一开始将这些认为是前端和网络相关的知识了. 😂</p>\n<p>通过这次的推荐也是使用上了Apifox这个工具, 对他能做的一些基础的接口规范确定, 和后端接口测试进行了一些初步的应用. 这些东西, 也许不参加这次面试, 我可能不知道要到什么时候才会去学, 没有相关的动力, 又不知道要学多久.</p>\n<h2 id=\"对于Go语言的熟悉\"><a href=\"#对于Go语言的熟悉\" class=\"headerlink\" title=\"对于Go语言的熟悉\"></a>对于Go语言的熟悉</h2><p>这次也算速通了Go语言, 当然, 有些更加深入的特性我还没去了解, 比如接口类型, 每次去找还是不清楚. </p>\n<p>当然还有一个宝藏网站, 关于Go的一些高级应用我还没看完.可惜相关的任务属于是内部资料了, 上了权限了现在. 当然, 也对我提供了思路, 需要对一个web应用设置相关的管理和访问权限.<a href=\"https://tour.go-zh.org/list\">Go语言之旅</a></p>\n<p>对于Go语言的使用, 我感觉他非常适合作为一个项目的语言进行书写, 或者说, 他本来的设计模式就是这样的.</p>\n<p>在刚开始学Go的以前, 我总会因为他的包管理相关的内容一头雾水, 但现在可以说已经有一定认识了. 同时, 这也为我未来学习web开发提供了一条便捷之路. 对于现在许多企业的后端项目都是通过Go语言进行开发的, 包括我喜欢的老米. 所以我可以在学习C++的同时, 将Go作为我的一手选择, 虽然如果要做测试路线的话, 可能还得多写Python😅.</p>\n<h2 id=\"关于项目\"><a href=\"#关于项目\" class=\"headerlink\" title=\"关于项目\"></a>关于项目</h2><p>这是我做的第一个web项目, 在之前并没有接触过, 正确的来说是接触了以后放弃了, 但是没有坚持下去的动力, 是Python的后端项目, 想想如果但是坚持做完了, 也许就能在这次开发中节省不少时间, 然后把项目完成的更好了. 还是缺少使自己坚持下去的动力啊.😢</p>\n<p>但是, 多做项目积累经验还是很不错的, 之后去github上找项目做也更加熟练了.</p>\n","excerpt":"","more":"<h1 id=\"杭电助手后端面试总结\"><a href=\"#杭电助手后端面试总结\" class=\"headerlink\" title=\"杭电助手后端面试总结\"></a>杭电助手后端面试总结</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>经过了长达两个星期的招新流程，虽然很遗憾，并没有被成功录取，但是也很幸运能够在这次面试中学到了很多的东西，进一步深化了自己的理解，不止是停留在了解概念的阶段。不管是否进入了后端部，这里都并不是我的终点，所以，再次进行总结，根据在二面期间写下的经历与问题总结而成,为以后能够成功拿下大厂offer做好准备.</p>\n<h2 id=\"关于二面的任务\"><a href=\"#关于二面的任务\" class=\"headerlink\" title=\"关于二面的任务\"></a>关于二面的任务</h2><p>对于一面来说, 主要只是考察面试人员的面貌的, 所以并不是技术的重点. </p>\n<p>二面的任务是上线一个校园问答系统, 要求根据相关的场景, 分析具体需求, 编写相关的接口.</p>\n<p>通过简单的分析, 对于这个系统的需求, 最基础的功能肯定是</p>\n<ol>\n<li>能够实现用户登录与注册</li>\n<li>能够提出问题</li>\n<li>能够回答问题</li>\n<li>能够查找相关问题</li>\n</ol>\n<p>在这些基础上, 对相关功能的实现进行相关场景的更加细化的设计. 同时, 由于要设计相关的数据表格, 所以根据要实现的功能设计相关的数据库表也是十分重要的. </p>\n<h2 id=\"关于后端的一些认识的提升\"><a href=\"#关于后端的一些认识的提升\" class=\"headerlink\" title=\"关于后端的一些认识的提升\"></a>关于后端的一些认识的提升</h2><p>在做这个项目之前, 虽然我早就对前后端分别要干什么事已经有了一定的了解. 但是对于接口这个概念也只是停留在印象里. 我认为, 由于后端处理的是传输回来的数据的处理, 同时与数据库进行交互的功能, 所以我认为, 后端的任务主要是实现对传入数据处理的函数的实现.</p>\n<p>​\t但是,通过实际的训练, 我发现, 虽然我的理解大差不差, 但是忽略了众多的细节. </p>\n<p>​\t如果是对于一个web端的应用来说, 前端传输数据请求的是相关的路由. 曾经, 由于我部署静态博客的经历, 我粗浅的认为, URL就是存放在服务器上资源的位置而已. 我只是将URL当作是一个具体的物理地址或者叫目录. 但是, 如果启动的是一个web端服务的话, 对于有些URL来说, 并不是具体的地址, 我在相关的路由上, 也许并没有相关的可执行为文件. 只是通过这个地址, 告诉了服务器, 我需要的是什么服务. 有点像输入了一串指令的样子. 通过我部署的相关服务器运行的框架, 接受到这些指令的请求, 会运行我相关的编写好的函数, 同时会先前端反馈我处理的结果.</p>\n<img src=\"https://s2.loli.net/2024/10/08/EcJtCLp5H6kb13R.png\" alt=\"这些路由不会在我启动的服务端存在相关的文件夹\" style=\"zoom: 50%;\" />\n\n\n\n<p>​\t当然对于URL接口的编写规范，这些有规则为RESful的编写规则. 对于这个规则目前我并没有深入的学习, 还需要进行总结. 对于接口传入的参数, 由于这次前后端分离的开发模式, 但是没有前端协作, 所以并没有对接口规范进行协商和规范的这样一个步骤, 当然这在正常的团队协作开发中是必不可少的.</p>\n<h2 id=\"对于接口的调试\"><a href=\"#对于接口的调试\" class=\"headerlink\" title=\"对于接口的调试\"></a>对于接口的调试</h2><p>我觉得，这次最大的收获，除了对路由的和接口的深入了解, 就是对如何对编写的接口进行调试这一步了.</p>\n<p>在这之前, 由于本身就没有编写过接口, 所以对于web开发中的这些调试并不是很了解, 说实话, 我可能一开始将这些认为是前端和网络相关的知识了. 😂</p>\n<p>通过这次的推荐也是使用上了Apifox这个工具, 对他能做的一些基础的接口规范确定, 和后端接口测试进行了一些初步的应用. 这些东西, 也许不参加这次面试, 我可能不知道要到什么时候才会去学, 没有相关的动力, 又不知道要学多久.</p>\n<h2 id=\"对于Go语言的熟悉\"><a href=\"#对于Go语言的熟悉\" class=\"headerlink\" title=\"对于Go语言的熟悉\"></a>对于Go语言的熟悉</h2><p>这次也算速通了Go语言, 当然, 有些更加深入的特性我还没去了解, 比如接口类型, 每次去找还是不清楚. </p>\n<p>当然还有一个宝藏网站, 关于Go的一些高级应用我还没看完.可惜相关的任务属于是内部资料了, 上了权限了现在. 当然, 也对我提供了思路, 需要对一个web应用设置相关的管理和访问权限.<a href=\"https://tour.go-zh.org/list\">Go语言之旅</a></p>\n<p>对于Go语言的使用, 我感觉他非常适合作为一个项目的语言进行书写, 或者说, 他本来的设计模式就是这样的.</p>\n<p>在刚开始学Go的以前, 我总会因为他的包管理相关的内容一头雾水, 但现在可以说已经有一定认识了. 同时, 这也为我未来学习web开发提供了一条便捷之路. 对于现在许多企业的后端项目都是通过Go语言进行开发的, 包括我喜欢的老米. 所以我可以在学习C++的同时, 将Go作为我的一手选择, 虽然如果要做测试路线的话, 可能还得多写Python😅.</p>\n<h2 id=\"关于项目\"><a href=\"#关于项目\" class=\"headerlink\" title=\"关于项目\"></a>关于项目</h2><p>这是我做的第一个web项目, 在之前并没有接触过, 正确的来说是接触了以后放弃了, 但是没有坚持下去的动力, 是Python的后端项目, 想想如果但是坚持做完了, 也许就能在这次开发中节省不少时间, 然后把项目完成的更好了. 还是缺少使自己坚持下去的动力啊.😢</p>\n<p>但是, 多做项目积累经验还是很不错的, 之后去github上找项目做也更加熟练了.</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}