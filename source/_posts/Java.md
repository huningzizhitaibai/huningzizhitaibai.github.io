---
title: Java
date: 2025-03-03 23:53:06
updated: 2025-05-06 19:56:52
tags:
categories:
keywords:
description:
top_img:
comments:
cover:
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
noticeOutdate:
---

# Java

1. `println`和`print`的区别在于前者在输出后自动添加换行, 后者则没有.
2. ~~在创建一个对象时`new`关键字在于重新创造一个对象, 如果直接创建一个对象, 创建对象的值在`Java string`的内存池内如果存在, 该对象会直接指向这个值.~~好像是在内存池中创建一个常量而已, 如果在常量池中有, 就直接将这个常量赋值, 否则就在常量池里再创建一个常量.(但是这样在内存池中创建多个相同的常量又有什么意义呢?)

3. 在scaner类中, `Scaner.next()`一定要读到有效字符后才可以结束.对有效字符之前遇到的空白会自动将其去除, 将有效字符后的空白作为结束符(就是不能输入含有空格的字符串)
4. `scaner.nextLIne()`以回车符为结束的标志. 
   1. scaner类中有`hasNextXXX`进行判断是否还有继续输入. 

# Springboot开发

## 前言

​	之前经过杭电助手后端的二面, 使用Gin框架开发了一个web应用. 已经可以可以体会到, 一个框架对于应用开发效率的提升, 再开发过程中节省了很多需要去配置相关依赖的过程, 再生产中只需要注重服务的逻辑实现就可以了.
​	Gin框架是基于Go语言的web开发框架. 这次为了能够吃透新买的项目教程书, 学习Springboot框架, 同时也是怎加视野和理解不同的编程思维.

# Java项目管理器Maven

​	在一个应用开发的过程中, 一定需要用到很多的第三方库, 这些库也可以称作为是包. 这些包的下载管理, 如果没有包处理器, 需要开发者自己去同意管理, 不仅耗费时间, 同时也容易混乱. 所以专门的事情就要有专门的人去做. 因此就诞生了包管理器,  在python中用到的就是pip.
​	对于maven来说, 好像管理的范围更加的广泛, 是对整个Java项目的所有资源进行管理.将这个项目进行抽象成一个模型, 方便解读和管理. 也许在Maven的眼中, 我们写出来的每一个Java项目的样子其实如下图(图片来自网络)

![](https://i-blog.csdnimg.cn/blog_migrate/39cf153e729b8733fea0c157b2e2d11e.png)

​	其中的本地是自身项目的包管理地址, 私服有点像是镜像源吧, 但是同时翻译其实是仓库, 就和github上差不多吧, 分为私有仓库, 公有仓库, 由中央就是maven团队维护的仓库全为公有仓库.
​	对于一个处在仓库中的jar包, 他的访问路径就是他的坐标.

## Springboot的实践

还是按照黑马的课程, 通过IDEA进行构项目.

对于Maven还是不熟悉的, 不得不说, 很难想象Maven的构建如果没有成熟的插件进行支持, 手工的构建是一件多么麻烦的事情, 当然, 也有可能是对于maven的不熟悉.

对于基于maven进行构建的Java项目, 首先上来对我最卡的就是包的管理. 对于python有pip, 对于Go自身就有管理. 但是Java属实有点难到我了. jar包的管理全部都是通过maven的pom文件中的依赖路径进行管理的. 目前我还是很难理解pom文件中的所有数据文件进行的写法.但是可以确信的是, 一个项目需要的jar包文件的路径应该是全写在maven的文件中了.

一开始的项目构建中, 我并没有采用视频中的jdk17, 一开始我以为是jdk版本的问题. 但是经过多方的尝试, 同时还是阅读编译器的信息, 感觉可能还是包的引入问题. 但是查阅资料, 发现Java中并没有pip这样的包管理器. 其实对我来说是犯了难了. 对于maven这个第三方的包管理器, 感觉像是为Java开发提供的一种补丁的方法. 其操作的程度对于目前初学的我来说简直是一种折磨.

回顾视频, 我发现再maven的选择上, 我少勾选了web的选项, 我猜测这相当于是在我的maven文件中没有自动加上相关的web包的依赖路径. 当然在我, 加上后一时间还是无法运行. 其实从IDEA的终端看看就知道是相关的解析一直没有完成, 涉及到这些外部包的事情, 难免就会涉及的镜像源的问题. 所以一时间的想法就是配置镜像源. 但是在IDEA中的maven好像是他自带的, 因为但我在没有补下maven之前他仍然能够常的运行. 所以即使我补下maven后, 同时在我本机的配置中加上了进行源, 但是仍然慢. 只有进入开发环境中的maven进行配置后, 就能够成功运行了.

## Java知识恶补

在完全没有接触Java直接进行Java的框架应用还是有一定难度. Java和C系的语言差别还是很多.

### 1.Java中的变量值传递的理解

对于在Java中对于有一个方法如果传入一个数组, 对数组进行修改后, 原数组的值也会产生改变这点. 和C系的语言非常不一样. 对于C系的语言来说, 如果只是直接将一个类进行传入, 相当于传入的就是副本, 不会对原来的值进行影响. 只有在传入时, 特地使用 '&' 进行运算的传输值, 才是相关变量的地址值. 但是在Java中, 无论是的什么类对象, 当然目前我并没有尝试数组, 传入的其实都是这个类的地址, 其变量的值, 不能直接简单的看作一个类的整体, 其实, 变量名本身就是一个地址. 所以, 虽然对于Java来说, 所有的传递都是值传递(passed-by-value), 但是, 由于传进去的本身就是地址值, 所以通过地址的修改会造成原来的有所变化.

**通过实践, 对于直接传入数组, 效果也是一样的. 也就是说, 在Java中, 数组其实也是一个类. 补:不对, 因为所以的类对象都是通过new方法建立的, 所以, 其实语句的左值本身就是一个引用变量. 所以传入方法中, 传入的当然就是引用了.**

### 2.Java中的静态变量与静态方法

​	在main函数中对我想写的方法进行测试时, 产生的报错, 写的是不能在静态方法中调用非静态的方法. 查阅资料, 发现这点对于静态变量适用. 原因就在于JVM的机制问题, 目前不是非常的能够看懂. *静态方法类似其他语言中的函数*

### 3.Java中构造方法的一点小不同

​	大部分的构造的方法都和C++差不多,  但是, 当在类中已经定义了相关构造方法后, 编译器就不会再自动构造默认的构造方法了, 想要的话必须自己加, 不理解为什么这样设计. 同时, 再创建构造方法时, 必须使用`new`进行构造.

### 4.关于子类和父类的创建引用的关系

​	还是贴篇文章吧, 有图有真相.

​	[【java】父类与子类的引用赋值关系_子类引用指向父类对象-CSDN博客](https://blog.csdn.net/weixin_42929607/article/details/107168033)

​	父类引用指向的是子类实例的话, 只能调用从父类继承的方法和变量. 但是, 子类对于父类的方法进行覆写, 父类引用调用时, 仍然还是父类的方法.

```java
public class Main {

    public static void main(String... args) {
        Father f = new Child();
        f.hello(); //Child's hello
    }

}

class Father {

    public void hello() {
        System.out.println("Father's hello");
    }
}

class Child extends Father {

    public void hello() {
        System.out.println("Child's hello");
    }

}
```

## Java static修饰

 对于static修饰的变量和方法,  对于变量来说, 其生命周期和类的生命周期一样长, 对于静态方法来说, 可以不通过创建一个具体的对象直接进行访问使用. 所以对于静态方法来说, 如果不是访问静态变量, 就就无法对其他的类变量进行访问, 因为普通的类变量依赖于具体的对象存在.

## Java中的多态优势

在做算法的时候遇到`Queue<int[]> queue = LinkedList<int[]> list`的声明. 不是很明白, 为什么一定要使用父类声明变量, 然后使用子类进行实现. 

对于类和一个父类，在构建实现一个父类申明的时, 会对父类的方法进行构造, 然后再对子类方法进行构造. 声明的父类变量, 相当于是一个指针, 声明为可以更改为其他的子类实现.

```java
package dd20161114_2;

public class Master1 {
public static void main(String[] args) {
    //dog对象实例化
        Dog dog=new Dog();
        eat(dog);
    //cat对象实例化
        Cat cat=new Cat();
        eat(cat);
    //Pet对象实例化
        Pet pet=new Dog();
        pet=new Cat();
        eat(pet);

    }
    public static void eat(Pet pet){

        pet.eat();
    }
}
/*
输出结果：
狗啃骨头
猫吃鱼
猫吃鱼
*/
```



## Java中的相等判断

对于equal方法来说都是判断整体是否相等, 若果只是使用`==`比较的是地址是否相等. 对于一个new出来的对象, 都是使用独立的内存进行存储的, 所以即使所有的字段都相同, equal也为false
