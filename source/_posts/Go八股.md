---
title: Go八股
date: 2025-03-07 16:43:36
updated: 2025-05-06 19:56:52
tags:
categories:
keywords:
description:
top_img:
comments:
cover:
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
noticeOutdate:
---

# Go八股

## 有限状态机

也叫有限自动状态机, 写过dp的话, 其实就说明已经用到过了, 本质上就是一个状态转换成另一个状态, 状态之间可以双向也可以单向, 同时也有纯粹的只进不出的状态, 也许是故意设计成这样的, 避免一个错误产生后, 程序仍然继续运行, 感觉会用在一些比较特殊的业务场景, 需要重新启动估计. 对于不需要重新启动的业务, 感觉在加一个处理异常的状态, 再重新转换回正常的状态即可.参考这篇文章[有限状态机FSM(finite state machine) 一_fsm statemachine-CSDN博客](https://blog.csdn.net/liqiangeastsun/article/details/118932263)

同时文章中提到了, 如果只是使用`if-else`语句进行判断, 最后会造成代码的不可读性. 通过使用一个通用的方法, 是比较好的办法. 通过定义一个抽象类`statusBase`, 在其中定义三个抽象方法`OnEnter` , `OnExecute`和`OnExit`. 对于每个状态去具体的实现这是三个方法从而实现不同状态的转移, 提高代码的可读性.

```java
public abstract class StateBase
{
    // 当前类型
    protected StateEnum _state;
    // 状态转换事件，要转换状态的通知
    protected Action<StateEnum> _transitionEvent;
    public StateBase()  { }

    // 进入该状态
    public abstract void OnEnter();

    // 执行该状态的行为
    public abstract void OnExecute();

    // 退出该状态
    public abstract void OnExit();

    //返回当前类型
    public StateEnum State
    {
        get { return _state; }
    }
    
    public void SetTransitionEvent(Action<StateEnum> transitionEvent)
    {
        _transitionEvent = transitionEvent;
    }
}

```

## 一致性

​	由于后端处理的很多都是与数据相关, 但是, 在当今的互联网服务中, 很明显, 没有办法再使用单一的服务端提供服务, 一方面是能够处理的请求实在是有限, 同时, 将所有的数据都保存在同一 服务端, 万一服务器崩溃就会导致服务不可用, 同时, 数据也可能会丢失, 所以, 目前服务集群部署更为常见. 但是为了提供相同的服务, 就需要保证每个服务器能够获取或者存储的数据应该是一致的. 当然根据业务场景可能对数据的要求并不一样。

1. 强一致性

   要求在任何时刻, 系统中所有的副本都是一样的, 对数据的一致性具有极高的要求, 在比如银行的转账系统等比较常见.

2. 最终一致性

   允许在短时内出现数据不一致的情况, 通过使所有节点的数据解决.

## RBAC(Role-Based Access Control) 基于角色的访问控制

听这很高大上的名词, 刚看到我也懵了, 也难怪参考博客的博主面试的时候被问懵了. 其实这东西在平常的已经用过很多遍了.

简单的来说, 就是对于每个用户逐一赋予相应的权限任务量实在是太大了. 其实, 大部分用户能够获得的权限是差不多的, 所以只要区分用户对于服务来说到底是怎样的关系, 也就是确定用户在服务中的角色, 相同的角色, 意味着用户能够用到的权限是一样的. 比如`消费者`, `商家`, `平台管理`之类的. 其实一想, 这就与平时的面向对象编程没有什么区别.

![](https://i-blog.csdnimg.cn/blog_migrate/90f4fbd9dcb2eae0683d0e4f4789f859.png)

上面这张别人做的图将RBAC的优势总结的非常的好, 一看就能理解.

当然我说的这种RBAC还是最基础的, 对于升级款的, 只能说非常的高端

RBAC0（Core RBAC）：最简单的RBAC形式，员工使用角色来获取权限（使用最多）。

基本模型有三个元素：用户、角色和权限。模型设计基于“多对多”原则，即多个用户可以具有相同的角色，一个用户可以具有多个角色。同样，您可以将同一权限分配给多个角色，也可以将同一角色分配给多个权限。

RBAC1（Hierarchical RBAC）：分层，建立在FlatRBAC规则之上，增加角色分层。

添加了第四个组件-层次结构，它定义了不同角色之间的资历关系。通过允许高级角色自动获取下级角色的权限，可以消除冗余，例如在角色重叠时必须指定某些权限。

RBAC2（Static separation of duty (SSD) relations）：受约束的，建立在分层RBAC0之上，并增加职责分离。

为了在存在利益冲突策略的情况下提供帮助，将根据用户分配添加角色之间的关系。例如，作为一个角色的成员的用户将无法被指派为具有利益冲突的角色的成员。

RBAC3（Dynamic separation of duty (DSD) relations）：RBAC3=RBAC1+RBAC2

与SSD一样，DSD限制了可用的用户权限，但基于不同的上下文。例如，根据会话期间执行的任务，用户可能需要不同级别的访问，DSD限制会话期间激活的权限。

原文链接：https://blog.csdn.net/m0_62006803/article/details/133962328

## JWT

​	其实已经用过很多次了, 但是其实对他的构成还不是很了解, 没想到这个也会被考, 感觉这八股是和算法一样学不完了.
了解JWT感觉还得先了解session.

### session

对于一个session其实具体存储在服务端, 这也是为什么, 如果在一个服务器上存储了大量的用户登录信息会造成服务器性能的下降. 

在服务器上存储的session具有一个id值, 而当产生了session后, 服务器会将session的id放入cookie进行返回, 当客户端请求时, 将sessionid放入cookie, 然后服务端进行检查, 然后服务可以根据session进行一些特殊的记录, 对用户进行有状态记录.

### JWT结构

以前还真没想过, 都是直接将先关的claim直接填写好就丢到函数里面进行生成返回了, 设置连JWT的传输安全都没考虑过. 

JWT 通常是这样的：`xxxxx.yyyyy.zzzzz`

1. HEADER 表头, 包括了令牌的类型和签名使用的算法等
2. Payload 负载, 包含了一些非敏感信息
3. Signature 签名 将上面两部分的编码后信息与指定的secret进行相对应的算法加密生成相对应的数字签名, 用于确保传输过程中数据没有被更改

![](https://oss.javaguide.cn/javaguide/system-design/jwt/jwt-composition.png)

## go语言垃圾回收

其实还是之前就接触过的东西, 只不过换了一种名词进行表达, 同时还将其定义更加明确化了而已.

对于一个程序运行时, 动态使用的最多的应该就是内存, 不同, 存放不同的数据. 但是有些数据很明显, 在经过一段时间的使用后, 其实就没有继续使用的意义了. 但是, 对于大部分语言来说, 都为程序员编程提供的自申请的一些地址空间. 一般将内存划分为堆空间和栈空间. 对于堆空间, 是可以申请的空间, 而栈空间一般直接由编译器进行管理.

当在栈空间内申请内存后, 使用一个指针表明其位置, 然后就可以使用了. 但是当后面这一块内存空间可能就不需要使用了, 但是, 如果只是直接将指向的指针改为新的地址, 那么原来的这一块地址就无法追踪, 相当于垃圾没有进行回收. 对于持续运行的程序来说, 如果没有进行重启, 那么这块地址就无法进行释放, 相当于对机器来说, 这块内存就消失了, 也就是`内存泄漏`.

### 垃圾回收机制

目前使用的好像是所谓的三色法+混合屏障机制. 其实就三色法来说还是比较好理解的.

垃圾回收机制最需要解决的就是内存泄漏, 而泄漏的内存都有一个特点, 就是不可达. 那么自然思路就是找到所有不可达的内存区, 将其标为可用就行了, 当然, 反向一下就是找到所有可达的内存, 那么剩下的就是不可达的. 

从根节点出发, 将所能抵达的内存块标记为灰色, 然后再从灰色的内存块出发, 将能到达的内存标为灰色, 将原来灰色的内存块标记为黑色, 重复执行, 直到最后没有灰色的内存块存在, 再执行回收机制, 将所有的不可达内存块即白色内存块释放. 当然这其中还插入了混合屏障机制, 当然我目前还没有完全理解.

