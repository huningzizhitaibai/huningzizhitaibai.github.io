<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Leetcode&amp;洛谷刷题记录与思考 | huning's hut</title><meta name="author" content="huning"><meta name="copyright" content="huning"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Leetcode&amp;&amp;洛谷刷题记录与思考p 7517题目链接：  对于第一篇题解的理解。 ··· 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits&#x2F;stdc++.h&gt;#define ll long long#define il inlineusing namespa">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode&amp;洛谷刷题记录与思考">
<meta property="og:url" content="http://example.com/2025/05/06/Leetcode&%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%9D%E8%80%83/index.html">
<meta property="og:site_name" content="huning&#39;s hut">
<meta property="og:description" content="Leetcode&amp;&amp;洛谷刷题记录与思考p 7517题目链接：  对于第一篇题解的理解。 ··· 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits&#x2F;stdc++.h&gt;#define ll long long#define il inlineusing namespa">
<meta property="og:locale">
<meta property="og:image" content="https://s2.loli.net/2025/05/06/dHhEmUxjBsNC4Fz.jpg">
<meta property="article:published_time" content="2025-05-06T10:47:42.000Z">
<meta property="article:modified_time" content="2025-05-06T11:56:52.000Z">
<meta property="article:author" content="huning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2025/05/06/dHhEmUxjBsNC4Fz.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Leetcode&洛谷刷题记录与思考",
  "url": "http://example.com/2025/05/06/Leetcode&%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%9D%E8%80%83/",
  "image": "https://s2.loli.net/2025/05/06/dHhEmUxjBsNC4Fz.jpg",
  "datePublished": "2025-05-06T10:47:42.000Z",
  "dateModified": "2025-05-06T11:56:52.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "huning",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="https://s2.loli.net/2024/06/06/Z9Iz2rNsJq7ihRA.jpg"><link rel="canonical" href="http://example.com/2025/05/06/Leetcode&amp;%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%9D%E8%80%83/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Leetcode&洛谷刷题记录与思考',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://s2.loli.net/2025/05/06/vZgaW8w42hcCjDm.png);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.loli.net/2024/06/06/9e4chpZGmvuM8CT.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">huning's hut</span></a><a class="nav-page-title" href="/"><span class="site-name">Leetcode&amp;洛谷刷题记录与思考</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Leetcode&amp;洛谷刷题记录与思考</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-05-06T10:47:42.000Z" title="Created 2025-05-06 18:47:42">2025-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-06T11:56:52.000Z" title="Updated 2025-05-06 19:56:52">2025-05-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Leetcode-洛谷刷题记录与思考"><a href="#Leetcode-洛谷刷题记录与思考" class="headerlink" title="Leetcode&amp;&amp;洛谷刷题记录与思考"></a>Leetcode&amp;&amp;洛谷刷题记录与思考</h1><h2 id="p-7517"><a href="#p-7517" class="headerlink" title="p 7517"></a>p 7517</h2><p>题目链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P7517"></a></p>
<p>对于第一篇题解的理解。</p>
<p>···</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="comment">//没有多大用的快读</span></span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> x=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(x&lt;<span class="string">&#x27;0&#x27;</span>||x&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;</span><br><span class="line">        x=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        s=s*<span class="number">10</span>+x-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        x=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f*s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N],b[N];<span class="comment">//b即为桶</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j*j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]%j!=<span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//关键判断</span></span><br><span class="line">            <span class="type">int</span> ans1=j,ans2=a[i]/j;</span><br><span class="line">            b[ans1]++;</span><br><span class="line">            <span class="keyword">if</span>(ans1!=ans2)<span class="comment">//特判</span></span><br><span class="line">                b[ans2]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;<span class="comment">//爆int警告</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=(ll)b[a[i]]<span class="number">-1</span>;<span class="comment">//累加，减一是减去自己的贡献</span></span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>···</p>
<p>其中有他自己创建的读取函数，目前我并不知道这样的读取函数对于直接使用系统自带函数能够提速多少，所以目前不予讨论. </p>
<p>这篇题解的思路在于直接将每个输入的数的因数直接统计出来,在b桶中计数, a中存储的是用户输入的结果. 最后再将用户输入的结果中的数所对应的桶中的结果倒出来, 同时减去来自自己出现时的那一次<code> 如果是i=j可以出现的情况应该就不用了</code>. 这样每次用户输入的数需要判断<br>$$<br>O(\sqrt{a_i})<br>$$<br>第二种方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> x=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(x&lt;<span class="string">&#x27;0&#x27;</span>||x&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;</span><br><span class="line">        x=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        s=s*<span class="number">10</span>+x-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        x=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f*s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    	b[<span class="built_in">read</span>()]++;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;i*j&lt;=N;j++)</span><br><span class="line">    		ans+=b[i]*b[i*j];</span><br><span class="line">    	ans+=b[i]*(b[i]<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次通过的是将尽可能的用户输入的数的倍数全部都进行计数. 如果用户输入的数的倍数曾经在用户输入的数据中, 就相当于可以组成一个数对. 不存在的话, 自然相应的数的次数为0, 最终累成和累加的结果就是0. 但是这样的操作,不经让人觉得速度并没有快多少, 应为都要将所有的数据判断一遍, 其中会有很多的含零的数据, 同时这对内存的消耗也很大.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于这道题, 看基本上的解题思路都是直接通过设置桶, 然后直接统计倍数. 这道题的数据都是<code>a_i&lt;=5e5</code> 所以直接将最大定位.</p>
<h3 id="自己根据学习写的代码"><a href="#自己根据学习写的代码" class="headerlink" title="自己根据学习写的代码"></a>自己根据学习写的代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> Maxn=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a[Maxn];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;temp);</span><br><span class="line">        a[temp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;Maxn;i++)&#123;</span><br><span class="line">        ans+=a[i]*(a[i]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">2</span>*i;j&lt;Maxn;j+=i)&#123;</span><br><span class="line">            ans+=a[i]*a[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="p-2701"><a href="#p-2701" class="headerlink" title="p 2701"></a>p 2701</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2701">洛谷</a></p>
<p>根据提供的题解是通过动态规划进行解答. </p>
<p>对于动态规划, 首先, 能够进行动态规划的题目首先可以满足暴力枚举, 但是由于数据量较大, 时间消耗过多. 其次, 可以根据节点, 会出现重复搜索或枚举,  将这部分的重复枚举进行删除或者记录, 达到省去的操作, 就可以称作是动态规划.  &#x3D;&#x3D;仅代表个人理解&#x3D;&#x3D;  .</p>
<p>对于这道题, 选取每一个点作为起点向别处延伸, 很明显可以通过暴力枚举进行解答, 同时, 通过不同的点进行容易想到, 会有很多重复, 所以就可以通过动态规划进行解题.</p>
<p>由于面积的延伸是正方形,倘若任意一点向想对边进行延伸,即 都需要考虑他周围的点,  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">min_3</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span> ,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="type">int</span> a[n][n],b[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            a[i][j]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x<span class="number">-1</span>][y<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            b[i][j]=a[i][j];</span><br><span class="line">    <span class="comment">//到这为止已经将所有的数据进行了初始化。</span></span><br><span class="line">    <span class="comment">//同时，此时的为0是第一行开始，0表示此处有树</span></span><br><span class="line">    <span class="comment">//当以点为右下角,此处同时可以代表就是此处可以达到的最大面积</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将每一个点代表的正方形可视化，或者是略加思考，可以的到每个点与周围点的关系</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][j])</span><br><span class="line">                b[i][j]+=min_3(b[i<span class="number">-1</span>][j<span class="number">-1</span>],b[i][j<span class="number">-1</span>],b[i<span class="number">-1</span>][j]);    <span class="comment">//不要忘记，只有当前的区域是没有树的才可能作为一个区域的右下角。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(b[i][j]&gt;max)</span><br><span class="line">                max=b[i][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min_3</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)</span><br><span class="line">        <span class="keyword">if</span>(a&lt;c)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(b&lt;c)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还是要考虑到的是，如何实现动态规划问题。关键在于如何找出者这之间的关系。</p>
<h2 id="p-2678"><a href="#p-2678" class="headerlink" title="p 2678"></a>p 2678</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2678">跳石头</a></p>
<p>通过思考题目可以知道，如果是通过暴力的方法进行解答，需要每次都找到最小的那段距离，然后再将最小的那段距离加到其相邻的两端距离中最小的那一段距离中去，然后再多次重复此方法，知道达到搬移石头的次数用尽。</p>
<p>很明显，这样的算法思路十分简单，但是遇到数据量大的题目时就略显费劲，先寻找最小的值为N，在判断最小值附近的值，这样的操作要做N遍，所以这是一个 O( n^2^ )的算法。</p>
<p>对于题解中大佬给出的二分答案法，我一开始并没有想明白对于一个无法进行排序的距离数组，如何使用需要有序为前提的二分查找. 但是通过阅读代码发现, 其中, 解题人的思路并非是将搬移次数作为了循环条件, 而是将搬移次数M当做了一个判断二分答案是否有效的条件. 其思路是, &#x3D;&#x3D;如果存在一个最大的最短距离为X,那么很明显, 其他的任何一段距离必定大于等于这段最短距离&#x3D;&#x3D; . </p>
<p>所以, 更具解题人的思路, 只需要查找在最长距离中的能够满足搬运次数少于或等于M次的x的最大值就行了<del>当然其实应该不会存在有小于的情况, 不然的话再搬一次不就有新的最大最小距离了吗</del> ,而这个答案明显一定在这之中,当然也可能会包括两端. 对于每个差找到的值, 判断如果需要达到这个查找值,对于当前数组所需要搬运的次数, 如果大于了M次的话, 就说明是太大, 将右边左移, 如果是小于M次就是将左边界右移,应为说明还可以有更大的距离.(其实,这样的算法,同样也会造成很多的数据其实不用算的,毕竟有些数据, 不可能是当前的这个数组能够组成的数据,但是, 在对于巨量的数据来说, 这多出来的计算量, 可能还没有暴力一个节点循环一遍计算量来得多 :cry: )</p>
<h2 id="14、最长公共前缀"><a href="#14、最长公共前缀" class="headerlink" title="14、最长公共前缀"></a>14、最长公共前缀</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SearchForMinString</span><span class="params">(<span class="type">char</span>** strs, <span class="type">int</span> strsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> minsize = <span class="built_in">strlen</span>(strs[<span class="number">0</span>]);  <span class="comment">//初始化最小的长度为第一个字符串的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(strs[i]) &lt; minsize)  <span class="comment">//如果有字符串的长度小于就取最小的</span></span><br><span class="line">            minsize = <span class="built_in">strlen</span>(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">longestCommonPrefix</span><span class="params">(<span class="type">char</span>** strs, <span class="type">int</span> strsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> minsize = SearchForMinString(strs, strsSize);   <span class="comment">//得到最小的字符串长度</span></span><br><span class="line">    <span class="type">char</span>* answer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * minsize+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(answer,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>) * minsize+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> answersize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; minsize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) <span class="comment">//有不一样的就直接返回答案</span></span><br><span class="line">                <span class="keyword">return</span> answer;</span><br><span class="line">        &#125;</span><br><span class="line">        answer[answersize] = strs[<span class="number">0</span>][i]; </span><br><span class="line">        answersize++;</span><br><span class="line">        <span class="comment">//说明所有的字符串该为位字符一样，将其赋值到结果的字符串中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于其中的字符串的malloc应用, 定要记住字符串结尾有一个<code>\0</code>, 但同时,<code>strlen</code>函数不会将这个计入字符长度内, 所以直接用这样的到的字符长度去创建一个字符串会导致最后一个<code>\0</code>消失, 导致构不成一个字符串. </p>
<p>与此同时, 对于malloc其分配的地址空间并不会直接给你初始化好, 所以建议搭配memset一起使用, 同时容易记住申请空间的大小.</p>
<h2 id="11、盛水最多的容器"><a href="#11、盛水最多的容器" class="headerlink" title="11、盛水最多的容器"></a>11、盛水最多的容器</h2><p>这道题，其实就是现实中的短板效应。任意选择的两个板能够盛水容量取决于最短的板. </p>
<p>对于这道题直接进行暴力求解非常简单. 但是对于一些测试用例会有超时的可能.</p>
<p>对于得到的木板数组处于无序状态,  对于任何的一个组合, 两端的木板选择只有两种. 假设从两端开始选取, 如果将两端任意一段的木板移动, 如果移动长版, 那么, 不论移动后的到的木板长度比原来大, 还是比原来小, 由于短板效应不会变, 但是底边必定变小, 所以选择的是的到的容积必定变小. 所以每次移动, 每次移动短板, 才能够是短板的长度进行变化. 这样的行为,可以一减小一定计算量.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> head,tail;</span><br><span class="line">    head=<span class="number">0</span>;tail=heightSize<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> maxCapacity=(height[head]&lt;height[tail]?height[head]:height[tail])*(tail-head);</span><br><span class="line">    <span class="keyword">while</span>(head!=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[head]&gt;height[tail])</span><br><span class="line">            tail--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            head++;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        temp=(height[head]&lt;height[tail]?height[head]:height[tail])*(tail-head);</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;maxCapacity)</span><br><span class="line">            maxCapacity=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209、长度最小的子数组"><a href="#209、长度最小的子数组" class="headerlink" title="209、长度最小的子数组"></a>209、长度最小的子数组</h2><h3 id="解法一、滑动窗口解法"><a href="#解法一、滑动窗口解法" class="headerlink" title="解法一、滑动窗口解法"></a>解法一、滑动窗口解法</h3><p>对于滑动窗口来说, 本题要求的子数组连续, 所以可以想象成一个窗口进行滑动. 如果该窗口是不变的话, 那么就需要每次对窗口的大小进行调整, 将窗口的大小从1~numsSize进行尝试, 显然,这样的尝试只比O(n2)暴力搜索快一点. 无法在时间限度内完成.</p>
<p>直接从小到大的对窗口进行增大, 存在的问题就是, 会有很多的较小的窗口其实没有计算的必要. 如果使用的是动态大小的窗口的话,可以对此进行一定的减少计算.</p>
<p>先逐步的扩大窗口,直到, 窗口中的数能够直接达到target, 然后再考虑是否对窗口中的数进行出队操作.(对于数组前面的数来说, 必须要是窗口达到当前的大小才能够达到target所以, 应去除窗口前面的数, 看看后面的数有没有可能.) 对窗口中的数进行出队, 当窗口内数的和,小于target的时候, 这时, 就当前的子数组的子数组长度+1的长度, 就是当前子数组能到达到的最小长度, 然后再向后进行查找.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯粹的窗口会导致许多小窗口的无谓计算, 尤其是当target和numsSize较大的时候</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> windowlenth=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(windowlenth&lt;=numsSize)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=numsSize-windowlenth;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j-i&lt;windowlenth;j++)&#123;</span><br><span class="line">                sum+=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">                <span class="keyword">return</span> windowlenth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        windowlenth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过动态窗口的大小进行搜索,先找到一个能够达到target的子数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">queue</span>[numsSize],head,tail;</span><br><span class="line">    <span class="type">int</span> queuesum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=numsSize+<span class="number">1</span>;</span><br><span class="line">    head=tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行入队操作同时统计队内和</span></span><br><span class="line">        <span class="type">int</span> temp_ans;</span><br><span class="line">        <span class="built_in">queue</span>[tail]=nums[i];</span><br><span class="line">        tail++;</span><br><span class="line">        queuesum+=nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//达到target的时候就从头出队</span></span><br><span class="line">        <span class="keyword">if</span>(queuesum&gt;=target)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将能够缩小的全部出队</span></span><br><span class="line">            <span class="keyword">while</span>(queuesum&gt;=target)&#123;</span><br><span class="line">                queuesum-=<span class="built_in">queue</span>[head];</span><br><span class="line">                head++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            temp_ans=tail-head+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;temp_ans)</span><br><span class="line">                ans=temp_ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == numsSize+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="p1002"><a href="#p1002" class="headerlink" title="p1002"></a>p1002</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1002">过河卒</a></p>
<p>其实就是经典动态规划，需要想清楚，几个状态，通过状态的转移找到公式，然后根据公式进行推理即可。</p>
<h2 id="p1004"><a href="#p1004" class="headerlink" title="p1004"></a>p1004</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1004">方格取数</a></p>
<p>通过我的思考，也是动态规划根据题目的意思，但是，这次需要遍历两次，需要在第一次的时候，将取到的数置零。让后再进行第二次遍历，进行同样的操作。但是需要进行。但是对于一个直接的动态规划而言，并没有对路劲进行记忆，所以，如何对于一个数组进行置零是很大的问题，对于我的思维来说，我会考虑在加上一个大小合适的记忆数组，对于每一次的路径进行记忆，但是，我认为这十分地耗费空间，而且代码也并不优雅。</p>
<p>通过题解的思考，这道题的解法是一个四维的动态规划，由于平时遇到的数据二维居多，对于思维的数组，一时间难以理解。最主要的在于，第一遍与第二遍是否应该分开思考的问题。</p>
<p>通过前面对于二维动态规划的思考，如果是按照模拟的方法，对于每次数组的遍历都采用分离的思想，则每次都是贪心算法，最终获得的是局部最优解，难以证明就是整体最优解。所以在思考四维的动态规划时，也不能将两次遍历分开思考。</p>
<p>对于相关的四维动态规划数组，其存储的应该就是，一次和第二次走到相关x，y位置是取到的最大值。两次走法应该是在相同时空观下的。但是，由于第一次走后会取走数，所以最终，在走到相同位置时，要减去相关位置的数。一定要将动态规划数组在某某位置的值和相应数组在某某位置的值分开思考。</p>
<h2 id="1010"><a href="#1010" class="headerlink" title="1010"></a>1010</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1010">幂次方</a></p>
<p>通过提示，想到对于一个数进行问题的分解，每次只做一层，用递归的方法。</p>
<p>很容易想到需要用到二进制进行求解。</p>
<p>通过阅读大佬的题解能得到一个很新的思路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fff</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">14</span>;i&gt;=<span class="number">0</span>;i--) <span class="comment">//两万的数据最多是2（14）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pow</span>(<span class="number">2</span>,i)&lt;=x)&#123;</span><br><span class="line">        <span class="comment">//pow（n，m）在cmath库中，返回n^m；枚举出第一个幂次方</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;2&quot;</span>; <span class="comment">//2（1）不用再往后分解了且2^1输出为2，单独出来</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;2(0)&quot;</span>; <span class="comment">//2（0）也不用再往后分解了，单独出来</span></span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//若i&gt;1则继续分解指数i</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;2(&quot;</span>;</span><br><span class="line">            <span class="built_in">fff</span>(i);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x-=<span class="built_in">pow</span>(<span class="number">2</span>,i); <span class="comment">//继续循环分解余下的</span></span><br><span class="line">            <span class="keyword">if</span>(x!=<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;+&quot;</span>;</span><br><span class="line">            <span class="comment">//加号处理的最简单方法：若此x还没分解完，则后面还有项，所以输出一个+号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="built_in">fff</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="DFS的算法学习"><a href="#DFS的算法学习" class="headerlink" title="DFS的算法学习"></a>DFS的算法学习</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/">LCR 175. 计算二叉树的深度 - 力扣（LeetCode）</a></p>
<p>非常简单的一道DFS的算法题目，计算二叉树的深度， 其实计算什么的深度都是一样的。这道题目相当于已经将应用的场景抽象化了，所以难度不高，在正式的应用中，真正的难度在于如何能够想到这个算法。</p>
<p>DFS算法的根本是枚举，将所有可能的情况都按照一定的顺序进行了枚举。关键在于回溯的机制。当一条路走到底后，就进行回溯，将之前还存在有路没走的节点再次进行。</p>
<p>话不多说上源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ldepth = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rdepth = <span class="number">1</span>;</span><br><span class="line">        ldepth += <span class="built_in">calculateDepth</span>(root-&gt;left);</span><br><span class="line">        rdepth += <span class="built_in">calculateDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ldepth &gt; rdepth ? ldepth : rdepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></p>
<p>简单的DFS算法可以进行实现，先找到最小的树，然后将其反转，最后在将其根节点进行反转。但是唯一的问题在于，原来又有一个疑问是有可能左右指树可能有空，但是想想，其实有空也应该进行反转，所以在写的时候疑惑解消了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1219">八皇后</a></p>
<p>同样需要用到DFS算法，但是这题对我来说的难点在于，如何寻找状态和判断对角线已经被占用</p>
<p>通过题解，可得将每次下完一个棋，棋盘剩余的资源为一个状态，向下进行传递。同时，对于对角线来说，存在一定的规律，从右到左的行下标与列下标的和在同一对角线相等且唯一，从左到右，行下标与列下标的差在同一对角线值相等且唯一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> size;  <span class="comment">//表格的大小</span></span><br><span class="line">        <span class="type">int</span> rows[<span class="number">14</span>],colunms[<span class="number">14</span>],r_l[<span class="number">27</span>],l_r[<span class="number">27</span>];</span><br><span class="line">        <span class="type">int</span> solutions;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetSoutions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> solutions;</span><br><span class="line">        &#125;   <span class="comment">//用于输出解的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            std::cin&gt;&gt;n;</span><br><span class="line">            <span class="keyword">this</span>-&gt;size = n;</span><br><span class="line">            <span class="built_in">queen</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="keyword">this</span>-&gt;<span class="built_in">GetSoutions</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(solutions&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i&lt;=size ; i++)</span><br><span class="line">                    std::<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rows[i]);</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;solutions++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询合适的位置放置一枚queen，如果没有判断输出，有则标记状态，在进行下次状态转移</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">queen</span><span class="params">(<span class="type">int</span> row)</span></span>&#123;</span><br><span class="line">            <span class="comment">//row大于行数size，说明到达边界，要么是全部放置完成</span></span><br><span class="line">            <span class="keyword">if</span>(row&gt;size)&#123;</span><br><span class="line">                <span class="built_in">myprint</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//保证字典序从1开始</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">1</span> ;col&lt;=size;col++)&#123;</span><br><span class="line">                    <span class="comment">//说明相关列没有被占领，对角线也没有</span></span><br><span class="line">                    <span class="comment">//在此处我曾将row与col差的值进行互换,输出的结果就是错误的,目前还没具体明白是为什么</span></span><br><span class="line">                    <span class="keyword">if</span>((!colunms[col]) &amp;&amp; (!r_l[col+row]) &amp;&amp; (!l_r[row-col+size]))&#123;</span><br><span class="line">                        rows[row] = col;    <span class="comment">//直接记录相关的列，方便下次进行输出</span></span><br><span class="line">                        colunms[col] = <span class="number">1</span>;</span><br><span class="line">                        r_l[col+row] = <span class="number">1</span>;</span><br><span class="line">                        l_r[row-col+size] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">queen</span>(row<span class="number">+1</span>);   <span class="comment">//状态转移，按照字典序，需从行号递增</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//从上个函数跳出，说明已经完成了当前的这个状态的记录的所有结果需要重新进行上个状态的记录，</span></span><br><span class="line">                        <span class="comment">//故清除当前状态的记录</span></span><br><span class="line">                        colunms[col] = r_l[col+row] = l_r[row-col+size] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution ans = <span class="built_in">Solution</span>();</span><br><span class="line">    ans.<span class="built_in">Solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5194">P5194</a></p>
<p>通过阅读题目，容易直接写出深度优先的算法，同时还可以想到类似背包一类。但是，分析数据的大小为1000，至少要做1000^2次运算, 除了AC的答案,其他全部超时了. </p>
<p>所以设计到深度优先搜索的算法优化, 就是剪枝的理论.</p>
<p>目前来说, 对于剪枝的理解就是, 通过对题目数据进行分析, 方向对于一些搜索的路径不需要再次搜索. 如题中, 但当前的砝码超出了承受范围C, 则之后的砝码都会超出, 可以直接返回, 这点只需要在判断时加上return语句即可, 但同时, 当前砝码必定大于等于前面两个砝码的质量之和, 但加上当前的砝码超出时, 直接返回后, 由于上一个状态并不能知道当前状态的下一个状态已经超出, 还会再次跳过下一个状态, 直接进行下下个, 这个对于当前的数据集来说就没有必要了, 下一个砝码超出, 则下下个砝码必定超出.</p>
<p>同时存在关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weight[i]+weight[i<span class="number">+3</span>]&lt;C;</span><br><span class="line">weight[i]+weight[i<span class="number">+1</span>]+weight[i<span class="number">+2</span>]&lt;C;</span><br><span class="line"><span class="comment">//所以在i状态下,可以直接跳到i+3的状态,避免了对i+1,i+2的计算,所以,也许直接从大到小搜索才是正解?</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[<span class="number">1005</span>],a[<span class="number">1005</span>],ans,n,c;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur,<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;  <span class="comment">//cur是为了标记当前的位置，x是记录当前的大小，防止超过C</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;c) <span class="keyword">return</span>; <span class="comment">//此时累加和已经超过了承受的范围</span></span><br><span class="line">    <span class="keyword">if</span>(sum[cur<span class="number">-1</span>]+x&lt;=c)&#123;    <span class="comment">//对于当前位置来说，如果前面的砝码全部取上加上现在的质量没有超过C，减少了前几次的累加操作</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,sum[cur<span class="number">-1</span>]+x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans,x);   <span class="comment">//当前状态已经是累加完一个数的状态了，前缀和判断的是该数之前的所有大小，进行细分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;cur;i++)</span><br><span class="line">        <span class="built_in">dfs</span>(i,x+a[i]);      <span class="comment">//从第一次最大的做不了后，他直接就从最小的开始一个个递归了，从这里开始是常态化的搜索，剪枝操作在上一步的前缀和里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];   <span class="comment">//前缀和数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1162">P1162 填色问题</a></p>
<p>做这道题的目的是为了能够锻炼BFS算法的思维，但是在题解中出现了比较优秀的DFS算法值得学习其中的思想</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">32</span>][<span class="number">32</span>], b[<span class="number">32</span>][<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n, i, j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; n + <span class="number">1</span> || q &lt; <span class="number">0</span> || q &gt; n + <span class="number">1</span> || a[p][q] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 说明已经超过了搜索的范围</span></span><br><span class="line">    a[p][q] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">dfs</span>(p + dx[i], q + dy[i]); <span class="comment">// 先该点的四周进行搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; b[i][j];</span><br><span class="line">            <span class="keyword">if</span> (b[i][j] == <span class="number">0</span>)</span><br><span class="line">                a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a[i][j] = <span class="number">2</span>; <span class="comment">// 目前这里为什么直接赋值为2还不清楚</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 这的dfs的作用是通过染色法，将有被围墙保护起来的水进行染色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 说明这里的水是之前被围墙保护起来的没有染色</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; b[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;                           <span class="comment">// a数组中保存的是将原来包括所有墙一起染色的答案。</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解的发布者的整体思想是类似在画图选择颜色中的方向选择。</p>
<p>​	在一开始的思考中，我都是通过正向的思维，在想，如何判断到达围墙边缘，同时判断处于围墙的内部。<br>​	从现在看来，如果我使用正向思维的DFS算算法，就需要首先找到属于围墙中心的一点，然后从这个点开始做扩散。但是如何判断这个点是围墙内的点是一个非常困难的问题，虽然从题目中已经确定，闭合圈中一定可以到达。其实可从触碰到的任意一个点进行判断，但是总感觉有点不够优雅。</p>
<p>​	大佬的解法是直接从外围开始，将颜料倒进水里，通过dfs的扩散效果，将除了被围墙保护起来的水进行染色，包括围墙，然后再通过和原来的状态进行对比，得到那些水是被围墙保护起来的，总体效果类似于反选。</p>
<h2 id="BFS的学习"><a href="#BFS的学习" class="headerlink" title="BFS的学习"></a>BFS的学习</h2><p>对于BFS来说, 就相当于是对一棵树进行层序遍历, 然后再得出结果, 需要将每一个节点对应的下一个节点进行记录. 可以想到是先进先出的思想.</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1162">P1162 填色问题</a></p>
<p>同样也是这个问题, 但是采用的是BFS的想法</p>
<p>题解的提供者同样也是使用的反选的方法进行搜索的. 可见思路的重要性.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">31</span>;   <span class="comment">//从1开始记录图像位置</span></span><br><span class="line"><span class="type">int</span> map[M][M];</span><br><span class="line"><span class="type">bool</span> vis[M][M];     <span class="comment">//用于记录是否是边界块，其实反向就是说这些不是被保护的块</span></span><br><span class="line"><span class="type">int</span> n,m,a,b,c;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(x);</span><br><span class="line">    q.<span class="built_in">push</span>(y);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span>  w = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> e = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后向该点的四周进行判断</span></span><br><span class="line">        <span class="comment">//只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(map[w<span class="number">+1</span>][e]== <span class="number">0</span> &amp;&amp; w!=n &amp;&amp; !vis[w<span class="number">+1</span>][e]) vis[w<span class="number">+1</span>][e] = <span class="number">1</span> , q.<span class="built_in">push</span>(w<span class="number">+1</span>), q.<span class="built_in">push</span>(e); </span><br><span class="line">        <span class="comment">//原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。</span></span><br><span class="line">        <span class="keyword">if</span>(map[w<span class="number">-1</span>][e] == <span class="number">0</span> &amp;&amp; w != <span class="number">1</span> &amp;&amp; !vis[w<span class="number">-1</span>][e] )    vis[w<span class="number">-1</span>][e] = <span class="number">1</span>,q.<span class="built_in">push</span>(w<span class="number">-1</span>),q.<span class="built_in">push</span>(e);</span><br><span class="line">        <span class="keyword">if</span>(map[w][e<span class="number">+1</span>] == <span class="number">0</span> &amp;&amp; e != n &amp;&amp; !vis[w][e<span class="number">+1</span>] )    vis[w][e<span class="number">+1</span>] = <span class="number">1</span>,q.<span class="built_in">push</span>(w),q.<span class="built_in">push</span>(e<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">if</span>(map[w][e<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; e != <span class="number">1</span> &amp;&amp; !vis[w][e<span class="number">-1</span>] )    vis[w][e<span class="number">-1</span>] = <span class="number">1</span>,q.<span class="built_in">push</span>(w),q.<span class="built_in">push</span>(e<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span> ;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;map[i][j];</span><br><span class="line">            <span class="keyword">if</span>(map[i][j] == <span class="number">1</span>) vis[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i+=n<span class="number">-1</span>)&#123; <span class="comment">//直接就判断两个对角上的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i][j]) <span class="keyword">continue</span>;     <span class="comment">//说明触发到了边界点从这个点</span></span><br><span class="line">            <span class="built_in">bfs</span>(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i = i + n - <span class="number">1</span> )        <span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span> ; j &lt;= n ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j][i])    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">bfs</span>(j,i);            <span class="comment">//十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点</span></span><br><span class="line">                                <span class="comment">//但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)                <span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span> ; j &lt;= n ; j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i][j])    cout&lt;&lt;<span class="string">&quot;2&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;        <span class="comment">//如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； </span></span><br><span class="line">            <span class="keyword">else</span>     cout&lt;&lt;map[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的方法还是比较符合典型的BFS的实现方法的</p>
<p>这里放一下我根据上一个题解进行的优化尝试<br>根据将外围包裹一圈, 这样就可以直接是判断点进行自由移动, 可以减少一点代码量, 但是多了一点计算.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">32</span>;   <span class="comment">//从1开始记录图像位置</span></span><br><span class="line"><span class="type">int</span> map[M][M];</span><br><span class="line"><span class="type">bool</span> vis[M][M];     <span class="comment">//用于记录是否是边界块，其实反向就是说这些不是被保护的块</span></span><br><span class="line"><span class="type">int</span> n,m,a,b,c;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(x);</span><br><span class="line">    q.<span class="built_in">push</span>(y);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span>  w = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> e = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后向该点的四周进行判断</span></span><br><span class="line">        <span class="comment">//只有周围是未被包围的，同时不超出范围，同时没有被判断过，就将这个点存入。稍后再进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(map[w<span class="number">+1</span>][e]== <span class="number">0</span> &amp;&amp; w!=n<span class="number">+1</span> &amp;&amp; !vis[w<span class="number">+1</span>][e]) vis[w<span class="number">+1</span>][e] = <span class="number">1</span> , q.<span class="built_in">push</span>(w<span class="number">+1</span>), q.<span class="built_in">push</span>(e); </span><br><span class="line">        <span class="comment">//原题解说可以用结构体。确实很多地方用结构体的话，代码的可读性会更高。</span></span><br><span class="line">        <span class="keyword">if</span>(map[w<span class="number">-1</span>][e] == <span class="number">0</span> &amp;&amp; w != <span class="number">0</span> &amp;&amp; !vis[w<span class="number">-1</span>][e] )    vis[w<span class="number">-1</span>][e] = <span class="number">1</span>,q.<span class="built_in">push</span>(w<span class="number">-1</span>),q.<span class="built_in">push</span>(e);</span><br><span class="line">        <span class="keyword">if</span>(map[w][e<span class="number">+1</span>] == <span class="number">0</span> &amp;&amp; e != n<span class="number">+1</span> &amp;&amp; !vis[w][e<span class="number">+1</span>] )    vis[w][e<span class="number">+1</span>] = <span class="number">1</span>,q.<span class="built_in">push</span>(w),q.<span class="built_in">push</span>(e<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">if</span>(map[w][e<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; e != <span class="number">0</span> &amp;&amp; !vis[w][e<span class="number">-1</span>] )    vis[w][e<span class="number">-1</span>] = <span class="number">1</span>,q.<span class="built_in">push</span>(w),q.<span class="built_in">push</span>(e<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span> ;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;map[i][j];</span><br><span class="line">            <span class="keyword">if</span>(map[i][j] == <span class="number">1</span>) vis[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i+=n)&#123; <span class="comment">//直接就判断两个对角上的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i][j]) <span class="keyword">continue</span>;     <span class="comment">//说明触发到了边界点从这个点</span></span><br><span class="line">            <span class="built_in">bfs</span>(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i = 1 ; i &lt;= n ; i = i + n - 1 )        //</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for(int j = 1 ; j &lt;= n ; j++)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         if(vis[j][i])    continue;</span></span><br><span class="line">    <span class="comment">//         bfs(j,i);            //十分重要！！！把它换过来，枚举另一组边界;可能会存在中间被拦腰隔断的情况，BFS无法自动移动到其他点</span></span><br><span class="line">    <span class="comment">//                             //但可以采用上一个题解给的方法将，再整体的外围再进行一圈包裹，就可以保证必定能够自由移动。</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)                <span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span> ; j &lt;= n ; j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i][j])    cout&lt;&lt;<span class="string">&quot;2&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;        <span class="comment">//如果未被标记，这一定是闭合‘1’中的‘0’， 输出‘2’； </span></span><br><span class="line">            <span class="keyword">else</span>     cout&lt;&lt;map[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1443">P1443</a></p>
<p>第一道自己写的题目, 但是写着写着从BFS写成了DFS, 虽然当然直接进行DFS显然超时了, 需要进行剪枝.先贴一下没有剪枝过的代码, 作为对比</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">401</span>][<span class="number">401</span>],b[<span class="number">401</span>][<span class="number">401</span>],n,m,x,y;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">bool</span> c[<span class="number">401</span>][<span class="number">401</span>];</span><br><span class="line"><span class="comment">// queue&lt;int&gt; q;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x+dx[i] &lt; <span class="number">1</span> || y+dy[i]&lt; <span class="number">1</span>  || x+dx[i] &gt; n || y+dy[i]&gt;m || c[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[x+dx[i]][y+dy[i]] !=<span class="number">-1</span>)</span><br><span class="line">                b[x+dx[i]][y+dy[i]] = <span class="built_in">min</span>(b[x+dx[i]][y+dy[i]],b[x][y]<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b[x+dx[i]][y+dy[i]] = b[x][y]<span class="number">+1</span>;</span><br><span class="line">            c[x][y] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(x+dx[i],y+dy[i]);</span><br><span class="line">            c[x][y] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            b[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DFS</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            cout&lt;&lt;b[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想来想去没想到有什么剪枝的方法，因为本身就要判断从这个点进行会不会比另一个点进行更快，就相当于时每个点都进行判断了，要对每一条支路进行分析，剪不掉，意味着层数越深，搜索的次数就越多，因为会有很多的支路。所谓的剪枝，也许就是从层数的角度出发，但是这样就是BFS了，所以最终还是使用BFS进行求解。<del>对于搜索来说，如何选择合适的搜索方式确实时需要慎重考虑的，回旋镖咋回来了</del></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">401</span>][<span class="number">401</span>],b[<span class="number">401</span>][<span class="number">401</span>],n,m,x,y;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">bool</span> c[<span class="number">401</span>][<span class="number">401</span>];	<span class="comment">//像水扩散一样, 从一个点开始出发,将他的每层的连接进行判断,重叠部分就不用判断了,所以不用取消状态.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x+dx[i] &lt; <span class="number">1</span> || y+dy[i]&lt; <span class="number">1</span>  || x+dx[i] &gt; n || y+dy[i]&gt;m || c[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[x+dx[i]][y+dy[i]] !=<span class="number">-1</span>)</span><br><span class="line">                b[x+dx[i]][y+dy[i]] = <span class="built_in">min</span>(b[x+dx[i]][y+dy[i]],b[x][y]<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b[x+dx[i]][y+dy[i]] = b[x][y]<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(x+dx[i]);</span><br><span class="line">            q.<span class="built_in">push</span>(y+dy[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c[x][y] = <span class="number">1</span>;	<span class="comment">//之前不小心放在循环的里面了,还是要注意什么时候要对状态使用完成进行标记,放里面就有DFS的味道了</span></span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> n_x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> n_y= q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">BFS</span>(n_x,n_y);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            b[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">BFS</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            cout&lt;&lt;b[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="30、串联所有单词的字串"><a href="#30、串联所有单词的字串" class="headerlink" title="30、串联所有单词的字串"></a>30、串联所有单词的字串</h2><p>滑动窗口优化，我尝试的第一道困难题，毕竟不是算法竞赛，没有想象中难么难。当还是有一定挑战的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#我的解法只使用了简单的枚举，其实并不涉及滑动窗口，在重复度高的情况中容易多次统计，造成计算重复</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        m,n,ls = <span class="built_in">len</span>(words),<span class="built_in">len</span>(words[<span class="number">0</span>]),<span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ls):</span><br><span class="line">            <span class="keyword">if</span>(i + m*n &gt;ls):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            differ = Counter()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                word = s[i+j*n : i+(j+<span class="number">1</span>)*n]</span><br><span class="line">                differ[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">                differ[word] -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> differ[word] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> differ[word]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(differ) == <span class="number">0</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用滑动窗口，在最外层的循环中，循环的长度为一个单词的长度，如果是单词整体的减少，通过滑动窗口已经能够进行判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        m, n, ls = <span class="built_in">len</span>(words), <span class="built_in">len</span>(words[<span class="number">0</span>]), <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i + m * n &gt; ls:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            differ = Counter()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                word = s[i + j * n: i + (j + <span class="number">1</span>) * n]</span><br><span class="line">                differ[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">                differ[word] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> differ[word] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> differ[word]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">#下一段是使用滑动窗口的优化</span></span><br><span class="line">                    <span class="comment">#步长为n代表窗口的整体滑动</span></span><br><span class="line">            <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(i, ls - m * n + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> start != i:</span><br><span class="line">                    <span class="comment">#word为窗口滑动进入的新词</span></span><br><span class="line">                    word = s[start + (m - <span class="number">1</span>) * n: start + m * n]</span><br><span class="line">                    differ[word] += <span class="number">1</span></span><br><span class="line">                    <span class="comment">#可能上一个词组不是,刚好欠这个词</span></span><br><span class="line">                    <span class="keyword">if</span> differ[word] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> differ[word]</span><br><span class="line">                    <span class="comment">#上一个</span></span><br><span class="line">                    word = s[start - n: start]</span><br><span class="line">                    differ[word] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> differ[word] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> differ[word]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(differ) == <span class="number">0</span>:</span><br><span class="line">                    res.append(start)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="135、分发糖果"><a href="#135、分发糖果" class="headerlink" title="135、分发糖果"></a>135、分发糖果</h2><p>第二道困难题，关于数组的，确实有难度，在于一点巧劲，常规解法的话其实需要对题目的数学模型有一定的理解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> candy(<span class="built_in">int</span>* ratings, <span class="built_in">int</span> ratingsSize) &#123;</span><br><span class="line">    <span class="built_in">int</span> left[ratingsSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ratingsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> right = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = ratingsSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; ratingsSize - <span class="number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret += fmax(left[i], right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https://leetcode.cn/problems/candy/solutions/<span class="number">533150</span>/fen-fa-tang-guo-by-leetcode-solution-f01p/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        ret = <span class="number">1</span></span><br><span class="line">        inc, dec, pre = <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt;= ratings[i - <span class="number">1</span>]:</span><br><span class="line">                dec = <span class="number">0</span></span><br><span class="line">                pre = (<span class="number">1</span> <span class="keyword">if</span> ratings[i] == ratings[i - <span class="number">1</span>] <span class="keyword">else</span> pre + <span class="number">1</span>)</span><br><span class="line">                ret += pre</span><br><span class="line">                inc = pre</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dec += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dec == inc:</span><br><span class="line">                    dec += <span class="number">1</span></span><br><span class="line">                ret += dec</span><br><span class="line">                pre = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https://leetcode.cn/problems/candy/solutions/<span class="number">533150</span>/fen-fa-tang-guo-by-leetcode-solution-f01p/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、接雨水</h2><p>第三道困难题，本来还想通过自己通过的，但是还是被最极端的用例给爆内存了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#自己的解法， 通过每一层进行扫描，但是前提是根据给出的数据创建一个相关的矩阵判断边界，有点像是模拟的做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#创建一个矩阵记录边界</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        max_height = <span class="built_in">max</span>(height)</span><br><span class="line">        bow = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_height)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height[i]):</span><br><span class="line">                bow[j][i] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#只有判断到一行中两个一之间的区域的时候，直接将其充满，毕竟没说石柱会有空隙</span></span><br><span class="line">        rain = <span class="number">0</span></span><br><span class="line">        start=end=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_height):</span><br><span class="line">            start=end=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> bow[i][j] == <span class="number">1</span> :</span><br><span class="line">                     rain += end - start</span><br><span class="line">                     start = end = j</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> bow[i][start] ==<span class="number">1</span>:</span><br><span class="line">                        end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rain</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#总体来说，在构建矩阵的时候，内存消耗过大，被极端用例给爆了</span></span><br></pre></td></tr></table></figure>

<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h2><p>本身题目并不难, 思路也比较好像, 但是双指针的思路我一时间还是没有想到的, 同时关于他的时间优化我觉得还是有必要记录一下的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一遍的双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doit</span>(<span class="params">self,n: <span class="built_in">int</span></span>):</span><br><span class="line">        nums=[]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>):</span><br><span class="line">            nums.append(n%<span class="number">10</span>)</span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            res += nums[i]**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        fast = n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> fast == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            fast = <span class="variable language_">self</span>.doit(fast)</span><br><span class="line">        slow = n</span><br><span class="line">        <span class="keyword">while</span>(fast != slow):</span><br><span class="line">            slow = <span class="variable language_">self</span>.doit(slow)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                fast = <span class="variable language_">self</span>.doit(fast)</span><br><span class="line">                <span class="keyword">if</span> fast == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 将每次快指针指向的数组</span></span><br></pre></td></tr></table></figure>

<h2 id="6、z字型变换"><a href="#6、z字型变换" class="headerlink" title="6、z字型变换"></a>6、z字型变换</h2><p>还是比较简单的，就是纯粹的模拟，但是有一个需要注意的地方，会使题目更简单. 虽然在字体形式上在上升行中会出现很多的空, 但是对于题目要求的输出来说并没有需要按照z字的形式输出, 所以直接忽略空白即可, 所以只需要考虑每个字符应该处在哪一行,同时按照顺序执行就行.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> numRows &lt; <span class="number">2</span> : <span class="keyword">return</span> s <span class="comment">#小于两行的化和直接输出没有区别</span></span><br><span class="line">        res = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numRows)]</span><br><span class="line">        i, flag = <span class="number">0</span>,-<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s :</span><br><span class="line">            res[i]+= c</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == numRows-<span class="number">1</span>:</span><br><span class="line">                flag = -flag</span><br><span class="line">            i+=flag</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)            </span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<h2 id="1715、分割回文字符IV"><a href="#1715、分割回文字符IV" class="headerlink" title="1715、分割回文字符IV"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning-iv/description/">1715、分割回文字符IV</a></h2><p>困难题，确实有点出乎意料. 对于一般的字符来说, 还没用到过动态规划. 要考虑到对于一个字符串来说, 如何分割确保分割出来的子字符串为回文,并没有确定的公式, 所以就说明必须要进行一些枚举运算. 但是, 在枚举的过程中, 会存在很多重复的判断是否为回文的字符串, 对于一个变长的子串, 其子串如果在前面已经判断过是否为回文, 那么在对其重复计算明显浪费了算力.</p>
<p>官方题解使用了一个动态规划数组, 在于任何子串, 其掐去两端的子串如果为回文, 那么, 掐去的两端字符如果相等, 那么其就为回文. 这样每次回文判断其实只需要两次计算.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPartitioning</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] isPalindrome = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定每次判断字符的长度，由于只是对判断原字符中的子字符是否是回文，所以只需要从小到大</span></span><br><span class="line">        <span class="comment">//又因为设计上的动态规划</span></span><br><span class="line">        <span class="comment">//本部分先将所有的子串是否为回文进行记录，虽然其中也有许多的冗余计算， 但是还是相对来说较少</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>; length &lt; n; length++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt;= n -length; start++)&#123;</span><br><span class="line">                <span class="comment">//end是可以取到的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + length-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">                    isPalindrome[start][end] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(length == <span class="number">2</span>) &#123;</span><br><span class="line">                    isPalindrome[start][end] = (s.charAt(start) == s.charAt(end));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//因为length从小到大，所以判断必定是从3-&gt;2,由4-&gt;3, 而其长度为这些的子串都会在前面的计算中判断过</span></span><br><span class="line">                    isPalindrome[start][end] = ((s.charAt(start)==s.charAt(end)) &amp;&amp; isPalindrome[start+<span class="number">1</span>][end-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接确定中间字符串的位置即可</span></span><br><span class="line">        <span class="comment">//1、0-&gt;start-1,2、start-&gt;end, 3、end+1-&gt;length</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;start&lt;n-<span class="number">1</span>;start ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPalindrome[<span class="number">0</span>][start-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end=start; end &lt;n-<span class="number">1</span>;end++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome[start][end] &amp;&amp; isPalindrome[end+<span class="number">1</span>][n-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="汇总区间"><a href="#汇总区间" class="headerlink" title="汇总区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150">汇总区间</a></h2><p>也不知道怎么之前就没有写出来, 非常普通的一个模拟. 但是他的判断逻辑写的有点有趣</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">summaryRanges</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ans []<span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="number">0</span>, <span class="built_in">len</span>(nums); i&lt;n; &#123;</span><br><span class="line">        left := i</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//类似一个if判断语句， 但是这个写法很抽象</span></span><br><span class="line">        <span class="keyword">for</span> i++; i&lt;n &amp;&amp; nums[i<span class="number">-1</span>] + <span class="number">1</span> == nums[i];i++ &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        s := strconv.Itoa(nums[left])</span><br><span class="line">        <span class="keyword">if</span> left &lt; i<span class="number">-1</span> &#123;</span><br><span class="line">            s += <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[i<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3306-元音辅音字母计数-II"><a href="#3306-元音辅音字母计数-II" class="headerlink" title="3306.元音辅音字母计数 II"></a>3306.元音辅音字母计数 II</h2><p>当读完题目就想到了滑动窗口发,  不知道算不算种进步, 虽然我脑海中的滑动窗口并没有实现. 感觉还是欠点, 或者说感觉我的逻辑太麻烦不够简洁. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countOfSubstrings</span><span class="params">(word <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    word_len = <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">var</span> ans <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> win_len := k+<span class="number">5</span>; win_len &lt;= word_len ;win_len++ &#123;</span><br><span class="line">        occur := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;e&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;i&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;o&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;u&#x27;</span>:<span class="number">0</span>&#125;</span><br><span class="line">        other := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span> ;i &lt;=win_len; i++ &#123;</span><br><span class="line">            _, ok := <span class="keyword">map</span>[word[i]]</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                <span class="keyword">map</span>[word[i]]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                other++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....不行了, 太麻烦了, 确实不是一个好的答案, 不是很好模拟, 判断太多了.到后面就容易造成...</span></span><br></pre></td></tr></table></figure>

<p>题解给出的答案是, 通过将统计恰好改为至少. 感觉也是一种题型.</p>
<p>如果将题目先改成<code>至少出现辅音k次</code>, 那么判断逻辑就会减少, 只要确保形成的子字符串中, 至少保存了k个即以上就行. 而恰好则可以转化成count(k) - count(k+1)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countOfSubstrings</span><span class="params">(word <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	vowels := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">bool</span>&#123;<span class="string">&#x27;a&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;e&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;i&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;o&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;u&#x27;</span>: <span class="literal">true</span>&#125; <span class="comment">//用于快速判断是否为元音</span></span><br><span class="line">	count := <span class="function"><span class="keyword">func</span><span class="params">(m <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">		n := <span class="built_in">len</span>(word)</span><br><span class="line">		<span class="keyword">var</span> res <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">		consonants := <span class="number">0</span></span><br><span class="line">		occur := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">		<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="comment">//找到以当前i开头的子串能满足的最短子串</span></span><br><span class="line">			<span class="keyword">for</span> j &lt; n &amp;&amp; (consonants &lt; m || <span class="built_in">len</span>(occur) &lt; <span class="number">5</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> vowels[word[j]] &#123;</span><br><span class="line">					occur[word[j]]++</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					consonants++</span><br><span class="line">				&#125;</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> consonants &gt;= m &amp;&amp; <span class="built_in">len</span>(occur) == <span class="number">5</span> &#123;</span><br><span class="line">                <span class="comment">//对于当前子串来说已经满足了条件, 那么,后面继续添加长度就必定满足条件, 不用判断</span></span><br><span class="line">				res += <span class="type">int64</span>(n - j + <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//接下来当前子串开头i要向后移位, 需要判断是否会对当前的满足条件造成影响</span></span><br><span class="line">			<span class="keyword">if</span> vowels[word[i]] &#123;</span><br><span class="line">				occur[word[i]]--</span><br><span class="line">				<span class="keyword">if</span> occur[word[i]] == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="built_in">delete</span>(occur, word[i])</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				consonants--</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count(k) - count(k+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1920-基于排列构建数组"><a href="#1920-基于排列构建数组" class="headerlink" title="1920.基于排列构建数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/build-array-from-permutation/description/?envType=daily-question&envId=2025-05-06">1920.基于排列构建数组</a></h2><p>从题目来说, 不考虑优化就是一件非常简单的任务.解法二的思路比较有意思. 这对数据来说, 所有的数据都不会超过1000的大小. 对于如何原地交换的问题在于, 直接交换, 可能只有一个数据满足要求, 会导致另一个数据失效, 同时也会打乱原来排序号的数据. 关键在于如何能够在一个地方同时存储两个数据, 一个代表的是原数据, 另一个代表的是更改后的数据.<br>通过观察数据最大到999, 所以可以将更改数据整体存储在1000位以上, 在通过第二遍历就能够将原数据去除, 只保留1000位以上的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i,_ :=  <span class="keyword">range</span> nums &#123;</span><br><span class="line">        nums[i] += <span class="number">1000</span>*(nums[nums[i]]%<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i,_ := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        nums[i] /= <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] buildArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            nums[i] += <span class="number">1000</span>*(nums[nums[i]]%<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            nums[i] /= <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是会降低运行速度, 毕竟变成O(n^2)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">huning</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/05/06/Leetcode&amp;%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%9D%E8%80%83/">http://example.com/2025/05/06/Leetcode&amp;%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%9D%E8%80%83/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2025/05/06/dHhEmUxjBsNC4Fz.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/05/05/%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="手写RPC框架学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">手写RPC框架学习</div></div><div class="info-2"><div class="info-item-1">手写RPC框架学习什么是RPCRPC(Remote Procedure Call)从字面意思就是远程程序请求, 我的理解就是, 将能够分离的服务进行解耦合, 暴露出接口, 让其他服务能够通过网络直接请求调用. 能够降低服务之间的耦合度, 防止崩溃, 同时提高服务的可维护程度. 通过RPC框架甚至不需要构建http请求, 相当与是RPC框架提供了一个方法, 隐藏了构建http请求的过程, 只需要关注传入的参数, 和传回的数据就足够了.  关于RPC的一些问题目前我理解的RPC框架相当于是一个引入的包, 通过调用相关的方法就能够直接访问相关的服务, 当然对于服务方应该也是使用相同的协议的. 写RPC框架就像是在写一个现成的包一样, 其他服务通过应用这个包, 然后使用这个包中的工具, 就可以实现RPC的功能. yu-RPC简易版初始化结构构建了四个模块exam-consumer,exam-provider, example-common, yu-rpc-easy. 取模拟三个端口, 其中的common模块相当于是公共模块,  使用rpc框架构成服务, 在消费者和生产者之间提供桥梁,...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://s2.loli.net/2025/05/06/dHhEmUxjBsNC4Fz.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">huning</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%9D%E8%80%83"><span class="toc-number">1.</span> <span class="toc-text">Leetcode&amp;&amp;洛谷刷题记录与思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#p-7517"><span class="toc-number">1.1.</span> <span class="toc-text">p 7517</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E6%A0%B9%E6%8D%AE%E5%AD%A6%E4%B9%A0%E5%86%99%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">自己根据学习写的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p-2701"><span class="toc-number">1.2.</span> <span class="toc-text">p 2701</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p-2678"><span class="toc-number">1.3.</span> <span class="toc-text">p 2678</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">1.4.</span> <span class="toc-text">14、最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">11、盛水最多的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#209%E3%80%81%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.</span> <span class="toc-text">209、长度最小的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%A7%A3%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">解法一、滑动窗口解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p1002"><span class="toc-number">1.7.</span> <span class="toc-text">p1002</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p1004"><span class="toc-number">1.8.</span> <span class="toc-text">p1004</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1010"><span class="toc-number">1.9.</span> <span class="toc-text">1010</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E7%9A%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.10.</span> <span class="toc-text">DFS的算法学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.11.</span> <span class="toc-text">BFS的学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%97%E4%B8%B2"><span class="toc-number">1.12.</span> <span class="toc-text">30、串联所有单词的字串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#135%E3%80%81%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">1.13.</span> <span class="toc-text">135、分发糖果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">1.14.</span> <span class="toc-text">42、接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">1.15.</span> <span class="toc-text">202.快乐数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2"><span class="toc-number">1.16.</span> <span class="toc-text">6、z字型变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1715%E3%80%81%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6IV"><span class="toc-number">1.17.</span> <span class="toc-text">1715、分割回文字符IV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4"><span class="toc-number">1.18.</span> <span class="toc-text">汇总区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3306-%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3%E5%AD%97%E6%AF%8D%E8%AE%A1%E6%95%B0-II"><span class="toc-number">1.19.</span> <span class="toc-text">3306.元音辅音字母计数 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1920-%E5%9F%BA%E4%BA%8E%E6%8E%92%E5%88%97%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">1.20.</span> <span class="toc-text">1920.基于排列构建数组</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/06/Leetcode&amp;%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%9D%E8%80%83/" title="Leetcode&amp;洛谷刷题记录与思考">Leetcode&amp;洛谷刷题记录与思考</a><time datetime="2025-05-06T10:47:42.000Z" title="Created 2025-05-06 18:47:42">2025-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="手写RPC框架学习">手写RPC框架学习</a><time datetime="2025-05-05T06:12:50.000Z" title="Created 2025-05-05 14:12:50">2025-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/07/Hgame2025%E8%B5%9B%E5%90%8E%E5%AD%A6%E4%B9%A0/" title="Hgame2025赛后学习">Hgame2025赛后学习</a><time datetime="2025-03-07T08:45:22.000Z" title="Created 2025-03-07 16:45:22">2025-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/07/Go%E5%85%AB%E8%82%A1/" title="Go八股">Go八股</a><time datetime="2025-03-07T08:43:36.000Z" title="Created 2025-03-07 16:43:36">2025-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/05/Linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8D%A3%E9%BC%93%E6%8C%87%E5%8C%97/" title="Linux云服务器捣鼓指北">Linux云服务器捣鼓指北</a><time datetime="2025-03-05T06:08:52.000Z" title="Created 2025-03-05 14:08:52">2025-03-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By huning</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>